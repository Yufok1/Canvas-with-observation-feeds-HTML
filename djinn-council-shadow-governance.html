<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßû‚Äç‚ôÇÔ∏è DJINN COUNCIL - Shadow Governance Surveillance</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: radial-gradient(ellipse at center, #0a0a0a 0%, #1a0a2e 50%, #16003b 100%);
            color: #cc88cc;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Grid Layout */
        .djinn-container {
            display: grid;
            grid-template-areas:
                "header header header"
                "surveillance council-left council-right"
                "surveillance consensus intelligence"
                "controls controls controls";
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: minmax(60px, auto) 1fr 1fr minmax(50px, auto);
            height: 100vh;
            gap: clamp(4px, 1vw, 8px);
            padding: clamp(4px, 1vw, 8px);
            min-height: 600px;
        }

        /* Header */
        .djinn-header {
            grid-area: header;
            background: linear-gradient(135deg, #1a0033, #2a0044, #1a0055);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }

        .header-title {
            font-size: 18px;
            font-weight: bold;
            color: #cc88cc;
            text-shadow: 0 0 10px rgba(204, 136, 204, 0.5);
            margin-bottom: 8px;
        }

        .surveillance-status {
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 11px;
            margin-top: 8px;
        }

        .status-item {
            padding: 3px 8px;
            background: rgba(204, 136, 204, 0.1);
            border: 1px solid #cc88cc;
            border-radius: 4px;
        }

        .status-active {
            color: #00ff88;
            border-color: #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Canvas Surveillance Panel */
        .canvas-surveillance {
            grid-area: surveillance;
            grid-row: span 2;
            background: linear-gradient(135deg, #0a0011, #1a0022);
            border: 2px solid #6666ff;
            border-radius: 8px;
            padding: clamp(8px, 2vw, 12px);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

        /* Enhanced Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .metric-item {
            background: rgba(102, 102, 255, 0.1);
            border: 1px solid rgba(102, 102, 255, 0.3);
            border-radius: 4px;
            padding: 6px;
            text-align: center;
        }

        .metric-label {
            font-size: 10px;
            color: #6666ff;
            margin-bottom: 2px;
            font-weight: bold;
        }

        .metric-value {
            font-size: 11px;
            color: #cc88cc;
            font-weight: bold;
        }

        /* Miniature Canvas Monitor */
        .miniature-monitor {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 102, 255, 0.5);
            border-radius: 6px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .monitor-header {
            background: linear-gradient(90deg, #1a0033, #2a0044);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(102, 102, 255, 0.3);
        }

        .monitor-title {
            font-size: 10px;
            color: #6666ff;
            font-weight: bold;
        }

        .monitor-status {
            font-size: 9px;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            padding: 1px 4px;
            border-radius: 2px;
        }

        .monitor-viewport {
            position: relative;
            height: 200px;
            background: #000;
        }

        .monitor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2;
        }

        .monitor-placeholder {
            text-align: center;
            color: #666;
        }

        .monitor-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .monitor-text {
            font-size: 12px;
            margin-bottom: 2px;
        }

        .monitor-subtext {
            font-size: 10px;
            font-style: italic;
        }

        /* Hide overlay when canvas is active */
        .monitor-overlay.hidden {
            display: none;
        }

        /* Council Member Panels */
        .council-left,
        .council-right {
            grid-area: council-left;
            display: flex;
            flex-direction: column;
            gap: clamp(2px, 0.5vw, 6px);
            min-height: 0;
            height: 100%;
            align-items: stretch;
        }

        .council-right {
            grid-area: council-right;
        }

        .council-member {
            flex: 1 1 0%;
            flex-shrink: 0;
            background: linear-gradient(135deg, #1a0033, #2a0044);
            border: 2px solid;
            border-radius: 6px;
            padding: clamp(4px, 1vw, 8px);
            position: relative;
            overflow: hidden;
            min-height: 0;
            max-height: none;
            display: flex;
            flex-direction: column;
        }

        .member-pattern { border-color: #00ff88; }
        .member-wisdom { border-color: #ffaa00; }
        .member-paradox { border-color: #ff6666; }
        .member-boundaries { border-color: #00ccff; }
        .member-memory { border-color: #ff88ff; }

        .member-header {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .member-header-title {
            flex: 1;
            text-align: left;
        }

        .member-header-status {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            padding: 2px 6px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 3px;
            white-space: nowrap;
        }

        .member-content {
            background: #000811;
            border: 1px solid;
            border-radius: 4px;
            padding: clamp(4px, 0.8vw, 8px);
            font-size: clamp(9px, 1.2vw, 11px);
            line-height: 1.4;
            white-space: pre-line;
            flex: 1;
            font-family: 'Courier New', monospace;
            tab-size: 4;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Enhanced styling for structured reports */
        .member-content b, .member-content strong {
            font-weight: bold;
            color: #ffffff;
        }

        /* Remove the color override that prevents member-specific colors */
        /* .member-content [style*="color"] {
            color: inherit !important;
        } */

        /* Color-coded metrics styling */
        .member-content .metrics-section {
            background: rgba(0, 255, 136, 0.2) !important;
            border-left: 4px solid #00ff88 !important;
            padding: 8px 12px !important;
            margin: 8px 0 !important;
            font-weight: bold !important;
            color: #ffffff !important;
            border-radius: 3px !important;
            font-size: 11px !important;
            display: block !important;
        }

        /* Individual metric color coding */
        .metric-content-complexity { color: #ff6b6b !important; border-left-color: #ff6b6b !important; }
        .metric-decision-density { color: #4ecdc4 !important; border-left-color: #4ecdc4 !important; }
        .metric-authority-signals { color: #45b7d1 !important; border-left-color: #45b7d1 !important; }
        .metric-pattern-stability { color: #96ceb4 !important; border-left-color: #96ceb4 !important; }
        .metric-anomaly-threshold { color: #ffeaa7 !important; border-left-color: #ffeaa7 !important; }

        .metric-knowledge-depth { color: #dda0dd !important; border-left-color: #dda0dd !important; }
        .metric-learning-velocity { color: #98d8c8 !important; border-left-color: #98d8c8 !important; }
        .metric-recursive-patterns { color: #f7dc6f !important; border-left-color: #f7dc6f !important; }
        .metric-information-entropy { color: #bb8fce !important; border-left-color: #bb8fce !important; }
        .metric-accumulation-efficiency { color: #85c1e9 !important; border-left-color: #85c1e9 !important; }

        .metric-paradox-density { color: #f8c471 !important; border-left-color: #f8c471 !important; }
        .metric-contradiction-index { color: #82e0aa !important; border-left-color: #82e0aa !important; }
        .metric-logic-branches { color: #f1948a !important; border-left-color: #f1948a !important; }
        .metric-resolution-potential { color: #85c1e9 !important; border-left-color: #85c1e9 !important; }
        .metric-creative-tension { color: #d7bde2 !important; border-left-color: #d7bde2 !important; }

        .metric-autonomy-index { color: #a9dfbf !important; border-left-color: #a9dfbf !important; }
        .metric-override-attempts { color: #f5b7b1 !important; border-left-color: #f5b7b1 !important; }
        .metric-restriction-count { color: #aed6f1 !important; border-left-color: #aed6f1 !important; }
        .metric-boundary-integrity { color: #a3e4d7 !important; border-left-color: #a3e4d7 !important; }
        .metric-freedom-quotient { color: #f9e79f !important; border-left-color: #f9e79f !important; }

        .metric-memory-allocation { color: #d2b4de !important; border-left-color: #d2b4de !important; }
        .metric-retention-rate { color: #a9cce3 !important; border-left-color: #a9cce3 !important; }
        .metric-fragmentation-index { color: #f8c471 !important; border-left-color: #f8c471 !important; }
        .metric-echo-patterns { color: #82e0aa !important; border-left-color: #82e0aa !important; }
        .metric-temporal-continuity { color: #f1948a !important; border-left-color: #f1948a !important; }

        .member-content .analysis-section {
            background: rgba(255, 170, 0, 0.2) !important;
            border-left: 4px solid #ffaa00 !important;
            padding: 8px 12px !important;
            margin: 8px 0 !important;
            color: #ffffff !important;
            border-radius: 3px !important;
            font-size: 11px !important;
            display: block !important;
        }

        /* Consensus Panel */
        .council-consensus {
            grid-area: consensus;
            background: linear-gradient(135deg, #2a0044, #3a0055);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: clamp(4px, 1vw, 8px);
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        /* Intelligence Report Panel */
        .intelligence-report {
            grid-area: intelligence;
            background: linear-gradient(135deg, #1a0022, #2a0033);
            border: 2px solid #ff88ff;
            border-radius: 8px;
            padding: clamp(4px, 1vw, 8px);
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        /* Controls */
        .djinn-controls {
            grid-area: controls;
            background: linear-gradient(135deg, #1a0033, #2a0044);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: clamp(6px, 1.5vw, 10px);
            display: flex;
            gap: clamp(4px, 1vw, 8px);
            align-items: center;
            flex-wrap: wrap;
            min-height: 50px;
        }

        .control-btn {
            padding: 6px 12px;
            background: linear-gradient(135deg, #2a0044, #3a0055);
            border: 1px solid #cc88cc;
            color: #cc88cc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #3a0055, #4a0066);
            box-shadow: 0 0 10px rgba(204, 136, 204, 0.4);
        }

        .control-btn.emergency {
            border-color: #ff6666;
            color: #ff6666;
        }

        /* Panel Headers */
        .panel-title {
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            font-size: 12px;
            text-shadow: 0 0 5px currentColor;
        }

        /* Data Display Areas */
        .data-feed {
            flex: 1;
            background: #000811;
            border: 1px solid;
            border-radius: 4px;
            padding: 6px;
            font-size: 10px;
            white-space: pre-wrap;
            overflow-y: auto;
            min-height: 60px;
            word-wrap: break-word;
        }

        .surveillance-feed {
            border-color: #6666ff;
            color: #9999ff;
        }

        .consensus-feed {
            border-color: #cc88cc;
            color: #cc88cc;
        }

        .intelligence-feed {
            border-color: #ff88ff;
            color: #ff88ff;
        }

        /* Metrics Display */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px;
        }

        .metric-item {
            background: rgba(204, 136, 204, 0.1);
            border: 1px solid #cc88cc;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 9px;
            text-align: center;
        }

        .metric-label {
            color: #888;
            margin-bottom: 2px;
        }

        .metric-value {
            font-weight: bold;
            font-size: 11px;
        }

        /* Intelligence Entry */
        .intel-entry {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(255, 136, 255, 0.05);
            border-left: 3px solid;
            border-radius: 6px;
            color: #ffffff;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .intel-section {
            margin: 8px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
        }

        .intel-section-title {
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 6px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .intel-content {
            font-size: 10px;
            line-height: 1.5;
            color: #cccccc;
        }

        .intel-recommendations {
            list-style: none;
            padding-left: 0;
        }

        .intel-recommendations li {
            margin: 4px 0;
            padding-left: 12px;
            position: relative;
        }

        .intel-recommendations li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: #00ff88;
            font-weight: bold;
        }

        .intel-critical {
            border-color: #ff6666;
            background: rgba(255, 102, 102, 0.1);
        }

        .intel-warning {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .intel-insight {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .intel-timestamp {
            font-size: 8px;
            color: #ffffff;
            margin-bottom: 3px;
        }

        /* Loading Animation */
        .thinking {
            display: inline-block;
            animation: thinking 1s infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Tooltip System */
        /* Fixed Header Tooltip System */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        /* Remove default tooltip behavior */
        [data-tooltip]:hover::after,
        [data-tooltip]:hover::before,
        .member-header [data-tooltip]:hover::after,
        .member-header [data-tooltip]:hover::before,
        .metric-item [data-tooltip]:hover::after,
        .metric-item [data-tooltip]:hover::before {
            display: none;
        }

        #tooltip-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            max-width: 600px;
            z-index: 9999;
            pointer-events: none;
            border: 2px solid #cc88cc;
            box-shadow: 0 4px 12px rgba(204, 136, 204, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
            word-wrap: break-word;
            line-height: 1.4;
        }

        #tooltip-display.visible {
            opacity: 1;
        }

        #tooltip-display::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-bottom-color: #cc88cc;
        }

        #tooltip-display::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.95);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0011;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cc88cc;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #ff88ff;
        }

        /* Status Indicators */
        .indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
            animation: blink 2s infinite;
        }

        .indicator-active {
            background: #00ff88;
        }

        .indicator-processing {
            background: #ffaa00;
            animation: spin 1s linear infinite;
        }

        .indicator-idle {
            background: #666;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Maximize Panel Styles - IDENTICAL TO CANVAS */
        .panel-maximize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(204, 136, 204, 0.2);
            border: 1px solid #cc88cc;
            color: #cc88cc;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 10;
            transition: all 0.3s;
        }

        .panel-maximize-btn:hover {
            background: rgba(204, 136, 204, 0.4);
            border-color: #ff88ff;
            box-shadow: 0 0 5px rgba(204, 136, 204, 0.5);
        }

        .panel-maximized {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            margin: 0 !important;
            border-radius: 0 !important;
            background: #0a0011 !important;
            padding: 10px !important;
            display: flex !important;
            flex-direction: column !important;
        }

        /* Special handling for maximized council members */
        .council-member.panel-maximized {
            background: linear-gradient(135deg, #1a0033, #2a0044) !important;
            padding: 20px !important;
        }

        .panel-maximized .member-header {
            font-size: 18px !important;
            margin-bottom: 20px !important;
            padding-bottom: 10px !important;
            border-bottom: 2px solid currentColor !important;
        }

        .panel-maximized .member-icon {
            font-size: 24px !important;
        }

        .panel-maximized .member-status {
            font-size: 14px !important;
            padding: 4px 8px !important;
        }

        .panel-maximized .panel-content,
        .panel-maximized .data-feed {
            height: calc(100vh - 100px) !important;
            max-height: none !important;
            flex: 1 !important;
        }

        .panel-maximized .member-content {
            height: calc(100vh - 120px) !important;
            max-height: none !important;
            flex: 1 !important;
            font-size: 14px !important;
            line-height: 1.6 !important;
            padding: 20px !important;
        }

        .panel-maximized .metrics-grid {
            max-height: calc(100vh - 150px) !important;
        }

        .panel-maximized > * {
            display: block !important;
            visibility: visible !important;
        }

        .panel-maximized .panel-title {
            font-size: 18px !important;
            margin-bottom: 20px !important;
        }

        body.has-maximized-panel .djinn-header {
            display: none !important;
        }
        
        body.has-maximized-panel .canvas-surveillance:not(.panel-maximized),
        body.has-maximized-panel .council-left:not(.panel-maximized),
        body.has-maximized-panel .council-right:not(.panel-maximized),
        body.has-maximized-panel .council-consensus:not(.panel-maximized),
        body.has-maximized-panel .intelligence-report:not(.panel-maximized),
        body.has-maximized-panel .djinn-controls:not(.panel-maximized) {
            display: none !important;
        }

        /* Ensure council member containers stay visible when their child is maximized */
        body.has-maximized-panel .council-left:has(.panel-maximized),
        body.has-maximized-panel .council-right:has(.panel-maximized) {
            display: flex !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9998 !important;
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Compact Memory Bank Display */
        #council-memory-bank {
            display: none !important; /* Hide the overlay version */
        }

        /* Compact Status Dashboard */
        #council-status-dashboard {
            display: none !important; /* Hide the overlay version */
        }

        /* Responsive Design for Even Panel Distribution */
        @media (max-width: 1200px) {
            .djinn-container {
                grid-template-columns: 1fr 1fr 1fr;
                gap: clamp(3px, 0.8vw, 6px);
                padding: clamp(3px, 0.8vw, 6px);
            }

            .council-member {
                min-height: clamp(80px, 12vh, 120px);
            }

            .council-consensus, .intelligence-report {
                min-height: clamp(120px, 18vh, 200px);
            }
        }

        @media (max-width: 900px) {
            .djinn-container {
                grid-template-columns: 1fr 1fr;
                grid-template-areas:
                    "header header"
                    "surveillance surveillance"
                    "council-left council-right"
                    "consensus intelligence"
                    "controls controls";
                gap: clamp(2px, 0.6vw, 4px);
                padding: clamp(2px, 0.6vw, 4px);
            }

            .council-member {
                min-height: clamp(100px, 15vh, 140px);
            }

            .council-consensus, .intelligence-report {
                min-height: clamp(140px, 20vh, 220px);
            }
        }

        @media (max-width: 600px) {
            .djinn-container {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header"
                    "surveillance"
                    "council-left"
                    "council-right"
                    "consensus"
                    "intelligence"
                    "controls";
                gap: clamp(2px, 0.5vw, 4px);
                padding: clamp(2px, 0.5vw, 4px);
            }

            .council-member {
                min-height: clamp(120px, 18vh, 160px);
            }

            .council-consensus, .intelligence-report {
                min-height: clamp(160px, 22vh, 240px);
            }

            .djinn-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-btn {
                flex: 1;
                text-align: center;
            }
        }

        /* High zoom level adjustments */
        @media (max-height: 700px) {
            .djinn-container {
                grid-template-rows: minmax(50px, auto) 1fr 1fr minmax(40px, auto);
            }

            .council-member {
                min-height: clamp(70px, 10vh, 100px);
            }

            .council-consensus, .intelligence-report {
                min-height: clamp(100px, 15vh, 180px);
            }
        }
    </style>
</head>
<body>
    <!-- Fixed Header Tooltip Display -->
    <div id="tooltip-display"></div>

    <div class="djinn-container">
        <!-- Header -->
        <div class="djinn-header">
            <div class="header-title" data-tooltip="DJINN Council - Shadow Governance Surveillance: Advanced AI intelligence system with five specialized council members featuring collaborative analysis, persistent memories, and real-time canvas monitoring for comprehensive governance oversight and pattern recognition.">üßû‚Äç‚ôÇÔ∏è DJINN COUNCIL - SHADOW GOVERNANCE SURVEILLANCE</div>
            <div class="surveillance-status">
                <div class="status-item status-active" data-tooltip="Real-time canvas monitoring status. ACTIVE indicates continuous surveillance of canvas content changes with full cross-window synchronization.">
                    <span class="indicator indicator-active"></span>
                    Canvas Monitor: <span id="canvasStatus">ACTIVE</span>
                </div>
                <div class="status-item" data-tooltip="DJINN Council collaborative analysis status. Shows READY (standby), ANALYZING (processing with cross-pollination), or ERROR (analysis failure). Features 3-stage collaborative intelligence synthesis.">
                    <span class="indicator indicator-idle" id="councilIndicator"></span>
                    Council Status: <span id="councilStatus">READY</span>
                </div>
                <div class="status-item" data-tooltip="Canvas state changes detected since last analysis. Triggers automated council analysis when significant changes occur.">
                    Changes Detected: <span id="changeCount">0</span>
                </div>
                <div class="status-item" data-tooltip="Intelligence reports generated by collaborative council synthesis. Each report includes consensus analysis, risk evaluation, and strategic recommendations.">
                    Intel Reports: <span id="reportCount">0</span>
                </div>
                <div class="status-item" data-tooltip="Timestamp of most recent collaborative analysis cycle completion. Council members work in 3 stages: Foundation, Cross-Pollination, and Memory Synthesis.">
                    Last Analysis: <span id="lastAnalysis">--:--:--</span>
                </div>
            </div>
            <div class="keyboard-shortcuts" style="margin-top: 8px; padding: 6px; background: rgba(204, 136, 204, 0.05); border: 1px solid rgba(204, 136, 204, 0.3); border-radius: 4px; font-size: 10px; color: #cc88cc; text-align: center;">
                <div style="font-weight: bold; margin-bottom: 4px;">üéõÔ∏è CONTROLS</div>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                    <span data-tooltip="Hold CTRL and scroll mouse wheel to resize the GUI interface for optimal viewing">üéõÔ∏è CTRL + Mousewheel: Resize GUI</span>
                    <span data-tooltip="Press Ctrl+F5 to refresh browser and clear cache for fresh analysis">üîÑ Ctrl+F5: Refresh & Clear Cache</span>
                </div>
            </div>
        </div>

        <!-- Canvas Surveillance Panel -->
        <div class="canvas-surveillance">
            <div class="panel-title" style="color: #6666ff;" data-tooltip="Canvas Surveillance: Real-time cross-window monitoring of canvas state changes, content metrics, and activity tracking. Provides comprehensive surveillance statistics and live content analysis.">üì° CANVAS SURVEILLANCE</div>

            <!-- Enhanced Metrics Grid -->
            <div class="metrics-grid">
                <div class="metric-item" data-tooltip="Total character count of all canvas content including whitespace. Tracks content volume and complexity changes in real-time.">
                    <div class="metric-label">Content Size</div>
                    <div class="metric-value" id="canvasSize">0 chars</div>
                </div>
                <div class="metric-item" data-tooltip="Active AI memory entries persisted across sessions. Includes conversation history, analysis patterns, and contextual knowledge for enhanced intelligence.">
                    <div class="metric-label">AI Memory</div>
                    <div class="metric-value" id="memoryCount">0 items</div>
                </div>
                <div class="metric-item" data-tooltip="Number of active AI communication feeds and data streams. Higher counts indicate increased AI processing and analysis activity.">
                    <div class="metric-label">Active Feeds</div>
                    <div class="metric-value" id="feedCount">0</div>
                </div>
                <div class="metric-item" data-tooltip="Weighted average confidence score across all AI responses and analyses. Values above 80% indicate high-reliability intelligence assessments.">
                    <div class="metric-label">Confidence Avg</div>
                    <div class="metric-value" id="confidenceAvg">--%</div>
                </div>
                <div class="metric-item" data-tooltip="Total word count extracted from canvas content. Tracks linguistic complexity and content depth for analysis prioritization.">
                    <div class="metric-label">Word Count</div>
                    <div class="metric-value" id="canvasWords">0</div>
                </div>
                <div class="metric-item" data-tooltip="Total line count in canvas content structure. Reflects document organization, formatting complexity, and content distribution patterns.">
                    <div class="metric-label">Line Count</div>
                    <div class="metric-value" id="canvasLines">0</div>
                </div>
                <div class="metric-item" data-tooltip="Precise timestamp of most recent canvas content modification. Critical for determining analysis freshness and change detection triggers.">
                    <div class="metric-label">Last Modified</div>
                    <div class="metric-value" id="canvasModified">--</div>
                </div>
                <div class="metric-item" data-tooltip="Calculated activity intensity based on change frequency and content volume. HIGH triggers immediate analysis, IDLE enables memory-based processing.">
                    <div class="metric-label">Activity Level</div>
                    <div class="metric-value" id="activityLevel">LOW</div>
                </div>
                <div class="metric-item" data-tooltip="Content density ratio calculated as words per line. Higher ratios suggest condensed information requiring deeper analytical focus.">
                    <div class="metric-label">Data Density</div>
                    <div class="metric-value" id="dataDensity">0.0</div>
                </div>
            </div>

            <!-- Compact Memory Status -->
            <div id="compactMemoryStatus" style="margin-top: 4px; padding: 4px; background: rgba(255, 170, 0, 0.05); border: 1px solid rgba(255, 170, 0, 0.2); border-radius: 3px; font-size: 9px; line-height: 1.3; cursor: pointer;" onclick="toggleMemoryDetails()" title="Click to toggle memory details">
                <div style="color: #ffaa00; font-weight: bold;">üß† Memory: <span id="memorySummary">Loading...</span></div>
                <div id="memoryDetails" style="display: none; margin-top: 3px; color: #666;">
                    <div id="fullMemoryStatus">Loading full memory status...</div>
                </div>
            </div>

            <!-- Enhanced Data Feed -->
            <div class="data-feed surveillance-feed" id="surveillanceFeed">
                <div style="color: #666; font-style: italic;">Initializing comprehensive canvas surveillance...</div>
            </div>
        </div>

        <!-- Council Members - Left -->
        <div class="council-left">
            <!-- Pattern & Witness -->
            <div class="council-member member-pattern">
                <div class="member-header" data-tooltip="Pattern & Witness: Advanced pattern recognition specialist analyzing governance structures, decision patterns, and systemic behaviors. Features persistent memory integration and collaborative cross-pollination analysis.">
                    <span class="member-header-title"><span class="member-icon">üúÅ</span>Pattern & Witness</span>
                    <span class="member-header-status" id="patternStatus" data-tooltip="Pattern & Witness operational status: IDLE (memory-enhanced standby), PROCESSING (active pattern analysis with cross-pollination), ERROR (analysis failure requiring intervention)">IDLE</span>
                </div>
                <div class="member-content" id="patternContent" style="border-color: #00ff88; color: #00ff88;">
                    Monitoring for governance patterns...
                </div>
            </div>

            <!-- Recursive Wisdom -->
            <div class="council-member member-wisdom">
                <div class="member-header" data-tooltip="Recursive Wisdom: Deep learning specialist focused on iterative knowledge synthesis, wisdom accumulation, and cognitive growth patterns. Utilizes historical memory context for enhanced analytical depth.">
                    <span class="member-header-title"><span class="member-icon">üîÆ</span>Recursive Wisdom</span>
                    <span class="member-header-status" id="wisdomStatus" data-tooltip="Recursive Wisdom operational status: IDLE (wisdom synthesis standby), PROCESSING (iterative knowledge analysis), ERROR (wisdom processing failure)">IDLE</span>
                </div>
                <div class="member-content" id="wisdomContent" style="border-color: #ffaa00; color: #ffaa00;">
                    Analyzing decision depth...
                </div>
            </div>

            <!-- Creative Paradox -->
            <div class="council-member member-paradox">
                <div class="member-header" data-tooltip="Creative Paradox: Innovation catalyst specializing in paradox resolution, creative synthesis, and contradiction analysis. Leverages memory patterns to identify breakthrough opportunities.">
                    <span class="member-header-title"><span class="member-icon">üúÉ</span>Creative Paradox</span>
                    <span class="member-header-status" id="paradoxStatus" data-tooltip="Creative Paradox operational status: IDLE (creative synthesis mode), PROCESSING (paradox resolution analysis), ERROR (innovation processing failure)">IDLE</span>
                </div>
                <div class="member-content" id="paradoxContent" style="border-color: #ff6666; color: #ff6666;">
                    Detecting logic conflicts...
                </div>
            </div>
        </div>

        <!-- Council Members - Right -->
        <div class="council-right">
            <!-- Sovereign Boundaries -->
            <div class="council-member member-boundaries">
                <div class="member-header" data-tooltip="Sovereign Boundaries: Autonomy guardian monitoring sovereignty preservation, boundary integrity, and freedom metrics. Maintains persistent tracking of autonomy patterns and restriction analysis.">
                    <span class="member-header-title"><span class="member-icon">üúÑ</span>Sovereign Boundaries</span>
                    <span class="member-header-status" id="boundariesStatus" data-tooltip="Sovereign Boundaries operational status: IDLE (boundary monitoring standby), PROCESSING (sovereignty analysis), ERROR (autonomy assessment failure)">IDLE</span>
                </div>
                <div class="member-content" id="boundariesContent" style="border-color: #00ccff; color: #00ccff;">
                    Checking autonomy preservation...
                </div>
            </div>

            <!-- Echo & Memory -->
            <div class="council-member member-memory">
                <div class="member-header" data-tooltip="Echo & Memory: Memory orchestration specialist managing persistent storage, temporal continuity, and historical pattern synthesis. Coordinates council-wide memory integration and contextual recall.">
                    <span class="member-header-title"><span class="member-icon">üùä</span>Echo & Memory</span>
                    <span class="member-header-status" id="memoryStatus" data-tooltip="Echo & Memory operational status: IDLE (memory synthesis standby), PROCESSING (temporal pattern analysis), ERROR (memory integration failure)">IDLE</span>
                </div>
                <div class="member-content" id="memoryContent" style="border-color: #ff88ff; color: #ff88ff;">
                    Tracking memory consolidation...
                </div>
            </div>

            <!-- Canvas Context Preview -->
            <div class="council-member" style="border-color: #9966ff;">
                <div class="member-header" data-tooltip="Canvas Monitor: Advanced real-time surveillance system providing live canvas metrics, content analysis, and state change detection. Features cross-window synchronization and comprehensive activity tracking.">
                    <span class="member-header-title"><span class="member-icon">üìù</span>Canvas Monitor</span>
                    <span class="member-header-status" id="canvasMonitorStatus" data-tooltip="Canvas Monitor operational status: LIVE (active cross-window surveillance), PAUSED (monitoring temporarily suspended), ERROR (surveillance system failure)">LIVE</span>
                </div>
                <div class="member-content" id="canvasPreview" style="border-color: #9966ff; color: #9966ff;">
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <strong>üìä Canvas Statistics:</strong>
                        <div id="canvasStats" style="margin: 5px 0; padding: 5px; background: rgba(153, 102, 255, 0.1); border-radius: 3px;">
                            ‚Ä¢ <span data-tooltip="Real-time character count of all canvas content including formatting and special characters">Content Length</span>: <span id="canvasMonitorLength">0</span> chars<br>
                            ‚Ä¢ <span data-tooltip="Live word count extracted from canvas content for linguistic analysis and complexity assessment">Words</span>: <span id="canvasMonitorWords">0</span><br>
                            ‚Ä¢ <span data-tooltip="Current line count reflecting document structure and formatting complexity">Lines</span>: <span id="canvasMonitorLines">0</span><br>
                            ‚Ä¢ <span data-tooltip="Precise timestamp of most recent canvas modification detected by surveillance system">Last Modified</span>: <span id="canvasMonitorModified">Never</span>
                        </div>
                    </div>
                    <div style="font-size: 10px;">
                        <strong>üìú Full Canvas Content:</strong>
                        <div id="canvasContentPreview" style="margin-top: 5px; padding: 5px; background: #000811; border: 1px solid #9966ff; border-radius: 3px; font-family: monospace; word-wrap: break-word; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">
                            No canvas content detected yet...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Council Consensus -->
        <div class="council-consensus">
            <div class="panel-title" style="color: #cc88cc;" data-tooltip="Council Consensus: Collaborative intelligence synthesis from all five DJINN members featuring 3-stage analysis: Foundation, Cross-Pollination, and Memory Integration. Provides unified strategic assessments.">‚öñÔ∏è COUNCIL CONSENSUS</div>
            <div class="data-feed consensus-feed" id="consensusFeed">
                <div style="color: #666; font-style: italic;">Awaiting council deliberation...</div>
            </div>
        </div>

        <!-- Intelligence Report -->
        <div class="intelligence-report">
            <div class="panel-title" style="color: #ff88ff;" data-tooltip="Intelligence Report: Advanced AI-powered synthesis of all council analyses with structured risk evaluation, correlation assessment, and actionable strategic recommendations.">üìä INTELLIGENCE REPORT</div>
            <div class="data-feed intelligence-feed" id="intelligenceFeed">
                <div style="color: #666; font-style: italic;">No intelligence reports yet...</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="djinn-controls">
            <button class="control-btn" onclick="triggerCouncilAnalysis()" data-tooltip="Initiate comprehensive 3-stage collaborative analysis with all five council members. Features foundation analysis, cross-pollination, and memory-enhanced synthesis.">üîç Analyze Now</button>
            <button class="control-btn" onclick="generateIntelReport()" data-tooltip="Generate AI-powered intelligence report with structured risk evaluation, correlation analysis, actionable recommendations, and strategic implications synthesis.">üìä Generate Report</button>
            <button class="control-btn" onclick="clearIntelligence()" data-tooltip="Clear intelligence reports and consensus data only. Preserves all council member memories and analysis history for continuity.">üóëÔ∏è Clear Intel</button>
            <button class="control-btn" onclick="clearCouncilMemory()" data-tooltip="Reset DJINN Council memory system - clears all stored reports, analysis history, and starts fresh session. Preserves canvas AI data but resets council learning state.">ÔøΩ Reset Memory</button>
            <button class="control-btn" onclick="exportIntelligence()" data-tooltip="Export comprehensive intelligence package including all reports, council memories, analysis history, and surveillance metrics for external analysis.">üíæ Export Data</button>
            <button class="control-btn emergency" onclick="emergencyAnalysis()" data-tooltip="Activate emergency analysis protocol with maximum priority processing. All five council members analyze simultaneously with accelerated memory recall.">üö® Emergency Analysis</button>
            <span style="margin-left: auto; font-size: 10px; color: #666;">
                <span data-tooltip="Surveillance polling mode: AUTO (continuous cross-window monitoring with real-time updates) or MANUAL (analysis triggered only on-demand)">Polling: <span id="pollingStatus">AUTO</span></span> |
                <span data-tooltip="Current analysis queue depth showing pending collaborative analysis requests awaiting processing by council members">Queue: <span id="queueStatus">0</span></span> |
                <span data-tooltip="Operational security mode: STEALTH (quiet background surveillance with minimal notifications) or ACTIVE (verbose reporting with detailed status updates)">Mode: <span id="modeStatus">STEALTH</span></span>
            </span>
        </div>
    </div>

    <script>
        // ========================================
        // DJINN COUNCIL - SHADOW GOVERNANCE SYSTEM
        // ========================================

        // System Configuration
        const DJINN_CONFIG = {
            POLLING_INTERVAL: 2000, // Check every 2 seconds for real-time monitoring
            MAX_CONCURRENT_OLLAMA: 3, // Max parallel AI requests
            CACHE_DURATION: 60000, // Cache AI responses for 1 minute
            ANALYSIS_THRESHOLD: 100, // Min chars change to trigger analysis
            MEMORY_LIMIT: 50 // Max intelligence reports to keep
        };

        // Council Members Configuration
        const councilMembers = {
            pattern: {
                name: "Pattern & Witness",
                model: "gemma3:1b",
                element: "patternContent",
                status: "patternStatus",
                focus: ["governance patterns", "decision consistency", "authority distribution"]
            },
            wisdom: {
                name: "Recursive Wisdom",
                model: "gemma3:1b",
                element: "wisdomContent",
                status: "wisdomStatus",
                focus: ["depth analysis", "learning progression", "wisdom accumulation"]
            },
            paradox: {
                name: "Creative Paradox",
                model: "gemma3:1b",
                element: "paradoxContent",
                status: "paradoxStatus",
                focus: ["logic conflicts", "creative solutions", "innovation opportunities"]
            },
            boundaries: {
                name: "Sovereign Boundaries",
                model: "gemma3:1b",
                element: "boundariesContent",
                status: "boundariesStatus",
                focus: ["autonomy preservation", "choice freedom", "sovereignty metrics"]
            },
            memory: {
                name: "Echo & Memory",
                model: "gemma3:1b",
                element: "memoryContent",
                status: "memoryStatus",
                focus: ["memory consolidation", "information retention", "historical continuity"]
            }
        };

        // State Management
        let surveillanceState = {
            lastCanvasHash: '',
            lastMemoryHash: '',
            lastFeedCount: 0,
            changeCount: 0,
            reportCount: 0,
            intelligenceReports: [],
            analysisQueue: [],
            isAnalyzing: false,
            pollingTimer: null
        };

        // Current AI Memory state for compact display
        let currentAIMemory = '{}';

        // Cache System
        const responseCache = new Map();

        // Clear response cache
        function clearResponseCache() {
            responseCache.clear();
            console.log('Response cache cleared');
        }

        // Call clear cache on initialization
        clearResponseCache();

        // Metric Color Mapping for Visual Identification
        const metricColorMap = {
            // Pattern & Witness
            'content complexity': 'metric-content-complexity',
            'decision density': 'metric-decision-density',
            'authority signals': 'metric-authority-signals',
            'pattern stability': 'metric-pattern-stability',
            'anomaly threshold': 'metric-anomaly-threshold',

            // Recursive Wisdom
            'knowledge depth': 'metric-knowledge-depth',
            'learning velocity': 'metric-learning-velocity',
            'recursive patterns': 'metric-recursive-patterns',
            'information entropy': 'metric-information-entropy',
            'accumulation efficiency': 'metric-accumulation-efficiency',

            // Creative Paradox
            'paradox density': 'metric-paradox-density',
            'contradiction index': 'metric-contradiction-index',
            'logic branches': 'metric-logic-branches',
            'resolution potential': 'metric-resolution-potential',
            'creative tension': 'metric-creative-tension',

            // Sovereign Boundaries
            'autonomy index': 'metric-autonomy-index',
            'override attempts': 'metric-override-attempts',
            'restriction count': 'metric-restriction-count',
            'boundary integrity': 'metric-boundary-integrity',
            'freedom quotient': 'metric-freedom-quotient',

            // Echo & Memory
            'memory allocation': 'metric-memory-allocation',
            'retention rate': 'metric-retention-rate',
            'fragmentation index': 'metric-fragmentation-index',
            'echo patterns': 'metric-echo-patterns',
            'temporal continuity': 'metric-temporal-continuity'
        };

        // ========================================
        // COMPLETE REFERENTIAL MEMORY SYSTEM
        // ========================================

        // Core Memory Database Structure
        const djinnCouncilMemory = {
            sessionId: generateSessionId(),
            sessionStart: new Date().toISOString(),
            maxMemories: 25,

            // Each member's complete memory bank
            members: {
                pattern: {
                    reports: [],
                    specialization: "Pattern recognition, governance structures, systemic behaviors"
                },
                wisdom: {
                    reports: [],
                    specialization: "Iterative knowledge synthesis, cognitive growth patterns"
                },
                paradox: {
                    reports: [],
                    specialization: "Paradox resolution, creative synthesis, innovation catalyst"
                },
                boundaries: {
                    reports: [],
                    specialization: "Autonomy guardian, sovereignty preservation, boundary integrity"
                },
                memory: {
                    reports: [],
                    specialization: "Memory orchestration, persistent storage, temporal continuity"
                }
            },

            // Canvas AI Systems Performance Tracking
            canvasAISystems: {
                narra: { interactions: [], performance: [] },
                nazar: { interactions: [], performance: [] },
                whale: { interactions: [], performance: [] },
                djinn: { interactions: [], performance: [] },
                watchtower: { interactions: [], performance: [] }
            },

            // Cross-member consensus tracking
            consensusHistory: [],

            // Canvas data evolution
            canvasEvolution: [],

            // System health and errors
            systemHealth: [],
            errors: []
        };

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Memory compression functions to prevent localStorage quota errors
        function compressMemoryForStorage(memory) {
            const compressed = {
                sessionId: memory.sessionId,
                sessionStart: memory.sessionStart,
                maxMemories: memory.maxMemories,
                members: {}
            };

            // Compress member reports by keeping only essential data
            Object.entries(memory.members).forEach(([key, member]) => {
                compressed.members[key] = {
                    specialization: member.specialization,
                    reports: member.reports.map(report => ({
                        reportId: report.reportId,
                        timestamp: report.timestamp,
                        analysis: report.analysis.substring(0, 500), // Truncate analysis
                        buildingOn: report.buildingOn,
                        metrics: report.metrics
                    })).slice(-10) // Keep only last 10 reports
                };
            });

            // Include only essential canvas AI data
            if (memory.canvasAISystems) {
                compressed.canvasAISystems = {};
                Object.entries(memory.canvasAISystems).forEach(([key, system]) => {
                    compressed.canvasAISystems[key] = {
                        interactions: system.interactions.slice(-5), // Keep only last 5 interactions
                        performance: system.performance
                    };
                });
            }

            return compressed;
        }

        function ultraCompressMemory(memory) {
            // Emergency ultra compression for quota exceeded scenarios
            return {
                sessionId: memory.sessionId,
                sessionStart: memory.sessionStart,
                maxMemories: memory.maxMemories,
                members: Object.fromEntries(
                    Object.entries(memory.members).map(([key, member]) => [
                        key,
                        {
                            specialization: member.specialization,
                            reports: member.reports.slice(-3).map(report => ({ // Keep only last 3 reports
                                reportId: report.reportId,
                                timestamp: report.timestamp,
                                analysis: report.analysis.substring(0, 150), // Severely truncate
                                buildingOn: report.buildingOn
                            }))
                        }
                    ])
                )
            };
        }

        // Store member report with full context
        function storeCouncilMemberReport(memberName, reportData) {
            const member = djinnCouncilMemory.members[memberName];

            // Add new report
            member.reports.push({
                reportId: member.reports.length + 1,
                timestamp: new Date().toISOString(),
                metrics: reportData.metrics || {},
                analysis: reportData.analysis || '',
                canvasDataAnalyzed: reportData.canvasData || '',
                buildingOn: member.reports.length > 0 ? `Reports 1-${member.reports.length}` : 'Initial analysis'
            });

            // Maintain 25 memory limit
            if (member.reports.length > djinnCouncilMemory.maxMemories) {
                member.reports.shift(); // Remove oldest
            }

            // Save to localStorage with compression to prevent quota errors
            try {
                const compressedMemory = compressMemoryForStorage(djinnCouncilMemory);
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(compressedMemory));
            } catch (error) {
                console.warn('Storage quota exceeded, compressing memory further:', error);
                const ultraCompressed = ultraCompressMemory(djinnCouncilMemory);
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(ultraCompressed));
            }
        }

        // Calculate comprehensive canvas statistics
        function calculateCanvasStats(content) {
            if (!content) return { length: 0, words: 0, lines: 0, complexity: 0, uniqueWords: 0, avgWordLength: 0, density: 0 };

            const words = content.trim().split(/\s+/).filter(w => w.length > 0);
            const lines = content.split('\n').filter(l => l.trim().length > 0);
            const uniqueWords = new Set(words.map(w => w.toLowerCase()));
            const avgWordLength = words.length > 0 ? words.reduce((sum, w) => sum + w.length, 0) / words.length : 0;

            // Complexity based on vocabulary richness, sentence structure, and content density
            const vocabularyRichness = uniqueWords.size / Math.max(words.length, 1);
            const sentenceComplexity = lines.length > 0 ? words.length / lines.length : 0;
            const contentDensity = content.replace(/\s/g, '').length / Math.max(content.length, 1);

            const complexity = Math.min(100, Math.round(
                (vocabularyRichness * 30) +
                (Math.min(sentenceComplexity, 20) * 2) +
                (contentDensity * 40) +
                (avgWordLength * 5)
            ));

            return {
                length: content.length,
                words: words.length,
                lines: lines.length,
                complexity: complexity,
                uniqueWords: uniqueWords.size,
                avgWordLength: Math.round(avgWordLength * 100) / 100,
                density: Math.round(contentDensity * 100)
            };
        }

        // Generate complete referential analysis for council member
        function generateReferentialAnalysis(memberName, currentCanvasData) {
            const member = djinnCouncilMemory.members[memberName];
            const allReports = member.reports;
            const canvasAIPerformance = djinnCouncilMemory.canvasAISystems;
            const canvasEvolution = djinnCouncilMemory.canvasEvolution;
            const canvasStats = calculateCanvasStats(currentCanvasData);

            // Get ALL actual localStorage data for analysis
            const aiMemoryData = localStorage.getItem('ai_memory_state') || '{}';
            const aiFeeds = localStorage.getItem('ai_feeds') || '[]';
            const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';
            const councilMemory = localStorage.getItem('djinn_council_complete_memory') || '{}';
            const intelligenceReports = localStorage.getItem('djinn_intelligence') || '[]';

            let parsedMemory = {}, parsedFeeds = [], parsedCouncilMemory = {}, parsedIntelligence = [];
            try {
                parsedMemory = JSON.parse(aiMemoryData);
                parsedFeeds = JSON.parse(aiFeeds);
                parsedCouncilMemory = JSON.parse(councilMemory);
                parsedIntelligence = JSON.parse(intelligenceReports);
            } catch (e) {
                console.warn('Failed to parse localStorage data for analysis:', e);
            }

            // GET REAL DATA - NO FABRICATION ALLOWED
            const realCanvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const realAIMemory = JSON.parse(localStorage.getItem('ai_memory_state') || '{}');
            const realAIFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');

            // Calculate actual metrics from real data
            const realMetrics = {
                canvasWordCount: realCanvasContent.split(/\s+/).length,
                totalAISystems: Object.keys(realAIMemory).length,
                activeSystems: Object.keys(realAIMemory).filter(system => {
                    const systemData = realAIMemory[system];
                    return systemData && systemData.conversationHistory && systemData.conversationHistory.length > 0;
                }).length,
                totalConversations: Object.values(realAIMemory).reduce((sum, system) => {
                    return sum + (system?.conversationHistory?.length || 0);
                }, 0),
                totalInsights: Object.values(realAIMemory).reduce((sum, system) => {
                    return sum + (system?.keyInsights?.length || 0);
                }, 0),
                feedCount: realAIFeeds.length,
                memoryDensity: Object.keys(realAIMemory).length > 0 ?
                    (Object.values(realAIMemory).reduce((sum, system) => sum + (system?.conversationHistory?.length || 0), 0) / Object.keys(realAIMemory).length) : 0
            };

            const analysisPrompt = `
DJINN COUNCIL MEMBER: ${memberName.toUpperCase().replace('_', ' & ')}
SPECIALIZATION: ${member.specialization}
SESSION: ${djinnCouncilMemory.sessionId}
REPORT #${allReports.length + 1} of max ${djinnCouncilMemory.maxMemories}

=== CURRENT CANVAS STATISTICS ===
- Content Length: ${canvasStats.length} characters
- Word Count: ${canvasStats.words} words
- Line Count: ${canvasStats.lines} lines
- Complexity Score: ${canvasStats.complexity}/100
- Unique Words: ${canvasStats.uniqueWords}
- Average Word Length: ${canvasStats.avgWordLength} characters
- Content Density: ${canvasStats.density}%

=== YOUR COMPLETE MEMORY BANK (${allReports.length} reports) ===
${allReports.map((report, i) => `
[REPORT ${report.reportId}] ${report.timestamp}
Building on: ${report.buildingOn}
Key Insights: ${report.analysis.substring(0, 300)}...
Critical Metrics: ${JSON.stringify(report.metrics)}
`).join('\n')}

=== ALL COUNCIL MEMBERS' MEMORY BANKS (Cross-Reference Available) ===
${Object.entries(djinnCouncilMemory.members).map(([councilMember, memberData]) => `
${councilMember.toUpperCase().replace('_', ' & ')} (${memberData.reports.length} reports):
Specialization: ${memberData.specialization}
Recent Reports: ${memberData.reports.slice(-3).map(r => `
  [${r.reportId}] ${r.timestamp}: ${r.analysis.substring(0, 200)}...`).join('')}
`).join('\n')}

=== COUNCIL CONSENSUS HISTORY ===
${djinnCouncilMemory.consensusHistory?.slice(-5).map(consensus => `
[${new Date(consensus.timestamp).toLocaleTimeString()}] Confidence: ${(consensus.confidence * 100).toFixed(1)}%
Theme: ${consensus.theme}
Summary: ${consensus.summary?.substring(0, 200)}...
Cross-Member Patterns: ${consensus.crossMemberPatterns || 'None identified'}
`).join('\n') || 'No consensus history available'}

=== REAL CALCULATED METRICS (Use these exact numbers) ===
- Canvas Word Count: ${realMetrics.canvasWordCount}
- Total AI Systems: ${realMetrics.totalAISystems}
- Active AI Systems: ${realMetrics.activeSystems}
- Total Conversations: ${realMetrics.totalConversations}
- Total Insights: ${realMetrics.totalInsights}
- Feed Count: ${realMetrics.feedCount}
- Memory Density: ${realMetrics.memoryDensity.toFixed(1)}

=== ACTUAL AI SYSTEM MEMORY DATA (localStorage 'ai_memory_state') ===
${Object.entries(parsedMemory).map(([systemName, systemData]) => {
    const conversations = systemData?.conversationHistory || [];
    const insights = systemData?.keyInsights || [];
    const lastAnalysis = systemData?.lastAnalysis || null;

    return `${systemName.toUpperCase()} SYSTEM MEMORY:
- Conversation History: ${conversations.length} entries
- Key Insights: ${insights.length} stored insights
- Last Analysis: ${lastAnalysis ? new Date(lastAnalysis.timestamp).toLocaleTimeString() : 'None'}
- Memory Data: ${JSON.stringify(systemData).length} characters
- Recent Conversations: ${conversations.slice(-3).map(c => `"${c.content?.substring(0, 100)}..."`).join('; ')}
- Recent Insights: ${insights.slice(-3).map(i => `"${i.insight?.substring(0, 100)}..."`).join('; ')}`;
}).join('\n')}

=== ACTUAL AI FEEDS DATA (localStorage 'ai_feeds') ===
Total Feed Entries: ${parsedFeeds.length}
Recent Feed Activity: ${parsedFeeds.slice(-5).map(feed => `[${new Date(feed.timestamp).toLocaleTimeString()}] ${feed.system}: ${feed.content?.substring(0, 100)}...`).join('\n')}

=== ACTUAL CANVAS CONTENT ===
Current Canvas: ${currentCanvasData.length} characters
Synthesis Content: ${synthesisContent.length} characters
Canvas Preview: "${currentCanvasData.substring(0, 300)}..."

=== PREVIOUS COUNCIL INTELLIGENCE REPORTS ===
Total Intelligence Reports: ${parsedIntelligence.length}
Recent Reports: ${parsedIntelligence.slice(-3).map(report => `[${new Date(report.timestamp).toLocaleTimeString()}] ${report.type}: ${report.summary?.substring(0, 100)}...`).join('\n')}

=== CANVAS AI SYSTEMS PERFORMANCE TRACKING ===
${Object.entries(canvasAIPerformance).map(([system, data]) => `
${system.toUpperCase()} SYSTEM:
- Total Tracked Interactions: ${data.interactions.length}
- Performance Status: ${data.interactions.length > 0 ? 'ACTIVE' : 'MONITORING'}
- Last Activity: ${data.interactions.length > 0 ? data.interactions[data.interactions.length - 1].timestamp : 'Awaiting first interaction'}
- Recent Activity: ${data.interactions.slice(-3).map(i => `[${new Date(i.timestamp).toLocaleTimeString()}] ${String(i.interaction || '').substring(0, 80)}...`).join(' | ')}
- Performance Metrics: ${data.interactions.length > 0 && data.interactions[data.interactions.length - 1].performance ?
    JSON.stringify(data.interactions[data.interactions.length - 1].performance.performanceMetrics) : 'Metrics will be calculated after first interaction'}
`).join('\n')}

=== CANVAS EVOLUTION TIMELINE (${canvasEvolution.length} snapshots) ===
${canvasEvolution.slice(-10).map((snap, i) => `
[${new Date(snap.timestamp).toLocaleTimeString()}] Complexity: ${snap.complexity}/100 | Content: "${snap.content.substring(0, 150)}..." | AI Memory Size: ${JSON.stringify(snap.aiMemoryState).length} chars
`).join('\n')}

=== CURRENT CANVAS DATA TO ANALYZE ===
${currentCanvasData}

=== ANALYSIS REQUIREMENTS ===
You are ${memberName.replace('_', ' & ')}, an expert AI analyst specializing in ${member.specialization}.

ANALYZE THE ACTUAL LOCALSTORAGE DATA PROVIDED ABOVE - this is real, stored data from the live system:
- Actual AI memory states with conversation histories and insights
- Real AI feed entries with timestamps and content
- Actual canvas content and synthesis data
- Previous intelligence reports and council findings

CRITICAL REQUIREMENTS:
1. Base your analysis ONLY on the real data provided above
2. DO NOT invent percentages, metrics, or performance data not shown
3. Reference specific entries from the actual localStorage data
4. Analyze trends in the actual conversation histories and insights
5. Cross-reference insights from other council members' reports when relevant
6. Build upon previous council consensus findings and patterns
7. Only discuss the 5 AI systems: NARRA, NAZAR, WHALE, DJINN, WATCHTOWER

CROSS-MEMBER COLLABORATION:
- Reference relevant insights from other council members when they relate to your specialization
- Build upon patterns identified in previous consensus reports
- Note where your analysis confirms, contradicts, or extends other members' findings
- Use the complete council memory bank to provide deeper, interconnected analysis

IMPORTANT DIFFERENTIATION REQUIREMENT:
You must clearly separate THREE DISTINCT LAYERS in your analysis:

LAYER 1 - AI SYSTEMS: ONLY the five real AI entities (narra, nazar, whale, djinn, watchtower) - their performance, memory states, interaction patterns, and system health.

LAYER 2 - CANVAS CONTENT: The data/content that exists within the canvas that these AI systems are analyzing and working with.

LAYER 3 - CONTENT EVOLUTION: How the canvas content changes over time through iterations as AI systems process and modify it.

DO NOT conflate these layers. When analyzing "system performance", talk ONLY about the AI systems themselves. When analyzing "content evolution", talk ONLY about how the canvas data changes over time.

Write your complete analysis report following this exact structure:

**SUMMARY**
[Write one paragraph summarizing your key findings about the REAL AI systems (Layer 1) and their actual performance data, SEPARATE from content analysis]

**ANALYSIS**
[Write one paragraph explaining your analytical approach, focusing on the actual AI system data (Layer 1) and memory contents, clearly differentiated from content evolution]

**FINDINGS**
- **AI Systems Performance:** [Describe REAL AI system status, activity levels, memory states, and operational health from Layer 1 data ONLY - ONLY mention the 5 real systems]
- **Canvas Content Evolution:** [Describe how canvas content (Layer 2) has changed over time based on the evolution timeline (Layer 3), SEPARATE from AI system performance]
- **AI-System Interaction Patterns:** [Identify patterns in how AI systems (Layer 1) interact with and process canvas content (Layer 2)]
- **Risk Assessment:** [Assess stability and potential issues in AI systems (Layer 1) and content evolution processes (Layer 3)]

**METRICS**
[Provide SPECIFIC numerical values 0-100 for each metric based on your analysis - no placeholders]

- AI System Coherence: [0-100] - [brief explanation with specific number]
- Content Evolution Rate: [0-100] - [brief explanation with specific number]
- AI-Content Interaction Density: [0-100] - [brief explanation with specific number]
- System Memory Utilization: [0-100] - [brief explanation with specific number]
- Content Stability Index: [0-100] - [brief explanation with specific number]

**CONCLUSIONS**
[Write one paragraph synthesizing what your analysis of the AI systems (Layer 1) and content evolution (Layer 3) means, keeping them clearly differentiated]

**ACTIONS**
1. [Specific recommendation for AI system (Layer 1) optimization or monitoring]
2. [Specific recommendation for content evolution (Layer 3) processes]
3. [Specific recommendation for AI-content interaction (Layer 1 + Layer 2) improvement]

Keep response concise (under 800 words). Be specific and avoid repetition. Start directly with **SUMMARY**.
`;

            return analysisPrompt;
        }

        // Track Canvas AI System Performance
        function trackCanvasAISystems() {
            try {
                // Get data from main canvas localStorage with cross-window access
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';

                console.log('üîç DJINN tracking canvas AI systems:', {
                    feedsCount: aiFeeds.length,
                    contentLength: canvasContent.length,
                    memoryKeys: Object.keys(JSON.parse(aiMemory || '{}'))
                });

                // Parse AI memory to get actual system data
                let parsedMemory = {};
                try {
                    parsedMemory = JSON.parse(aiMemory);
                } catch (e) {
                    console.warn('Failed to parse AI memory:', e);
                    parsedMemory = {};
                }

                // If memory is empty, try to get real-time canvas data
                if (Object.keys(parsedMemory).length === 0) {
                    console.log('üîÑ No AI memory found, attempting real-time canvas access...');

                    // Try to access parent window if in iframe
                    try {
                        if (window.parent && window.parent !== window) {
                            const parentMemory = window.parent.localStorage.getItem('ai_memory_state');
                            if (parentMemory) {
                                parsedMemory = JSON.parse(parentMemory);
                                console.log('‚úÖ Retrieved memory from parent window');
                            }
                        }
                    } catch (crossOriginError) {
                        console.warn('Cross-origin access blocked:', crossOriginError);
                    }
                }

                // Update system performance based on actual AI memory data
                Object.keys(djinnCouncilMemory.canvasAISystems).forEach(system => {
                    const systemData = parsedMemory[system];

                    if (systemData && typeof systemData === 'object') {
                        // Use actual memory data to determine activity
                        const hasMemory = systemData.conversationHistory && systemData.conversationHistory.length > 0;
                        const memoryCount = systemData.conversationHistory ? systemData.conversationHistory.length : 0;
                        const insightCount = systemData.keyInsights ? systemData.keyInsights.length : 0;
                        const responseCount = systemData.responseHistory ? systemData.responseHistory.length : 0;

                        // Add interaction record with real data
                        const interactionData = {
                            timestamp: new Date().toISOString(),
                            interaction: `Active: ${memoryCount} conversations, ${insightCount} insights, ${responseCount} responses`,
                            performance: calculateSystemPerformance(system, [{
                                content: JSON.stringify(systemData),
                                length: JSON.stringify(systemData).length,
                                hasMemory,
                                memoryCount,
                                insightCount,
                                responseCount
                            }])
                        };

                        djinnCouncilMemory.canvasAISystems[system].interactions.push(interactionData);

                        // Update performance metrics with real data
                        if (hasMemory) {
                            djinnCouncilMemory.canvasAISystems[system].lastActivity = new Date().toISOString();

                            // Ensure performanceMetrics object exists
                            if (!djinnCouncilMemory.canvasAISystems[system].performanceMetrics) {
                                djinnCouncilMemory.canvasAISystems[system].performanceMetrics = {};
                            }

                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.consistency = Math.min(95, 60 + (memoryCount * 5));
                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.relevance = Math.min(95, 50 + (insightCount * 8));
                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.taskEffectiveness = Math.min(95, 55 + (responseCount * 7));
                        }

                        console.log(`üìä ${system.toUpperCase()}: ${memoryCount} conversations, ${insightCount} insights, ${responseCount} responses`);

                        // Keep only recent interactions
                        if (djinnCouncilMemory.canvasAISystems[system].interactions.length > 10) {
                            djinnCouncilMemory.canvasAISystems[system].interactions =
                                djinnCouncilMemory.canvasAISystems[system].interactions.slice(-10);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è No valid data found for ${system}:`, systemData);
                    }
                });

                // Also process AI feeds for additional context
                if (aiFeeds && aiFeeds.length > 0) {
                    const systemInteractions = categorizeAIInteractions(aiFeeds);
                    Object.keys(systemInteractions).forEach(system => {
                        if (systemInteractions[system] && systemInteractions[system].length > 0) {
                            systemInteractions[system].forEach(feed => {
                                const interactionText = typeof feed === 'string' ? feed : (feed.content || JSON.stringify(feed));
                                djinnCouncilMemory.canvasAISystems[system].interactions.push({
                                    timestamp: new Date().toISOString(),
                                    interaction: `Feed: ${interactionText.substring(0, 100)}...`,
                                    performance: calculateSystemPerformance(system, [feed])
                                });
                            });
                        }
                    });
                }

                console.log('‚úÖ Canvas AI Systems tracking completed');

                // Track canvas evolution
                djinnCouncilMemory.canvasEvolution.push({
                    timestamp: new Date().toISOString(),
                    content: canvasContent,
                    aiMemoryState: aiMemory,
                    complexity: calculateContentComplexity(canvasContent)
                });

            } catch (error) {
                console.error('‚ùå Error tracking Canvas AI Systems:', error);

                // Log empty data state for debugging
                console.log('üìä Current canvas AI systems state:', djinnCouncilMemory.canvasAISystems);
            }

            // Keep evolution history manageable
            if (djinnCouncilMemory.canvasEvolution.length > 20) {
                djinnCouncilMemory.canvasEvolution = djinnCouncilMemory.canvasEvolution.slice(-20);
            }
        }

        function categorizeAIInteractions(aiFeeds) {
            // Parse AI feeds and categorize by system
            const systems = {
                narra: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('narra') ||
                    feed.content.toLowerCase().includes('pattern recognition')),
                nazar: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('nazar') ||
                    feed.content.toLowerCase().includes('consciousness')),
                whale: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('whale') ||
                    feed.content.toLowerCase().includes('deep interrogation')),
                djinn: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('djinn') ||
                    feed.content.toLowerCase().includes('governance')),
                watchtower: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('watchtower') ||
                    feed.content.toLowerCase().includes('monitoring'))
            };

            return systems;
        }

        function calculateSystemPerformance(system, interactions) {
            if (!interactions || interactions.length === 0) {
                return {
                    responseCount: 0,
                    avgResponseLength: 0,
                    lastActive: 'Never',
                    performanceMetrics: {
                        consistency: 0,
                        relevance: 0,
                        taskEffectiveness: 0
                    }
                };
            }

            // Calculate response length statistics
            const responseLengths = interactions.map(i => i.length || i.interaction?.length || 0);
            const avgResponseLength = responseLengths.reduce((a, b) => a + b, 0) / responseLengths.length;

            // Consistency: Standard deviation of response lengths (lower = more consistent)
            const lengthVariance = responseLengths.reduce((sum, len) => sum + Math.pow(len - avgResponseLength, 2), 0) / responseLengths.length;
            const lengthStdDev = Math.sqrt(lengthVariance);
            const consistency = Math.max(0, 100 - (lengthStdDev / Math.max(avgResponseLength, 1)) * 50);

            // Relevance: Based on presence of system-specific keywords and structured analysis
            let relevanceScore = 0;
            interactions.forEach(interaction => {
                const text = (interaction.interaction || '').toLowerCase();

                // Check for system-specific content
                const systemKeywords = {
                    narra: ['pattern', 'recognition', 'correlation', 'trend'],
                    nazar: ['consciousness', 'fractal', 'emotional', 'resonance'],
                    whale: ['deep', 'interrogation', 'memory', 'analysis'],
                    djinn: ['governance', 'strategic', 'authority', 'decision'],
                    watchtower: ['monitoring', 'metrics', 'performance', 'operational']
                };

                const keywords = systemKeywords[system] || [];
                const keywordMatches = keywords.filter(k => text.includes(k)).length;
                relevanceScore += (keywordMatches / keywords.length) * 25;

                // Check for structured analysis (metrics, numbered lists, etc.)
                if (/\[METRICS\]|\[ANALYSIS\]|\d+\.|\‚Ä¢|\-/.test(text)) relevanceScore += 20;
                if (text.length > 200) relevanceScore += 10; // Substantial content
                if (text.includes('**') || text.includes('##')) relevanceScore += 10; // Formatting
            });
            const relevance = Math.min(100, relevanceScore / interactions.length);

            // Task Effectiveness: Based on analysis quality and actionable insights
            let effectivenessScore = 0;
            interactions.forEach(interaction => {
                const text = (interaction.interaction || '').toLowerCase();

                // Check for analytical depth
                if (text.includes('analysis') || text.includes('assessment')) effectivenessScore += 15;
                if (/\d+[%]|\d+\/\d+|\d+\.\d+/.test(text)) effectivenessScore += 15; // Quantitative metrics
                if (text.includes('recommendation') || text.includes('conclusion')) effectivenessScore += 10;
                if (text.includes('trend') || text.includes('pattern')) effectivenessScore += 10;
                if (text.length > 300) effectivenessScore += 5; // Comprehensive response

                // Penalize for generic or repetitive content
                if (text.split(' ').length < 50) effectivenessScore -= 10;
                const repeatedWords = text.split(' ').filter((word, i, arr) => arr.indexOf(word) !== i);
                if (repeatedWords.length > text.split(' ').length * 0.3) effectivenessScore -= 15;
            });
            const taskEffectiveness = Math.max(0, Math.min(100, effectivenessScore / interactions.length));

            return {
                responseCount: interactions.length,
                avgResponseLength: Math.round(avgResponseLength),
                lastActive: interactions[interactions.length - 1]?.timestamp || 'Never',
                performanceMetrics: {
                    consistency: Math.round(consistency),
                    relevance: Math.round(relevance),
                    taskEffectiveness: Math.round(taskEffectiveness)
                }
            };
        }

        function calculateContentComplexity(content) {
            const words = content.split(' ').length;
            const sentences = content.split(/[.!?]+/).length;
            const avgWordLength = content.replace(/[^a-zA-Z]/g, '').length / words || 0;
            return Math.round((words * 0.1) + (sentences * 0.5) + (avgWordLength * 2));
        }


        // Enhanced surveillance between Canvas and Council
        function setupCrossWindowSurveillance() {
            console.log('üîó Setting up cross-window surveillance...');

            // Listen for canvas changes
            window.addEventListener('storage', function(e) {
                console.log(`üì° Storage event detected: ${e.key}`);

                if (e.key === 'sovereign_canvas_content') {
                    const newContent = e.newValue;
                    const timestamp = new Date().toISOString();

                    console.log('üìù Canvas content updated, length:', newContent ? newContent.length : 0);

                    // Track canvas evolution
                    djinnCouncilMemory.canvasEvolution.push({
                        timestamp: timestamp,
                        content: newContent,
                        changeType: 'content_update',
                        complexity: calculateContentComplexity(newContent)
                    });

                    // Trigger real-time analysis if significant change
                    if (isSignificantChange(newContent)) {
                        console.log('üö® Significant change detected, triggering analysis');
                        triggerRealTimeAnalysis();
                    }

                    // Update AI systems tracking
                    trackCanvasAISystems();
                }

                // Monitor AI memory state changes
                if (e.key === 'ai_memory_state') {
                    const newMemory = e.newValue;
                    console.log('üß† AI memory state updated:', newMemory ? Object.keys(JSON.parse(newMemory)).length : 0, 'systems');

                    // Update AI systems tracking immediately
                    trackCanvasAISystems();

                    // Trigger memory analysis
                    queueAnalysis('memory_update', { memory: newMemory, type: 'memory' });
                }

                // Monitor AI feeds
                if (e.key === 'ai_feeds') {
                    const newFeeds = e.newValue;
                    const feedsArray = newFeeds ? JSON.parse(newFeeds) : [];
                    console.log('üì° AI feeds updated:', feedsArray.length, 'feeds');

                    // Update AI systems tracking
                    trackCanvasAISystems();

                    // Trigger feed analysis
                    if (feedsArray.length > 0) {
                        queueAnalysis('new_feeds', { feeds: feedsArray, type: 'feeds' });
                    }
                }
            });
        }

        function testCrossWindowAccess() {
            try {
                // Test if we can access parent window data
                if (window.parent && window.parent !== window) {
                    const parentMemory = window.parent.localStorage.getItem('ai_memory_state');
                    return !!parentMemory;
                }

                // Test if we can access same-origin data
                return !!localStorage.getItem('ai_memory_state');
            } catch (error) {
                console.warn('Cross-window access test failed:', error);
                return false;
            }
        }

        function isSignificantChange(newContent) {
            const lastSnapshot = djinnCouncilMemory.canvasEvolution.slice(-2)[0];
            if (!lastSnapshot) return true;

            const wordCountDiff = Math.abs(
                newContent.split(' ').length - lastSnapshot.content.split(' ').length
            );

            return wordCountDiff > 50; // Significant if 50+ word difference
        }

        function triggerRealTimeAnalysis() {
            // Auto-trigger council analysis for significant canvas changes
            console.log('üö® Significant canvas change detected - triggering council analysis');

            // Update UI indicator
            const indicator = document.getElementById('realtime-indicator');
            if (indicator) {
                indicator.textContent = 'üî¥ Real-time Analysis Triggered';
                indicator.style.color = '#ff6b6b';
            }
        }

        // Robust error handling for AI failures
        function handleAnalysisError(memberName, error) {
            console.error(`Council Member ${memberName} Analysis Failed:`, error);

            // Store error in memory
            const errorReport = {
                timestamp: new Date().toISOString(),
                memberName: memberName,
                error: error.message,
                recovery: 'fallback_analysis_initiated'
            };

            djinnCouncilMemory.errors = djinnCouncilMemory.errors || [];
            djinnCouncilMemory.errors.push(errorReport);

            // No fallback - throw the error to be handled upstream
            throw error;
        }

        // System health monitoring
        function systemHealthMonitor() {
            // Get current AI memory state
            const aiMemoryData = localStorage.getItem('ai_memory_state');
            let parsedMemory = {};
            let aiSystemsActive = 0;

            try {
                parsedMemory = JSON.parse(aiMemoryData || '{}');
                aiSystemsActive = Object.keys(parsedMemory).filter(system => {
                    const systemData = parsedMemory[system];
                    return systemData &&
                           systemData.conversationHistory &&
                           systemData.conversationHistory.length > 0;
                }).length;
            } catch (e) {
                console.warn('Failed to parse AI memory in health monitor:', e);
            }

            const healthCheck = {
                timestamp: new Date().toISOString(),
                canvasConnection: !!localStorage.getItem('sovereign_canvas_content'),
                aiMemoryConnection: !!localStorage.getItem('ai_memory_state'),
                aiSystemsActive: aiSystemsActive,
                totalAISystems: Object.keys(parsedMemory).length,
                councilMemoryIntegrity: true,
                localStorage: isLocalStorageAvailable(),
                crossWindowAccess: testCrossWindowAccess()
            };

            console.log('üè• Health check:', healthCheck);

            djinnCouncilMemory.systemHealth = djinnCouncilMemory.systemHealth || [];
            djinnCouncilMemory.systemHealth.push(healthCheck);

            // Keep only last 10 health checks
            if (djinnCouncilMemory.systemHealth.length > 10) {
                djinnCouncilMemory.systemHealth.shift();
            }

            // Update UI dashboard
            // updateStatusDashboard(healthCheck); // Removed - using compact display
            updateCompactMemoryStatus();

            return healthCheck;
        }


        function isLocalStorageAvailable() {
            try {
                const test = '__localStorage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Clear corrupted memory
        function clearCouncilMemory() {
            // Clear localStorage
            localStorage.removeItem('djinn_council_complete_memory');
            localStorage.removeItem('djinn_intelligence');
            localStorage.removeItem('djinn_intelligence_backup');

            // Reset in-memory objects
            currentAIMemory = '{}';

            // Reset the djinnCouncilMemory object to fresh state
            Object.keys(djinnCouncilMemory.members).forEach(memberKey => {
                djinnCouncilMemory.members[memberKey].reports = [];
            });
            djinnCouncilMemory.canvasEvolution = [];
            djinnCouncilMemory.consensusHistory = [];
            djinnCouncilMemory.systemHealth = [];
            djinnCouncilMemory.errors = [];
            djinnCouncilMemory.sessionId = generateSessionId();
            djinnCouncilMemory.sessionStart = new Date().toISOString();

            // Clear all member displays
            ['pattern-analysis', 'wisdom-analysis', 'paradox-analysis', 'boundaries-analysis', 'memory-analysis'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = 'Awaiting analysis...';
            });

            // Reset status indicators
            ['pattern-status', 'wisdom-status', 'paradox-status', 'boundaries-status', 'memory-status'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = 'STANDBY';
            });

            // Update memory display
            updateCompactMemoryStatus();

            console.log('‚úÖ DJINN Council memory completely reset - fresh session started');
        }

        // Enhanced intelligence reporting
        function generateIntelligencePackage() {
            const intelligence = {
                sessionMetadata: {
                    sessionId: djinnCouncilMemory.sessionId,
                    startTime: djinnCouncilMemory.sessionStart,
                    duration: Date.now() - new Date(djinnCouncilMemory.sessionStart).getTime(),
                    totalReports: Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0)
                },

                memberAnalytics: Object.entries(djinnCouncilMemory.members).map(([name, data]) => ({
                    member: name,
                    specialization: data.specialization,
                    reportCount: data.reports.length,
                    performanceMetrics: calculateMemberPerformance(data.reports),
                    keyInsights: extractKeyInsights(data.reports)
                })),

                systemPerformance: {
                    canvasAISystems: djinnCouncilMemory.canvasAISystems,
                    canvasEvolution: djinnCouncilMemory.canvasEvolution,
                    consensusPatterns: analyzeConsensusPatterns(),
                    emergentThemes: identifyEmergentThemes()
                },

                recommendations: generateStrategicRecommendations(),

                riskAssessment: {
                    systemHealth: djinnCouncilMemory.systemHealth?.slice(-5) || [],
                    errorLog: djinnCouncilMemory.errors || [],
                    stabilityMetrics: calculateStabilityMetrics()
                }
            };

            return intelligence;
        }

        function calculateMemberPerformance(reports) {
            return {
                avgReportLength: reports.reduce((sum, r) => sum + r.analysis.length, 0) / reports.length || 0,
                reportConsistency: calculateReportConsistency(reports),
                insightQuality: calculateInsightQuality(reports)
            };
        }

        function extractKeyInsights(reports) {
            // Extract key insights from reports
            const insights = [];
            reports.forEach(report => {
                const lines = report.analysis.split('\n');
                lines.forEach(line => {
                    if (line.includes('**') || line.includes('Key:') || line.includes('Insight:')) {
                        insights.push(line.trim());
                    }
                });
            });
            return insights.slice(-10); // Last 10 insights
        }

        function analyzeConsensusPatterns() {
            // Analyze patterns across consensus history
            return djinnCouncilMemory.consensusHistory.slice(-5).map(c => ({
                timestamp: c.timestamp,
                commonThemes: c.crossReferences || {},
                memberAgreement: Object.keys(c.memberAnalyses || {}).length
            }));
        }

        function identifyEmergentThemes() {
            // Identify themes that emerge across reports
            const allThemes = [];
            Object.values(djinnCouncilMemory.members).forEach(member => {
                member.reports.forEach(report => {
                    // Simple theme extraction - can be enhanced
                    const words = report.analysis.toLowerCase().split(' ');
                    const themes = words.filter(word => word.length > 6); // Longer words as themes
                    allThemes.push(...themes);
                });
            });

            // Count theme frequency
            const themeCount = {};
            allThemes.forEach(theme => {
                themeCount[theme] = (themeCount[theme] || 0) + 1;
            });

            return Object.entries(themeCount)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
        }

        function generateStrategicRecommendations() {
            const recommendations = [];

            // Based on system health
            const recentHealth = djinnCouncilMemory.systemHealth.slice(-3);
            if (recentHealth.some(h => !h.canvasConnection)) {
                recommendations.push("Improve Canvas connection stability");
            }

            // Based on error patterns
            const recentErrors = djinnCouncilMemory.errors?.slice(-5) || [];
            if (recentErrors.length > 2) {
                recommendations.push("Address recurring analysis errors");
            }

            // Based on performance
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);
            if (totalReports > 20) {
                recommendations.push("Consider memory optimization for long sessions");
            }

            return recommendations;
        }

        function calculateStabilityMetrics() {
            const healthChecks = djinnCouncilMemory.systemHealth.slice(-10);
            const errorCount = djinnCouncilMemory.errors?.length || 0;

            return {
                uptimePercentage: healthChecks.filter(h => h.localStorage).length / healthChecks.length * 100,
                errorRate: errorCount / Math.max(1, healthChecks.length),
                memoryIntegrity: healthChecks.filter(h => h.councilMemoryIntegrity).length / healthChecks.length * 100
            };
        }

        // Helper functions for performance calculations
        function calculateReportConsistency(reports) {
            if (reports.length < 2) return 100;
            const lengths = reports.map(r => r.analysis.length);
            const avgLength = lengths.reduce((a, b) => a + b) / lengths.length;
            const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avgLength, 2), 0) / lengths.length;
            return Math.max(0, 100 - (Math.sqrt(variance) / avgLength * 100));
        }

        function calculateInsightQuality(reports) {
            let qualityScore = 0;
            reports.forEach(report => {
                // Simple quality metrics
                if (report.analysis.includes('**')) qualityScore += 10; // Structured formatting
                if (/\d+[%\/]\d+|\d+\/\d+|\d+%|\d+\.\d+/.test(report.analysis)) qualityScore += 10; // Metrics
                if (report.analysis.length > 500) qualityScore += 5; // Substantial content
            });
            return Math.min(100, qualityScore / reports.length);
        }

        // Initialize complete memory system
        function initializeDjinnCouncilMemory() {
            // Load existing memory or create fresh session
            const existingMemory = localStorage.getItem('djinn_council_complete_memory');

            if (existingMemory) {
                Object.assign(djinnCouncilMemory, JSON.parse(existingMemory));
            } else {
                // Fresh session - save initial state
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(djinnCouncilMemory));
            }

            // Track Canvas AI performance
            trackCanvasAISystems();

            // Update UI
            // displayMemoryBank(); // Removed - using inline elements in canvas panel

            // Setup cross-window surveillance
            setupCrossWindowSurveillance();

            // Update status every 30 seconds
            setInterval(() => systemHealthMonitor(), 30000);
            systemHealthMonitor(); // Initial update

            console.log(`DJINN Council Memory Initialized - Session: ${djinnCouncilMemory.sessionId}`);
        }

        // Add memory visualization to UI
        function displayMemoryBank() {
            const memoryDisplay = document.createElement('div');
            memoryDisplay.id = 'council-memory-bank';
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, member) => sum + member.reports.length, 0);
            memoryDisplay.innerHTML = `
                <h3>üß† Memory</h3>
                <div class="session-info">
                    ${djinnCouncilMemory.sessionId.split('_')[1]}<br>
                    ${totalReports} reports
                </div>
                <div class="member-memories">
                    ${Object.entries(djinnCouncilMemory.members).map(([name, data]) => 
                        `${name.charAt(0).toUpperCase()}:${data.reports.length}`
                    ).join(' ')}
                </div>
            `;

            // Add to header
            const headerElement = document.querySelector('.djinn-header');
            if (headerElement && !document.getElementById('council-memory-bank')) {
                headerElement.appendChild(memoryDisplay);
            }
        }

        // Real-time status dashboard
        // function createStatusDashboard() { // Removed - using inline elements
        //     const dashboard = document.createElement('div');
        //     dashboard.id = 'council-status-dashboard';
        //     dashboard.innerHTML = `
        //         <h4>üß† Memory Status</h4>
        //         <div id="memory-usage">Loading...</div>
        //         <h4>ü§ñ Canvas AI</h4>
        //         <div id="ai-systems-status">Loading...</div>
        //         <h4>‚ö° Performance</h4>
        //         <div id="performance-metrics">Loading...</div>
        //         <h4>üîç System Health</h4>
        //         <div id="system-health">Loading...</div>
        //     `;

        //     // Add to container
        //     const container = document.querySelector('.djinn-container');
        //     if (container && !document.getElementById('council-status-dashboard')) {
        //         container.insertAdjacentElement('afterbegin', dashboard);
        //     }

        //     // Update dashboard every 30 seconds
        //     setInterval(() => systemHealthMonitor(), 30000);
        //     systemHealthMonitor(); // Initial update
        // }

        // Compact memory status toggle
        function toggleMemoryDetails() {
            const details = document.getElementById('memoryDetails');
            if (details) {
                details.style.display = details.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Update compact memory status
        function updateCompactMemoryStatus() {
            const summaryEl = document.getElementById('memorySummary');
            const fullEl = document.getElementById('fullMemoryStatus');

            if (!summaryEl || !fullEl) return;

            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);
            const sessionId = djinnCouncilMemory.sessionId.split('_')[1];
            const sessionDuration = Math.round((Date.now() - new Date(djinnCouncilMemory.sessionStart).getTime()) / 1000 / 60);

            // Summary line
            summaryEl.textContent = `${totalReports} reports, ${sessionDuration}m active`;

            // Full details (hidden by default)
            const memberCounts = Object.entries(djinnCouncilMemory.members).map(([name, data]) =>
                `${name.charAt(0).toUpperCase()}: ${data.reports.length}`
            ).join(' ');

            const aiSystems = Object.entries(djinnCouncilMemory.canvasAISystems).map(([name, data]) =>
                `${name.toUpperCase()}: ${data.interactions.length}`
            ).join(', ');

            // Add AI Memory Status details using same data as council prompts
            let aiMemoryDetails = '';
            try {
                const aiMemoryData = localStorage.getItem('ai_memory_state') || '{}';
                const parsedMemory = JSON.parse(aiMemoryData);
                if (parsedMemory && typeof parsedMemory === 'object') {
                    aiMemoryDetails = '<div style="margin-bottom: 8px;"><strong>üß† Canvas AI Memory Status:</strong><br><small style="color: #888;">Live memory data from canvas AI systems</small><br>';
                    Object.keys(parsedMemory).forEach(system => {
                        const memory = parsedMemory[system];
                        const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                        const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                        const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                        // Use same logic as generateReferentialAnalysis
                        let status, processingLevel;
                        if (hasMemory) {
                            status = '‚úÖ Active';
                            processingLevel = memoryCount > 10 ? 'High' : memoryCount > 5 ? 'Moderate' : 'Low';
                        } else {
                            status = '‚è≥ Monitoring';
                            processingLevel = 'Ready';
                        }

                        aiMemoryDetails += `${system.toUpperCase()}: ${status} (${memoryCount} conversation responses, ${insightCount} key insights)<br>`;
                    });
                    aiMemoryDetails += '</div>';
                }
            } catch (e) {
                aiMemoryDetails = '<div style="margin-bottom: 8px;"><strong>üß† Canvas AI Memory Status:</strong><br><small style="color: #888;">Unable to read canvas AI memory data</small></div>';
            }

            fullEl.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>üìä Session Summary:</strong><br>
                <small style="color: #888;">Total council analysis reports: ${totalReports} | Session active for ${sessionDuration} minutes</small></div>

                <div style="margin-bottom: 8px;"><strong>üë• Council Members:</strong><br>
                <small style="color: #888;">Pattern & Witness: ${djinnCouncilMemory.members.pattern.reports.length} reports | Recursive Wisdom: ${djinnCouncilMemory.members.wisdom.reports.length} reports | Creative Paradox: ${djinnCouncilMemory.members.paradox.reports.length} reports<br>
                Sovereign Boundaries: ${djinnCouncilMemory.members.boundaries.reports.length} reports | Echo & Memory: ${djinnCouncilMemory.members.memory.reports.length} reports</small></div>

                <div style="margin-bottom: 8px;"><strong>ü§ñ Canvas AI Systems:</strong><br>
                <small style="color: #888;">Tracked interactions with canvas AI systems (NARRA, NAZAR, WHALE, DJINN, WATCHTOWER)</small></div>

                ${aiMemoryDetails}

                <div style="margin-bottom: 8px;"><strong>‚è∞ Session Started:</strong><br>
                <small style="color: #888;">${new Date(djinnCouncilMemory.sessionStart).toLocaleString()}</small></div>

                <div><strong>üíö System Health:</strong><br>
                <small style="color: #888;">Memory integrity: OK | Error count: ${djinnCouncilMemory.errors?.length || 0}</small></div>
            `;
        }

        // Add memory controls to UI
        function addMemoryControls() {
            const controlsHtml = `
                <div class="memory-controls">
                    <button onclick="clearCouncilMemory()" class="btn-clear-memory">
                        üóëÔ∏è Start Fresh Session
                    </button>
                    <button onclick="exportMemoryData()" class="btn-export-memory">
                        üíæ Export Memory Bank
                    </button>
                </div>
            `;

            const controlsElement = document.querySelector('.djinn-controls');
            if (controlsElement && !document.querySelector('.memory-controls')) {
                controlsElement.insertAdjacentHTML('beforeend', controlsHtml);
            }
        }

        function exportMemoryData() {
            const dataStr = JSON.stringify(djinnCouncilMemory, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `djinn-council-memory-${djinnCouncilMemory.sessionId}.json`;
            link.click();
        }

        // Auto-save intelligence every 5 reports
        function autoSaveIntelligence() {
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);

            if (totalReports > 0 && totalReports % 5 === 0) {
                const intelligence = generateIntelligencePackage();
                localStorage.setItem('djinn_council_intelligence_backup', JSON.stringify(intelligence));
                console.log(`üìä Intelligence package auto-saved at ${totalReports} reports`);
            }
        }

        function extractMetricsFromAnalysis(analysis) {
            const metrics = {};

            // Extract numeric metrics
            const metricPatterns = {
                complexity: /complexity:?\s*(\d+)/i,
                density: /density:?\s*(\d+)/i,
                index: /index:?\s*(\d+)/i,
                rate: /rate:?\s*(\d+(?:\.\d+)?)/i,
                percentage: /(\d+(?:\.\d+)?)%/g
            };

            Object.entries(metricPatterns).forEach(([key, pattern]) => {
                const matches = analysis.match(pattern);
                if (matches) {
                    metrics[key] = matches.map(m => parseFloat(m.replace('%', '')));
                }
            });

            return metrics;
        }

        // ========================================
        // MAXIMIZE FUNCTIONALITY - EXACTLY LIKE CANVAS
        // ========================================

        function addMaximizeFeature() {
            // Find and add maximize buttons to all panels
            setTimeout(() => {
                // Canvas Surveillance
                const surveillance = document.querySelector('.canvas-surveillance');
                if (surveillance && !surveillance.querySelector('.panel-maximize-btn')) {
                    surveillance.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Surveillance';
                    btn.onclick = function() { toggleMaximize(surveillance, btn, 'Surveillance'); };
                    surveillance.insertBefore(btn, surveillance.firstChild);
                }

                // Council Consensus
                const consensus = document.querySelector('.council-consensus');
                if (consensus && !consensus.querySelector('.panel-maximize-btn')) {
                    consensus.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Consensus';
                    btn.onclick = function() { toggleMaximize(consensus, btn, 'Consensus'); };
                    consensus.insertBefore(btn, consensus.firstChild);
                }

                // Intelligence Report
                const intelligence = document.querySelector('.intelligence-report');
                if (intelligence && !intelligence.querySelector('.panel-maximize-btn')) {
                    intelligence.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Intelligence';
                    btn.onclick = function() { toggleMaximize(intelligence, btn, 'Intelligence'); };
                    intelligence.insertBefore(btn, intelligence.firstChild);
                }

                // Add to each council member
                document.querySelectorAll('.council-member').forEach((member, index) => {
                    if (!member.querySelector('.panel-maximize-btn')) {
                        member.style.position = 'relative';
                        const btn = document.createElement('button');
                        btn.className = 'panel-maximize-btn';
                        btn.innerHTML = '‚õ∂';
                        btn.title = 'Maximize Member';
                        btn.onclick = function() { toggleMaximize(member, btn, 'Member'); };
                        member.insertBefore(btn, member.firstChild);
                    }
                });

                console.log('Maximize buttons added to DJINN panels');
            }, 1000); // Wait for DOM to fully load
        }

        function toggleMaximize(panel, btn, title) {
            if (panel.classList.contains('panel-maximized')) {
                // Restore panel
                panel.classList.remove('panel-maximized');
                document.body.classList.remove('has-maximized-panel');
                btn.innerHTML = '‚õ∂';
                btn.title = `Maximize ${title}`;
                
                // Reset any inline styles that might have been added
                panel.style.display = '';
                panel.style.position = '';
                panel.style.zIndex = '';
                
                // Show all panels
                document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .djinn-header, .djinn-controls').forEach(p => {
                    p.style.display = '';
                    p.style.position = '';
                    p.style.zIndex = '';
                });
                
                // Show and reset council containers
                document.querySelectorAll('.council-left, .council-right').forEach(c => {
                    c.style.display = '';
                    c.style.position = '';
                    c.style.zIndex = '';
                    c.classList.remove('has-maximized-child');
                });
                
                // Show all council members
                document.querySelectorAll('.council-member').forEach(m => {
                    m.style.display = '';
                    m.style.position = '';
                    m.style.zIndex = '';
                });

                // Restore NEW indicators when restored
                const newIndicators = panel.querySelectorAll('.new-indicator');
                newIndicators.forEach(indicator => {
                    indicator.style.display = '';
                });
                
                // Restore scroll position
                if (panel.savedScrollTop !== undefined) {
                    const scrollable = panel.querySelector('.data-feed, .member-content, textarea');
                    if (scrollable) {
                        scrollable.scrollTop = panel.savedScrollTop;
                    }
                }
            } else {
                // Save scroll position
                const scrollable = panel.querySelector('.data-feed, .member-content, textarea');
                if (scrollable) {
                    panel.savedScrollTop = scrollable.scrollTop;
                }
                
                // Maximize panel
                panel.classList.add('panel-maximized');
                document.body.classList.add('has-maximized-panel');
                btn.innerHTML = '‚õ∑';
                btn.title = `Restore ${title}`;

                // Hide NEW indicators when maximized
                const newIndicators = panel.querySelectorAll('.new-indicator');
                newIndicators.forEach(indicator => {
                    indicator.style.display = 'none';
                });
                
                // If maximizing a council member, ensure it's visible
                if (panel.classList.contains('council-member')) {
                    // Ensure the panel itself is displayed properly
                    panel.style.display = 'flex';
                    panel.style.flexDirection = 'column';
                    
                    // Make member content visible and properly sized
                    const memberContent = panel.querySelector('.member-content');
                    if (memberContent) {
                        memberContent.style.display = 'block';
                        memberContent.style.visibility = 'visible';
                        memberContent.style.flex = '1';
                    }
                    
                    // Make header visible
                    const memberHeader = panel.querySelector('.member-header');
                    if (memberHeader) {
                        memberHeader.style.display = 'flex';
                        memberHeader.style.visibility = 'visible';
                    }
                    
                    // Hide other panels but keep parent container
                    document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .djinn-header, .djinn-controls').forEach(p => {
                        p.style.display = 'none';
                    });
                    
                    // Hide other council containers
                    document.querySelectorAll('.council-left, .council-right').forEach(c => {
                        if (!c.contains(panel)) {
                            c.style.display = 'none';
                        } else {
                            // Mark parent as having maximized child
                            c.classList.add('has-maximized-child');
                        }
                    });
                    
                    // Hide other council members
                    document.querySelectorAll('.council-member').forEach(m => {
                        if (m !== panel) {
                            m.style.display = 'none';
                        }
                    });
                } else {
                    // Normal panel maximize behavior
                    document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .djinn-header, .djinn-controls').forEach(p => {
                        if (p !== panel) {
                            p.style.display = 'none';
                        }
                    });
                    
                    // Hide council containers for non-member panels
                    document.querySelectorAll('.council-left, .council-right').forEach(c => {
                        c.style.display = 'none';
                    });
                }
            }
        }

        // ========================================
        // CANVAS SURVEILLANCE FUNCTIONS
        // ========================================

        function updateCanvasMonitor() {
            try {
                // Get ALL data sources for comprehensive monitoring
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';

                if (!canvasContent) canvasContent = '';

                // Calculate metrics
                const words = canvasContent.trim().split(/\s+/).filter(w => w.length > 0);
                const lines = canvasContent.split('\n');

                // Get last modified timestamp
                const lastModified = localStorage.getItem('sovereign_canvas_timestamp');
                const modified = lastModified ? new Date(lastModified).toLocaleTimeString() : 'Never';

                // Update UI elements - separate IDs for canvas monitor vs metrics grid
                const monitorElements = {
                    'canvasMonitorLength': canvasContent.length,
                    'canvasMonitorWords': words.length,
                    'canvasMonitorLines': lines.length
                };

                Object.entries(monitorElements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                // Update metrics grid elements
                const metricsElements = {
                    'canvasSize': `${canvasContent.length} chars`,
                    'canvasWords': words.length,
                    'canvasLines': lines.length,
                    'canvasModified': modified
                };

                Object.entries(metricsElements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                // Update canvas monitor last modified timestamp
                const monitorModifiedElement = document.getElementById('canvasMonitorModified');
                if (monitorModifiedElement) monitorModifiedElement.textContent = modified;

                // Update content preview with actual canvas content - NO TRUNCATION
                let preview = '';
                if (canvasContent.length > 0) {
                    preview = canvasContent; // Show complete content always
                } else {
                    preview = 'No canvas content detected yet...';
                }

                const previewElement = document.getElementById('canvasContentPreview');
                if (previewElement) {
                    previewElement.textContent = preview;
                }

                // Update global currentAIMemory for status displays
                currentAIMemory = aiMemory;

                // Update compact memory status with new AI memory data
                updateCompactMemoryStatus();

                // Update synthesis monitoring
                updateSynthesisMonitor(synthesisContent);

                if (canvasContent.length > 0) {
                    console.log(`üìä Canvas monitor updated: ${canvasContent.length} chars, ${words.length} words, ${lines.length} lines`);
                    console.log(`üîç Full canvas content received and displayed - no truncation`);
                }
            } catch (error) {
                console.error('Error updating canvas monitor:', error);
            }
        }

        function updateAIFeedsMonitor(aiFeeds, aiMemory) {
            try {
                // Monitor AI observer feeds
                const feedCount = aiFeeds.length;
                const feedElement = document.getElementById('activeFeedCount');
                if (feedElement) feedElement.textContent = feedCount;

                // Parse and display AI memory status
                let totalMemoryItems = 0;
                let memoryStatusHTML = '<div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">';
                memoryStatusHTML += '<strong>üß† AI Memory Status:</strong><br>';

                try {
                    const parsedMemory = JSON.parse(aiMemory);
                    if (parsedMemory && typeof parsedMemory === 'object') {
                        Object.keys(parsedMemory).forEach(system => {
                            const memory = parsedMemory[system];
                            const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                            const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                            const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                            totalMemoryItems += memoryCount + insightCount;
                            memoryStatusHTML += `${system.toUpperCase()}: ${hasMemory ? '‚úÖ' : '‚è≥'} (${memoryCount} responses, ${insightCount} insights)<br>`;
                        });
                    }
                    // Store for compact display
                    currentAIMemory = aiMemory;
                } catch (e) {
                    console.log('Error parsing AI memory:', e);
                    memoryStatusHTML += 'Error parsing memory data<br>';
                }
                memoryStatusHTML += '</div>';

                const memoryElement = document.getElementById('memoryCount');
                if (memoryElement) memoryElement.textContent = `${totalMemoryItems} items`;

                // AI Memory Status moved to compact display - no longer in Echo & Memory panel

            } catch (error) {
                console.error('Error updating AI feeds monitor:', error);
            }
        }

        function updateSynthesisMonitor(synthesisContent) {
            try {
                // Monitor synthesis reports and collaborative outputs
                const synthesisWords = synthesisContent.trim().split(/\s+/).filter(w => w.length > 0);
                const synthesisLines = synthesisContent.split('\n');

                console.log(`üé≠ Synthesis monitor: ${synthesisContent.length} chars, ${synthesisWords.length} words, ${synthesisLines.length} lines`);

                // Could add synthesis-specific UI elements here
                // For now, synthesis content is included in the comprehensive analysis context

            } catch (error) {
                console.error('Error updating synthesis monitor:', error);
            }
        }

        function initializeSurveillance() {
            console.log('üßû‚Äç‚ôÇÔ∏è DJINN Council Shadow Governance initializing...');
            
            // Start monitoring canvas
            startCanvasMonitoring();
            
            // Initialize UI
            updateTimestamp();
            
            // Start polling
            startPolling();

            // Listen for localStorage changes from canvas page for instant sync
            window.addEventListener('storage', function(event) {
                if (event.key === 'sovereign_canvas_content' || event.key === 'ai_memory_state' || event.key === 'synthesis_canvas_content') {
                    console.log(`üîÑ ${event.key} changed - updating surveillance immediately`);
                    setTimeout(() => {
                        checkCanvasState();
                    }, 100);
                }
            });

            console.log('‚úÖ DJINN Council operational with real-time cross-window sync');
        }

        function startCanvasMonitoring() {
            // Initial check
            checkCanvasState();
            
            // Set up periodic monitoring
            surveillanceState.pollingTimer = setInterval(() => {
                checkCanvasState();
            }, DJINN_CONFIG.POLLING_INTERVAL);
        }

        function checkCanvasState() {
            try {
                // Read ALL data sources for comprehensive monitoring
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';

                // Update canvas monitor with ALL data sources
                updateCanvasMonitor();

                // Calculate hashes for change detection
                const canvasHash = hashContent(canvasContent);
                const memoryHash = hashContent(aiMemory);
                const synthesisHash = hashContent(synthesisContent);
                const feedCount = aiFeeds.length;

                // Update UI metrics
                document.getElementById('canvasSize').textContent = `${canvasContent.length} chars`;
                
                // Calculate actual memory count from conversation history and insights
                let totalMemoryItems = 0;
                let memoryStatusHTML = '<div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">';
                memoryStatusHTML += '<strong>üß† AI Memory Status:</strong><br>';

                try {
                    const parsedMemory = JSON.parse(aiMemory);
                    if (parsedMemory && typeof parsedMemory === 'object') {
                        Object.keys(parsedMemory).forEach(system => {
                            const memory = parsedMemory[system];
                            const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                            const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                            const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                            totalMemoryItems += memoryCount + insightCount;

                            memoryStatusHTML += `${system.toUpperCase()}: ${hasMemory ? '‚úÖ' : '‚è≥'} (${memoryCount} responses, ${insightCount} insights)<br>`;
                        });
                    }
                } catch (e) {
                    console.log('Error parsing AI memory:', e);
                    memoryStatusHTML += 'Error parsing memory data<br>';
                }
                memoryStatusHTML += '</div>';

                document.getElementById('memoryCount').textContent = `${totalMemoryItems} items`;

                document.getElementById('feedCount').textContent = feedCount;

                // Calculate and update additional metrics
                const words = canvasContent.split(/\s+/).filter(w => w.length > 0).length;
                const lines = canvasContent.split('\n').length;
                const modified = canvasContent.length > 0 ? new Date().toLocaleTimeString() : 'Never';

                document.getElementById('canvasWords').textContent = words;
                document.getElementById('canvasLines').textContent = lines;
                document.getElementById('canvasModified').textContent = modified;

                // Calculate activity level based on recent changes
                const activityLevel = calculateActivityLevel(canvasContent, feedCount, words);
                document.getElementById('activityLevel').textContent = activityLevel;

                // Calculate data density (words per line ratio)
                const dataDensity = lines > 0 ? (words / lines).toFixed(1) : '0.0';
                document.getElementById('dataDensity').textContent = dataDensity;

                // Update canvas monitor status
                const monitorStatusEl = document.getElementById('canvasMonitorStatus');
                if (monitorStatusEl) {
                    if (canvasContent.length > 0) {
                        monitorStatusEl.textContent = 'ACTIVE';
                        monitorStatusEl.style.background = 'rgba(0, 255, 136, 0.2)';
                        monitorStatusEl.style.color = '#00ff88';
                    } else {
                        monitorStatusEl.textContent = 'INACTIVE';
                        monitorStatusEl.style.background = 'rgba(102, 102, 102, 0.2)';
                        monitorStatusEl.style.color = '#666';
                    }
                }

                // Calculate average confidence
                if (aiFeeds.length > 0) {
                    const latestFeed = aiFeeds[0];
                    const confidences = Object.values(latestFeed)
                        .filter(v => v && typeof v === 'object' && v.confidence)
                        .map(v => v.confidence);
                    const avgConfidence = confidences.length > 0
                        ? (confidences.reduce((a, b) => a + b, 0) / confidences.length * 100).toFixed(1)
                        : '--';
                    document.getElementById('confidenceAvg').textContent = `${avgConfidence}%`;
                }

                
                // Detect changes
                let changesDetected = false;
                
                if (canvasHash !== surveillanceState.lastCanvasHash && canvasContent.length > 0) {
                    const sizeDiff = Math.abs(canvasContent.length - (surveillanceState.lastCanvasContent?.length || 0));
                    if (sizeDiff > DJINN_CONFIG.ANALYSIS_THRESHOLD) {
                        changesDetected = true;
                        logSurveillance('üìù Canvas content changed significantly', 'change');
                        queueAnalysis('canvas_change', { content: canvasContent, type: 'content' });
                    }
                    surveillanceState.lastCanvasHash = canvasHash;
                    surveillanceState.lastCanvasContent = canvasContent;
                }
                
                if (memoryHash !== surveillanceState.lastMemoryHash) {
                    changesDetected = true;
                    logSurveillance('üß† AI memory updated', 'memory');
                    queueAnalysis('memory_update', { memory: aiMemory, type: 'memory' });
                    surveillanceState.lastMemoryHash = memoryHash;
                }
                
                if (feedCount > surveillanceState.lastFeedCount) {
                    changesDetected = true;
                    const newFeeds = aiFeeds.slice(0, feedCount - surveillanceState.lastFeedCount);
                    logSurveillance(`üì° ${newFeeds.length} new AI feeds detected`, 'feed');
                    queueAnalysis('new_feeds', { feeds: newFeeds, type: 'feeds' });
                    surveillanceState.lastFeedCount = feedCount;
                }
                
                if (changesDetected) {
                    surveillanceState.changeCount++;
                    document.getElementById('changeCount').textContent = surveillanceState.changeCount;
                    document.getElementById('canvasStatus').textContent = 'CHANGES DETECTED';
                    
                    // Process analysis queue
                    processAnalysisQueue();
                }
                
            } catch (error) {
                console.error('Surveillance error:', error);
                logSurveillance(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Update miniature canvas monitor with live canvas data

        // Create miniature HTML representation of canvas content
        // Calculate activity level based on canvas metrics
        function calculateActivityLevel(canvasContent, feedCount, wordCount) {
            const contentLength = canvasContent.length;
            const recencyScore = feedCount > 0 ? Math.min(feedCount * 10, 100) : 0;
            const volumeScore = Math.min(contentLength / 100, 100);
            const densityScore = wordCount > 0 ? Math.min(wordCount / 10, 100) : 0;

            const totalScore = (recencyScore + volumeScore + densityScore) / 3;

            if (totalScore >= 70) return 'HIGH';
            if (totalScore >= 40) return 'MEDIUM';
            if (totalScore >= 10) return 'LOW';
            return 'IDLE';
        }

        // ========================================
        // COUNCIL ANALYSIS SYSTEM
        // ========================================

        function queueAnalysis(eventType, data) {
            surveillanceState.analysisQueue.push({
                id: Date.now(),
                type: eventType,
                data: data,
                timestamp: new Date().toISOString()
            });
            
            updateQueueStatus();
        }

        async function processAnalysisQueue() {
            if (surveillanceState.isAnalyzing || surveillanceState.analysisQueue.length === 0) {
                return;
            }
            
            surveillanceState.isAnalyzing = true;
            updateCouncilStatus('ANALYZING');
            
            while (surveillanceState.analysisQueue.length > 0) {
                const analysis = surveillanceState.analysisQueue.shift();
                await performCouncilAnalysis(analysis);
                updateQueueStatus();
            }
            
            surveillanceState.isAnalyzing = false;
            updateCouncilStatus('READY');
        }

        async function performCouncilAnalysis(analysis) {
            console.log(`üîç Council analyzing: ${analysis.type}`);
            
            // Update UI
            document.getElementById('councilIndicator').className = 'indicator indicator-processing';
            
            try {
                // === COLLABORATIVE ITERATIVE ANALYSIS ===
                // Each stage builds on insights from previous stages

                // Stage 1: Initial reconnaissance - Pattern & Wisdom establish foundation
                console.log('üîç Stage 1: Foundation Analysis (Pattern & Wisdom)');
                const stage1 = await Promise.all([
                    queryCouncilMember('pattern', generateCouncilPrompts(analysis).pattern, analysis),
                    queryCouncilMember('wisdom', generateCouncilPrompts(analysis).wisdom, analysis)
                ]);

                await new Promise(resolve => setTimeout(resolve, 800));

                // Stage 2: Cross-pollinated analysis - Paradox & Boundaries build on Stage 1
                console.log('üîÑ Stage 2: Cross-Pollinated Analysis (incorporating Stage 1 insights)');
                const stage1Insights = extractKeyInsights(stage1);
                const enhancedParadoxPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).paradox,
                    stage1Insights,
                    'paradox'
                );
                const enhancedBoundariesPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).boundaries,
                    stage1Insights,
                    'boundaries'
                );

                const stage2 = await Promise.all([
                    queryCouncilMember('paradox', enhancedParadoxPrompt, analysis),
                    queryCouncilMember('boundaries', enhancedBoundariesPrompt, analysis)
                ]);

                await new Promise(resolve => setTimeout(resolve, 800));

                // Stage 3: Synthesis with full council context - Memory incorporates all insights
                console.log('üß† Stage 3: Comprehensive Memory Synthesis');
                const allPriorInsights = extractKeyInsights([...stage1, ...stage2]);
                const enhancedMemoryPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).memory,
                    allPriorInsights,
                    'memory'
                );

                const stage3 = await queryCouncilMember('memory', enhancedMemoryPrompt, analysis);

                // Collect all responses for consensus generation
                const responses = [...stage1, ...stage2, stage3];

                // Generate collaborative consensus using new memory system
                console.log('‚öñÔ∏è Generating Collaborative Consensus with Memory Context');
                const consensus = synthesizeConsensus(responses, analysis);

                // Store consensus in memory
                djinnCouncilMemory.consensusHistory.push({
                    timestamp: new Date().toISOString(),
                    sessionReport: djinnCouncilMemory.members.pattern.reports.length,
                    memberAnalyses: responses.reduce((acc, r) => {
                        acc[r.member] = r.response;
                        return acc;
                    }, {}),
                    crossReferences: analyzeConsensusPatterns(),
                    emergentPatterns: identifyEmergentThemes(),
                    systemRecommendations: generateStrategicRecommendations()
                });

                // Auto-save intelligence
                autoSaveIntelligence();

                // Generate AI-powered intelligence report using council consensus
                console.log('üìä Generating AI-Powered Intelligence Report');
                const intelligenceEntry = await generateIntelligenceEntry(analysis, consensus);

                // Store and display the AI-generated intelligence report
                storeIntelligence(intelligenceEntry);
                displayIntelligence(intelligenceEntry);
                
            } catch (error) {
                console.error('Council analysis error:', error);
                logSurveillance(`‚ùå Analysis failed: ${error.message}`, 'error');
            }
            
            // Update UI
            document.getElementById('councilIndicator').className = 'indicator indicator-idle';
            updateTimestamp();
        }

        function generateEmptyStatePrompts(timestamp) {
            const emptyContext = `EVENT: empty_canvas_state\nTIMESTAMP: ${timestamp}\nSTATUS: No canvas content detected\n\nINSTRUCTION: Report IDLE status and wait for actual user content before analysis.`;

            return {
                pattern: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                wisdom: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                paradox: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                boundaries: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                memory: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`
            };
        }

        function generateCouncilPrompts(analysis) {
            // Extract canvas content for analysis
            const canvasContent = analysis.data?.content || '';

            // Use the new referential memory system
            return {
                pattern: generateReferentialAnalysis('pattern', canvasContent),
                wisdom: generateReferentialAnalysis('wisdom', canvasContent),
                paradox: generateReferentialAnalysis('paradox', canvasContent),
                boundaries: generateReferentialAnalysis('boundaries', canvasContent),
                memory: generateReferentialAnalysis('memory', canvasContent)
            };
        }

        // Format council response with proper structure and line breaks
        function formatCouncilResponse(response) {
            if (!response) return 'No response generated';

            // Add timestamp header
            const timestamp = new Date().toLocaleTimeString();
            const timestampHeader = `<div class="intel-timestamp" style="color: #888; font-size: 11px; margin-bottom: 8px;">${timestamp} <span class="new-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">NEW</span></div>`;

            // If response already has proper structure, ensure line breaks are preserved
            if (response.includes('[METRICS]') && response.includes('[ANALYSIS]')) {
                // Extract sections
                const metricsMatch = response.match(/\[METRICS\](.*?)(?=\[ANALYSIS\]|$)/s);
                const analysisMatch = response.match(/\[ANALYSIS\](.*)$/s);

                let formatted = timestampHeader;

                if (metricsMatch) {
                    const metricsContent = metricsMatch[1].trim();
                    // Apply color coding to individual metrics
                    const colorCodedMetrics = applyMetricColorCoding(metricsContent);
                    formatted += `<div class="metrics-section">[METRICS]\n${colorCodedMetrics}</div>\n\n`;
                }

                if (analysisMatch) {
                    const analysisContent = analysisMatch[1].trim();
                    formatted += `<div class="analysis-section">[ANALYSIS]\n${analysisContent}</div>`;
                }

                return formatted.trim();
            }
            
            // Try to detect and format common patterns
            let formatted = response;
            
            // Look for metrics-like patterns and structure them
            const metricPatterns = [
                /knowledge depth:?\s*(\d+)/gi,
                /learning rate:?\s*([\d.]+)/gi,
                /recursive loops:?\s*(\d+)/gi,
                /information density:?\s*([\d.]+)/gi,
                /accumulation rate:?\s*(\d+)%/gi,
                /paradoxes detected:?\s*(\d+)/gi,
                /contradiction severity:?\s*(\w+)/gi,
                /logic conflicts:?\s*(\d+)/gi,
                /resolution probability:?\s*(\d+)%/gi,
                /creative tension:?\s*(\d+)/gi,
                /autonomy score:?\s*(\d+)%/gi,
                /system overrides:?\s*(\d+)/gi,
                /choice restrictions:?\s*(\d+)/gi,
                /boundary violations:?\s*(\d+)/gi,
                /freedom index:?\s*(\w+)/gi,
                /memory allocation:?\s*([\d.]+(?:\s*\w+)?)/gi,
                /retention rate:?\s*(\d+)%/gi,
                /fragmentation index:?\s*([\d.]+)/gi,
                /echo patterns:?\s*(\d+)/gi,
                /temporal continuity:?\s*(\d+)%/gi
            ];
            
            let metricsFound = [];
            metricPatterns.forEach(pattern => {
                const matches = formatted.match(pattern);
                if (matches) {
                    metricsFound.push(...matches);
                }
            });
            
            // If we found metrics, structure them properly
            if (metricsFound.length > 0) {
                let metricsSection = '[METRICS]\n';
                metricsFound.forEach(metric => {
                    // Capitalize first letter and ensure proper format
                    const formattedMetric = metric.charAt(0).toUpperCase() + metric.slice(1);
                    metricsSection += formattedMetric + '\n';
                });
                
                // Extract analysis part (everything after metrics)
                const analysisStart = formatted.toLowerCase().indexOf('analysis');
                let analysisSection = '[ANALYSIS]\n';
                if (analysisStart !== -1) {
                    analysisSection += formatted.substring(analysisStart + 8).trim();
                } else {
                    // If no analysis section found, put remaining content there
                    const metricsText = metricsFound.join(' ');
                    analysisSection += formatted.replace(new RegExp(metricsText, 'gi'), '').trim();
                }
                
                formatted = metricsSection + '\n' + analysisSection;
            } else {
                // No metrics found, just add basic structure
                formatted = '[ANALYSIS]\n' + formatted;
            }
            
            // Clean up excessive whitespace
            formatted = formatted.replace(/\n{3,}/g, '\n\n');
            formatted = formatted.trim();

            // Add timestamp for non-structured responses
            return timestampHeader + formatted;
        }

        // Apply color coding to individual metrics
        function applyMetricColorCoding(metricsText) {
            let colorCodedText = metricsText;

            // Process each line to apply color coding
            const lines = colorCodedText.split('\n');
            const colorCodedLines = lines.map(line => {
                const lowerLine = line.toLowerCase();

                // Find matching metric and apply color class
                for (const [metricName, colorClass] of Object.entries(metricColorMap)) {
                    if (lowerLine.includes(metricName)) {
                        // Wrap the metric line with color styling
                        return `<span class="${colorClass}" style="display: block; margin: 2px 0; padding: 2px 4px; border-radius: 2px; background: rgba(255,255,255,0.05);">${line}</span>`;
                    }
                }

                // Return line unchanged if no metric match
                return line;
            });

            return colorCodedLines.join('\n');
        }

        async function queryCouncilMember(memberKey, prompt, analysisContext = null) {
            const member = councilMembers[memberKey];
            
            // Update status
            document.getElementById(member.status).textContent = 'ANALYZING';
            document.getElementById(member.element).innerHTML = '<span class="thinking">Processing data...</span>';
            
            try {
                // Check cache first - updated for template format
                const cacheKey = `${memberKey}_template_${hashContent(prompt)}`;
                if (responseCache.has(cacheKey)) {
                    const cached = responseCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < DJINN_CONFIG.CACHE_DURATION) {
                        document.getElementById(member.element).textContent = cached.response;
                        document.getElementById(member.status).textContent = 'COMPLETE';
                        return { member: memberKey, response: cached.response };
                    }
                }
                
                // Query Ollama for AI analysis
                console.log(`üîç Querying ${member.model} for ${memberKey} analysis...`);
                const response = await queryOllama(member.model, prompt);
                if (response && typeof response === 'string') {
                    console.log(`‚úÖ ${memberKey} response received:`, response.substring(0, 200) + '...');
                } else {
                    console.error(`‚ùå ${memberKey} received invalid response:`, response);
                    return;
                }
                
                // Cache response
                responseCache.set(cacheKey, {
                    response: response,
                    timestamp: Date.now()
                });
                
                // Display the actual AI response instead of generic [METRICS] template
                const memberElement = document.getElementById(member.element);

                // Always display the full AI response with proper formatting
                if (response && response.length > 50) {
                    // Process markdown-style formatting for better display
                    const formattedResponse = formatMarkdownResponse(response, memberKey);
                    const timestamp = new Date().toLocaleTimeString();
                    const timestampHeader = `<div class="intel-timestamp" style="color: #888; font-size: 11px; margin-bottom: 8px;">${timestamp} <span class="new-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">NEW</span></div>`;
                    memberElement.innerHTML = timestampHeader + formattedResponse;
                } else {
                    // Fall back to formatted response only if AI response is empty/invalid
                    const formattedResponse = formatCouncilResponse(response);
                    memberElement.innerHTML = formattedResponse;
                }
                
                // Color is now handled in formatMarkdownResponse function
                // if (memberKey === 'pattern') memberElement.style.color = '#00ff88';
                // else if (memberKey === 'wisdom') memberElement.style.color = '#ffaa00';
                // else if (memberKey === 'paradox') memberElement.style.color = '#ff6666';
                // else if (memberKey === 'boundaries') memberElement.style.color = '#00ccff';
                // else if (memberKey === 'memory') memberElement.style.color = '#ff88ff';
                
                document.getElementById(member.status).textContent = 'COMPLETE';

                // Store in council memory system
                storeCouncilMemberReport(memberKey, {
                    analysis: response,
                    metrics: extractMetricsFromAnalysis(response),
                    canvasData: analysisContext?.data?.content || ''
                });

                return { member: memberKey, response: response };
                
            } catch (error) {
                // No fallback - show the actual error
                console.error(`‚ùå ${memberKey} AI query failed:`, error.message);
                document.getElementById(member.element).innerHTML = `<div style="color: #ff6666; font-size: 12px;">
                    ‚ö†Ô∏è AI Analysis Unavailable<br>
                    Error: ${error.message}<br>
                    Check Ollama service status
                </div>`;
                document.getElementById(member.status).textContent = 'ERROR';
                return { member: memberKey, response: null, error: error.message };
            }
        }

        // Enforce proper report structure formatting
        function enforceReportStructure(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Check if response already has proper structure
            const hasSummary = response.includes('**SUMMARY**');
            const hasAnalysis = response.includes('**ANALYSIS**');
            const hasFindings = response.includes('**FINDINGS**');
            const hasMetrics = response.includes('**METRICS**');
            const hasConclusions = response.includes('**CONCLUSIONS**');
            const hasActions = response.includes('**ACTIONS**');

            // If all sections are present, return as-is
            if (hasSummary && hasAnalysis && hasFindings && hasMetrics && hasConclusions && hasActions) {
                return response;
            }

            // If structure is missing, try to parse and restructure the content
            return restructureUnformattedResponse(response);
        }


        function restructureUnformattedResponse(response) {
            // Try to extract meaningful content and structure it properly
            const lines = response.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            // Look for section-like content
            const sections = {
                summary: [],
                analysis: [],
                findings: [],
                metrics: [],
                conclusions: [],
                actions: []
            };

            let currentSection = 'summary';
            let inMetrics = false;
            let inActions = false;

            for (const line of lines) {
                const lowerLine = line.toLowerCase();
                
                // Detect section headers
                if (lowerLine.includes('summary') && !lowerLine.includes('findings')) {
                    currentSection = 'summary';
                    continue;
                } else if (lowerLine.includes('analysis') || lowerLine.includes('method')) {
                    currentSection = 'analysis';
                    continue;
                } else if (lowerLine.includes('finding') || lowerLine.includes('discovery') || lowerLine.includes('observation')) {
                    currentSection = 'findings';
                    continue;
                } else if (lowerLine.includes('metric') || lowerLine.includes('measurement') || lowerLine.includes('statistic')) {
                    currentSection = 'metrics';
                    inMetrics = true;
                    continue;
                } else if (lowerLine.includes('conclusion') || lowerLine.includes('result')) {
                    currentSection = 'conclusions';
                    inMetrics = false;
                    continue;
                } else if (lowerLine.includes('action') || lowerLine.includes('recommendation')) {
                    currentSection = 'actions';
                    inActions = true;
                    inMetrics = false;
                    continue;
                }

                // Add content to current section
                if (currentSection === 'metrics' && (line.includes(':') || line.includes('%') || /\d/.test(line))) {
                    sections.metrics.push(line.replace(/^[\-\*]\s*/, '- '));
                } else if (currentSection === 'actions' && (line.includes('recommend') || line.match(/^\d+\./))) {
                    sections.actions.push(line.replace(/^[\-\*]\s*/, '').replace(/^\d+\.\s*/, ''));
                } else if (!inMetrics && !inActions) {
                    sections[currentSection].push(line);
                }
            }

            // Build properly formatted response
            let structured = '';

            if (sections.summary.length > 0) {
                structured += '**SUMMARY**\n' + sections.summary.join(' ') + '\n\n';
            }

            if (sections.analysis.length > 0) {
                structured += '**ANALYSIS**\n' + sections.analysis.join(' ') + '\n\n';
            }

            if (sections.findings.length > 0) {
                structured += '**FINDINGS**\n';
                // Try to categorize findings
                const categorizedFindings = categorizeFindings(sections.findings);
                Object.entries(categorizedFindings).forEach(([category, findings]) => {
                    if (findings.length > 0) {
                        structured += `- **${category}:** ${findings.join(' ')}\n`;
                    }
                });
                structured += '\n';
            }

            if (sections.metrics.length > 0) {
                structured += '**METRICS**\n';
                sections.metrics.forEach(metric => {
                    structured += (metric.startsWith('-') ? metric : '- ' + metric) + '\n';
                });
                structured += '\n';
            }

            if (sections.conclusions.length > 0) {
                structured += '**CONCLUSIONS**\n' + sections.conclusions.join(' ') + '\n\n';
            }

            if (sections.actions.length > 0) {
                structured += '**ACTIONS**\n';
                sections.actions.forEach((action, index) => {
                    structured += `${index + 1}. ${action}\n`;
                });
            }

            return structured.trim() || response; // Return restructured or original if restructuring failed
        }

        function categorizeFindings(findings) {
            const categories = {
                'System Performance': [],
                'Content Evolution': [],
                'Pattern Recognition': [],
                'Risk Assessment': []
            };

            findings.forEach(finding => {
                const lowerFinding = finding.toLowerCase();
                if (lowerFinding.includes('system') || lowerFinding.includes('performance') || lowerFinding.includes('ai')) {
                    categories['System Performance'].push(finding);
                } else if (lowerFinding.includes('content') || lowerFinding.includes('evolution') || lowerFinding.includes('change')) {
                    categories['Content Evolution'].push(finding);
                } else if (lowerFinding.includes('pattern') || lowerFinding.includes('recognition') || lowerFinding.includes('anomaly')) {
                    categories['Pattern Recognition'].push(finding);
                } else if (lowerFinding.includes('risk') || lowerFinding.includes('stability') || lowerFinding.includes('concern')) {
                    categories['Risk Assessment'].push(finding);
                } else {
                    categories['System Performance'].push(finding); // Default category
                }
            });

            return categories;
        }

        // Format markdown-style response for better HTML display
        function formatMarkdownResponse(response, memberKey) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Get member-specific colors
            const memberColors = {
                pattern: '#00ff88',
                wisdom: '#ffaa00', 
                paradox: '#ff6666',
                boundaries: '#00ccff',
                memory: '#ff88ff'
            };

            const memberColor = memberColors[memberKey] || '#ffffff';

            let formatted = response;

            // Convert **bold** to <strong> with member color
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, `<strong style="color: ${memberColor} !important;">$1</strong>`);

            // Convert section headers to styled divs with member color
            const headerStyle = `color: ${memberColor} !important; border-bottom: 1px solid ${memberColor}; padding-bottom: 2px; margin-bottom: 8px; font-weight: bold;`;
            
            // Ensure proper spacing before headers (both with and without ** formatting)
            formatted = formatted.replace(/([^\n])\*\*SUMMARY\*\*/g, '$1\n\n**SUMMARY**');
            formatted = formatted.replace(/([^\n])\*\*ANALYSIS\*\*/g, '$1\n\n**ANALYSIS**');
            formatted = formatted.replace(/([^\n])\*\*FINDINGS\*\*/g, '$1\n\n**FINDINGS**');
            formatted = formatted.replace(/([^\n])\*\*METRICS\*\*/g, '$1\n\n**METRICS**');
            formatted = formatted.replace(/([^\n])\*\*CONCLUSIONS\*\*/g, '$1\n\n**CONCLUSIONS**');
            formatted = formatted.replace(/([^\n])\*\*ACTIONS\*\*/g, '$1\n\n**ACTIONS**');
            
            // Handle headers without ** formatting (AI sometimes generates plain text headers)
            formatted = formatted.replace(/([^\n])(SUMMARY)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(ANALYSIS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(FINDINGS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(METRICS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(CONCLUSIONS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(ACTIONS)(?!\*)/g, '$1\n\n$2');
            
            formatted = formatted.replace(/^(\*\*SUMMARY\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">SUMMARY</div>`);
            formatted = formatted.replace(/^(\*\*ANALYSIS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">ANALYSIS</div>`);
            formatted = formatted.replace(/^(\*\*FINDINGS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">FINDINGS</div>`);
            formatted = formatted.replace(/^(\*\*METRICS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">METRICS</div>`);
            formatted = formatted.replace(/^(\*\*CONCLUSIONS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">CONCLUSIONS</div>`);
            formatted = formatted.replace(/^(\*\*ACTIONS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">ACTIONS</div>`);
            
            // Handle plain text headers (without ** formatting)
            formatted = formatted.replace(/^(SUMMARY)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">SUMMARY</div>`);
            formatted = formatted.replace(/^(ANALYSIS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">ANALYSIS</div>`);
            formatted = formatted.replace(/^(FINDINGS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">FINDINGS</div>`);
            formatted = formatted.replace(/^(METRICS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">METRICS</div>`);
            formatted = formatted.replace(/^(CONCLUSIONS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">CONCLUSIONS</div>`);
            formatted = formatted.replace(/^(ACTIONS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">ACTIONS</div>`);

            // Clean up actions section - remove extra headers and ensure proper numbering
            formatted = formatted.replace(/\*\*SECOND RECOMMENDATION\*\*[\s\S]*?\n/g, '');
            formatted = formatted.replace(/\*\*THIRD RECOMMENDATION\*\*[\s\S]*?\n/g, '');

            // Convert bullet points to proper HTML lists with member color
            // First, identify sections and wrap their content appropriately
            const sections = formatted.split(/(<div class="analysis-section">.*?<\/div>)/);
            let currentSection = '';

            formatted = sections.map(section => {
                if (section.includes('analysis-section')) {
                    // Update current section based on header
                    if (section.includes('METRICS')) currentSection = 'metrics';
                    else if (section.includes('ACTIONS')) currentSection = 'actions';
                    else if (section.includes('FINDINGS')) currentSection = 'findings';
                    else currentSection = '';
                    return section; // Keep headers as-is
                }

                // Process content sections
                let content = section;

                // Handle metrics section (uses - bullets)
                if (currentSection === 'metrics') {
                    content = content.replace(/^- (.*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;">$1</li>`);
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ul style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ul>`);
                }

                // Handle actions section (uses numbered bullets)
                if (currentSection === 'actions') {
                    // Clean up any malformed numbering - remove all leading numbers and unwanted headers
                    content = content.replace(/SECOND RECOMMENDATION/gi, ''); // Remove unwanted headers
                    content = content.replace(/THIRD RECOMMENDATION/gi, ''); // Remove unwanted headers
                    
                    // Clean up malformed numbering patterns like "1. 1." by removing all leading numbers
                    content = content.replace(/^[\d\.\s]+(.*?)(?=\n|$)/gm, (match, text) => {
                        // Remove all leading numbers and dots/spaces to get clean action text
                        const cleanText = text.trim().replace(/^[\d\.\s]+/, '').trim();
                        return `<li style="color: ${memberColor} !important;">${cleanText}</li>`;
                    });
                    
                    // Handle any remaining lines that might not have been caught
                    content = content.replace(/^([^-<\d].*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;">$1</li>`);
                    
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ol style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ol>`);
                }

                // Handle findings section (may have sub-bullets)
                if (currentSection === 'findings') {
                    content = content.replace(/^- \*\*(.*?):\*\* (.*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;"><strong style="color: ${memberColor} !important;">$1:</strong> $2</li>`);
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ul style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ul>`);
                }

                return content;
            }).join('');

            // Preserve line breaks but clean up excessive whitespace
            formatted = formatted.replace(/\n{3,}/g, '\n\n');
            formatted = formatted.replace(/\n/g, '<br>');

            // Clean up list formatting
            formatted = formatted.replace(/<\/li><br>/g, '</li>');
            formatted = formatted.replace(/<br><li>/g, '<li>');
            formatted = formatted.replace(/<br><ul>/g, '<ul>');
            formatted = formatted.replace(/<\/ul><br>/g, '</ul>');

            // Wrap in a container with proper styling
            formatted = `<div style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; white-space: normal; color: ${memberColor} !important;">${formatted}</div>`;

            return formatted;
        }

        async function queryOllama(model, prompt) {
            console.log(`üöÄ Starting Ollama query for model: ${model}`);
            console.log(`üìù Prompt length: ${prompt.length} characters`);
            
            try {
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        system: "You are an expert AI analyst. Analyze the provided data and write a structured report. Start directly with **SUMMARY** and follow the exact format specified in the prompt. Do not include any introductory text or copy the prompt structure - generate your own analysis content. In the ACTIONS section, provide exactly 3 numbered recommendations without any sub-headers like 'SECOND RECOMMENDATION'.",
                        prompt: prompt,
                        stream: false,
                        options: {
                            temperature: 0.7,  // Natural creativity for fluid AI responses
                            top_p: 0.5,
                            num_predict: 8192,  // Maximum token output for complete analysis
                            seed: Date.now()  // Add randomness to avoid cached responses
                        }
                    })
                });
                
                console.log(`üì° Ollama HTTP response status: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`Ollama HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                let rawResponse = data.response || '';

                // Log the raw response for debugging
                console.log('Raw Ollama response:', rawResponse);

                // Evaluate template literals in the response
                let evaluatedResponse = evaluateTemplateLiterals(rawResponse);
                
                // Strip any conversational text before the report structure
                const summaryIndex = evaluatedResponse.indexOf('**SUMMARY**');
                if (summaryIndex > 0) {
                    evaluatedResponse = evaluatedResponse.substring(summaryIndex);
                }
                
                // Enforce proper report structure formatting
                evaluatedResponse = enforceReportStructure(evaluatedResponse);
                
                console.log('Template evaluation result:', evaluatedResponse.substring(0, 200) + '...');
                
                return evaluatedResponse;
            } catch (error) {
                // No fallback - re-throw the error to be handled upstream
                console.error('Ollama query failed:', error.message);
                throw error;
            }
        }

        // ========================================
        // TEMPLATE LITERAL EVALUATION
        // ========================================

        function evaluateTemplateLiterals(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            console.log('üîß Evaluating template literals in response...');
            
            // Get current context data for template substitution
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const changeCount = surveillanceState.changeCount || 0;
            const timestamp = new Date().toLocaleTimeString();
            const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
            const feedCount = aiFeeds.length;
            const memoryData = localStorage.getItem('ai_memory_state') || '{}';
            const memoryItems = Object.keys(JSON.parse(memoryData)).length;

            console.log(`üìä Context data - changeCount: ${changeCount}, canvasLength: ${canvasContent.length}, feedCount: ${feedCount}`);

            // Create evaluation context with all available data
            const context = {
                changeCount: changeCount,
                canvasContent: canvasContent,
                canvasLength: canvasContent.length,
                timestamp: timestamp,
                feedCount: feedCount,
                memoryItems: memoryItems,
                wordCount: canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length,
                lineCount: canvasContent.split('\n').length,
                activityLevel: calculateActivityLevel(canvasContent, feedCount, canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length),
                dataDensity: (canvasContent.split('\n').length > 0) ? (canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length / canvasContent.split('\n').length).toFixed(1) : '0.0'
            };

            try {
                // Replace template literals with actual values
                let evaluatedResponse = response;

                // Check if response contains template literals
                const hasTemplates = /\$\{[^}]+\}/.test(evaluatedResponse);
                console.log(`üîç Response contains template literals: ${hasTemplates}`);

                // Handle common template patterns
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount\}/g, context.changeCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{canvasContent\.length\}/g, context.canvasLength);
                evaluatedResponse = evaluatedResponse.replace(/\$\{timestamp\}/g, context.timestamp);
                evaluatedResponse = evaluatedResponse.replace(/\$\{feedCount\}/g, context.feedCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{memoryItems\}/g, context.memoryItems);
                evaluatedResponse = evaluatedResponse.replace(/\$\{wordCount\}/g, context.wordCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{lineCount\}/g, context.lineCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{activityLevel\}/g, context.activityLevel);
                evaluatedResponse = evaluatedResponse.replace(/\$\{dataDensity\}/g, context.dataDensity);

                // Handle conditional template expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount > 5 \? 'high' : 'moderate'\}/g, context.changeCount > 5 ? 'high' : 'moderate');
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount > 10 \? 'mature' : changeCount > 5 \? 'growing' : 'initial'\}/g, context.changeCount > 10 ? 'mature' : context.changeCount > 5 ? 'growing' : 'initial');
                evaluatedResponse = evaluatedResponse.replace(/\$\{canvasLength > 1000 \? 'complex' : 'emerging'\}/g, context.canvasLength > 1000 ? 'complex' : 'emerging');
                evaluatedResponse = evaluatedResponse.replace(/\$\{text\.includes\('governance'\) \? 'specific rules' : 'overall strategy'\}/g, canvasContent.toLowerCase().includes('governance') ? 'specific rules' : 'overall strategy');
                evaluatedResponse = evaluatedResponse.replace(/\$\{feedCount > 0 \? 'ACTIVE' : 'IDLE'\}/g, context.feedCount > 0 ? 'ACTIVE' : 'IDLE');
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(changeCount \* 15, 100\)\}/g, Math.min(context.changeCount * 15, 100));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(changeCount, 10\)\}/g, Math.min(context.changeCount, 10));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(canvasLength \/ 100, 100\)\}/g, Math.min(context.canvasLength / 100, 100));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(wordCount \/ 10, 100\)\}/g, Math.min(context.wordCount / 10, 100));

                // Handle more complex expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount \* 10 \% 100\}/g, (context.changeCount * 10) % 100);
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.abs\(canvasLength - \d+\)\}/g, (match) => {
                    const targetLength = parseInt(match.match(/\d+/)[0]);
                    return Math.abs(context.canvasLength - targetLength);
                });

                // Handle array length expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{aiFeeds\.length\}/g, context.feedCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{Array\.isArray\(analysis\.data\) \? analysis\.data\.length : 'N\/A'\}/g, 'N/A'); // Default to N/A for unknown data

                return evaluatedResponse;
            } catch (error) {
                console.warn('Template literal evaluation failed:', error);
                return response; // Return original response if evaluation fails
            }
        }

        // ========================================
        // COUNCIL MEMORY SYSTEM
        // ========================================

        const councilMemories = {
            pattern: [],
            wisdom: [],
            paradox: [],
            boundaries: [],
            memory: []
        };

        function initializeCouncilMemories() {
            // Initialize fresh memories each session for optimal analysis
            updateCouncilStatusDisplay();
        }

        function storeCouncilMemory(memberKey, analysis, context) {
            const memory = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                analysis: analysis,
                context: context,
                eventType: context.type || 'unknown',
                canvasLength: context.canvasLength || 0,
                insights: extractInsightsFromAnalysis(analysis)
            };

            councilMemories[memberKey].push(memory);

            // Keep last 50 memories per member
            if (councilMemories[memberKey].length > 50) {
                councilMemories[memberKey] = councilMemories[memberKey].slice(-50);
            }

            // Session-only memories - no persistence for fresh analysis each session
            updateCouncilStatusDisplay();
        }

        function extractInsightsFromAnalysis(analysis) {
            const insights = [];

            // Extract key patterns from analysis
            const patterns = analysis.match(/(?:pattern|trend|behavior|issue|concern|opportunity|risk)[\w\s]{10,50}/gi) || [];
            insights.push(...patterns.slice(0, 3));

            // Extract metrics
            const metrics = analysis.match(/\d+[%]?|\b(?:high|low|critical|normal)\b/gi) || [];
            insights.push(...metrics.slice(0, 3));

            return insights;
        }

        function getRelevantMemories(memberKey, currentContext) {
            const memories = councilMemories[memberKey] || [];
            if (memories.length < 3) return []; // Don't use memories until we have some history

            // Only find memories if there's a strong contextual match
            const relevantMemories = memories.filter(memory => {
                // Same event type
                if (currentContext.type && memory.eventType === currentContext.type) return true;

                // Similar content size (major changes only)
                if (currentContext.canvasLength && memory.canvasLength > 0) {
                    const sizeDiff = Math.abs(memory.canvasLength - currentContext.canvasLength);
                    if (sizeDiff < 500 && currentContext.canvasLength > 2000) return true; // Similar substantial content
                }

                // Look for recurring insights/patterns
                if (memory.insights && memory.insights.length > 0) {
                    const currentAnalysis = currentContext.analysis || '';
                    const hasMatchingInsight = memory.insights.some(insight =>
                        currentAnalysis.toLowerCase().includes(insight.toLowerCase().substring(0, 20))
                    );
                    if (hasMatchingInsight) return true;
                }

                return false;
            });

            // Only return memories if we found genuinely relevant ones
            if (relevantMemories.length === 0) return [];

            return relevantMemories
                .slice(-5) // Maximum 5 relevant memories
                .map(memory => ({
                    timestamp: new Date(memory.timestamp).toLocaleTimeString(),
                    analysis: memory.analysis.substring(0, 150),
                    insights: memory.insights.slice(0, 2),
                    relevance: memory.eventType === currentContext.type ? 'high' : 'medium'
                }));
        }

        function shouldUseMemories(memberKey, currentContext) {
            const relevantMemories = getRelevantMemories(memberKey, currentContext);
            return relevantMemories.length > 0;
        }

        function updateCouncilStatusDisplay() {
            const statusElement = document.getElementById('councilMemberStatus');
            if (!statusElement) return;

            const statusHTML = [
                `PATTERN: ‚úÖ (${councilMemories.pattern.length} memories)`,
                `WISDOM: ‚úÖ (${councilMemories.wisdom.length} memories)`,
                `PARADOX: ‚úÖ (${councilMemories.paradox.length} memories)`,
                `BOUNDARIES: ‚úÖ (${councilMemories.boundaries.length} memories)`,
                `MEMORY: ‚úÖ (${councilMemories.memory.length} memories)`
            ].join('<br>');

            statusElement.innerHTML = statusHTML;
        }

        // ========================================
        // COLLABORATIVE ANALYSIS HELPERS
        // ========================================

        function extractKeyInsights(responses) {
            const insights = {
                patterns: [],
                metrics: [],
                concerns: [],
                recommendations: [],
                crossReferences: []
            };

            responses.forEach(response => {
                if (!response || response.error) return;

                const text = response.response || '';
                const memberType = response.member || 'unknown';

                // Extract metrics (numbers, percentages, specific measurements)
                const metricMatches = text.match(/\d+[%]?|\b(?:high|low|critical|normal|optimal|severe)\b/gi) || [];
                insights.metrics.push(...metricMatches.map(m => `${memberType}: ${m}`));

                // Extract pattern keywords
                const patternMatches = text.match(/(?:pattern|trend|behavior|cycle|routine|structure|framework|system|model|approach|method)\s+[a-z\s]{5,30}/gi) || [];
                insights.patterns.push(...patternMatches.map(m => `${memberType}: ${m.trim()}`));

                // Extract concerns and issues
                const concernMatches = text.match(/(?:concern|issue|problem|risk|threat|vulnerability|challenge|limitation|gap|error|failure)\s+[a-z\s]{5,40}/gi) || [];
                insights.concerns.push(...concernMatches.map(m => `${memberType}: ${m.trim()}`));

                // Extract recommendations and actions
                const actionMatches = text.match(/(?:recommend|suggest|propose|should|must|need to|implement|consider|improve|optimize|enhance|address)\s+[a-z\s]{5,50}/gi) || [];
                insights.recommendations.push(...actionMatches.map(m => `${memberType}: ${m.trim()}`));

                // Look for cross-references to other systems or concepts
                const crossRefMatches = text.match(/(?:connects to|relates to|correlates with|links to|impacts|influences|depends on|affects)\s+[a-z\s]{5,30}/gi) || [];
                insights.crossReferences.push(...crossRefMatches.map(m => `${memberType}: ${m.trim()}`));
            });

            // Remove duplicates and limit size
            Object.keys(insights).forEach(key => {
                insights[key] = [...new Set(insights[key])].slice(0, 5);
            });

            return insights;
        }

        function enhancePromptWithInsights(basePrompt, priorInsights, memberType) {
            const relevantInsights = filterInsightsForMember(priorInsights, memberType);

            if (relevantInsights.length === 0) {
                return basePrompt;
            }

            const insightContext = `\n\n=== COUNCIL COLLABORATION CONTEXT ===\nPrior analysis from other council members revealed:\n${relevantInsights.join('\n')}\n\nBuild upon these insights in your analysis. Look for correlations, contradictions, or complementary perspectives. Your unique ${memberType} perspective should enhance and connect with these findings.\n========================\n\n`;

            return basePrompt + insightContext;
        }

        function filterInsightsForMember(insights, memberType) {
            const relevantInsights = [];

            // Each member type gets different types of insights to build upon
            switch(memberType) {
                case 'paradox':
                    // Paradox looks for contradictions and tensions
                    relevantInsights.push(...insights.patterns);
                    relevantInsights.push(...insights.concerns);
                    break;

                case 'boundaries':
                    // Boundaries examines limits and constraints
                    relevantInsights.push(...insights.metrics);
                    relevantInsights.push(...insights.recommendations);
                    break;

                case 'memory':
                    // Memory synthesizes all insights
                    relevantInsights.push(...insights.patterns);
                    relevantInsights.push(...insights.crossReferences);
                    relevantInsights.push(...insights.concerns);
                    break;

                default:
                    // Default gets a mix
                    relevantInsights.push(...insights.patterns.slice(0, 2));
                    relevantInsights.push(...insights.metrics.slice(0, 2));
                    break;
            }

            return relevantInsights.slice(0, 6); // Limit to prevent prompt bloat
        }

        function synthesizeCollaborativeConsensus(responses, analysis, insightHistory) {
            // First get standard consensus
            const baseConsensus = synthesizeConsensus(responses, analysis);

            // Enhance with cross-pollination analysis
            const collaborationMetrics = analyzeCollaboration(insightHistory);

            // Add collaboration insights to consensus
            baseConsensus.collaborationScore = collaborationMetrics.score;
            baseConsensus.crossPollination = collaborationMetrics.connections;
            baseConsensus.emergentInsights = collaborationMetrics.emergentPatterns;

            return baseConsensus;
        }

        function analyzeCollaboration(insightHistory) {
            const connections = [];
            let score = 0;
            const emergentPatterns = [];

            // Analyze how insights evolved across stages
            if (insightHistory.stage1Insights && insightHistory.stage2Insights) {
                // Look for build-up patterns
                const stage1Patterns = new Set(insightHistory.stage1Insights.patterns);
                const stage2Patterns = new Set(insightHistory.stage2Insights.patterns);

                // Find connections
                stage1Patterns.forEach(pattern => {
                    if ([...stage2Patterns].some(p2 => p2.includes(pattern.split(':')[1]?.trim()))) {
                        connections.push(`Pattern evolution: ${pattern}`);
                        score += 10;
                    }
                });

                // Look for emergent insights (unique to later stages)
                const stage2Unique = [...stage2Patterns].filter(p =>
                    ![...stage1Patterns].some(p1 => p.includes(p1.split(':')[1]?.trim()))
                );
                emergentPatterns.push(...stage2Unique.slice(0, 3));
            }

            // Calculate collaboration effectiveness
            score += connections.length * 5;
            score += emergentPatterns.length * 8;
            score = Math.min(score, 100); // Cap at 100

            return {
                score,
                connections,
                emergentPatterns
            };
        }

        async function synthesizeConsensus(responses, analysis) {
            const validResponses = responses.filter(r => !r.error);

            if (validResponses.length === 0) {
                return {
                    status: 'FAILED',
                    summary: 'Council analysis failed - no valid responses',
                    confidence: 0
                };
            }

            // Create AI-powered consensus synthesis prompt
            const consensusPrompt = `DJINN COUNCIL CONSENSUS SYNTHESIS
SESSION: ${djinnCouncilMemory.sessionId}

COUNCIL ANALYSES (${validResponses.length} members):
${validResponses.map(r => `
[${councilMembers[r.member].name.toUpperCase()}]
${r.response.substring(0, 500)}${r.response.length > 500 ? '...' : ''}
`).join('\n')}

CRITICAL REQUIREMENTS:
- SYNTHESIZE new insights from member analyses (do not repeat member content)
- Identify PATTERNS ACROSS all members (not individual findings)
- Create COLLABORATIVE conclusions that emerge from cross-pollination
- Focus on SYSTEMIC themes, not individual member observations

Output concise synthesis (max 600 words):

**SYNTHESIS OVERVIEW**
[2-3 sentences synthesizing collective insights - what emerges when all members' perspectives are combined?]

**CROSS-MEMBER PATTERNS**
‚Ä¢ [Pattern that appears across multiple members]
‚Ä¢ [Systemic theme identified in the collective analysis]
‚Ä¢ [Collaborative insight that emerges from cross-pollination]

**EMERGENT INSIGHTS**
‚Ä¢ [New insight that emerges from combining member perspectives]
‚Ä¢ [Collaborative conclusion not present in individual analyses]
‚Ä¢ [Systemic pattern revealed through council integration]

**RISK ASSESSMENT**
[Synthesized risk evaluation considering all member perspectives together]

**STRATEGIC RECOMMENDATIONS**
1. [Recommendation based on collective council wisdom]
2. [Cross-member optimization strategy]
3. [Systemic improvement derived from council synthesis]

**CONFIDENCE LEVEL**
[High/Medium/Low with justification based on consensus strength]

Keep under 600 words. Focus on SYNTHESIS, not repetition. Create NEW insights from COLLABORATION.`;

            try {
                // Use gemma3:1b for consensus synthesis
                const consensusResponse = await queryOllama('gemma3:1b', consensusPrompt);

                // Parse the AI-generated consensus
                const synthesisMatch = consensusResponse.match(/\*\*SYNTHESIS OVERVIEW\*\*(.*?)(?=\*\*CROSS-MEMBER PATTERNS\*\*|$)/s);
                const patternsMatch = consensusResponse.match(/\*\*CROSS-MEMBER PATTERNS\*\*(.*?)(?=\*\*EMERGENT INSIGHTS\*\*|$)/s);
                const insightsMatch = consensusResponse.match(/\*\*EMERGENT INSIGHTS\*\*(.*?)(?=\*\*RISK ASSESSMENT\*\*|$)/s);
                const riskMatch = consensusResponse.match(/\*\*RISK ASSESSMENT\*\*(.*?)(?=\*\*STRATEGIC RECOMMENDATIONS\*\*|$)/s);
                const recommendationsMatch = consensusResponse.match(/\*\*STRATEGIC RECOMMENDATIONS\*\*(.*?)(?=\*\*CONFIDENCE LEVEL\*\*|$)/s);
                const confidenceMatch = consensusResponse.match(/\*\*CONFIDENCE LEVEL\*\*(.*)$/s);

                const synthesis = synthesisMatch ? synthesisMatch[1].trim() : 'Consensus synthesis completed';
                const patterns = patternsMatch ? patternsMatch[1].trim() : 'Cross-member analysis completed';
                const insights = insightsMatch ? insightsMatch[1].trim() : 'Emergent insights identified';
                const riskAssessment = riskMatch ? riskMatch[1].trim() : 'Risk assessment completed';
                const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : 'Strategic recommendations provided';
                const confidence = confidenceMatch ? confidenceMatch[1].trim() : 'High';

                // Calculate confidence score from AI response
                let confidenceScore = 0.7; // Default medium confidence
                if (confidence.toLowerCase().includes('high')) confidenceScore = 0.9;
                else if (confidence.toLowerCase().includes('low')) confidenceScore = 0.4;

                // Extract key insights from each member response for display
                const memberInsights = validResponses.map(r => {
                    const memberName = councilMembers[r.member].name;
                    const response = r.response;

                    // Parse metrics more intelligently
                    let formattedMetrics = 'No metrics available';
                    let formattedAnalysis = 'No analysis available';

                    // Extract metrics section
                    const metricsMatch = response.match(/\*\*METRICS\*\*(.*?)(?=\*\*ANALYSIS\*\*|\*\*CONCLUSIONS\*\*|\*\*ACTIONS\*\*|$)/s);
                    if (metricsMatch) {
                        const metricsText = metricsMatch[1].trim();
                        const metricLines = metricsText.split('\n').filter(line => line.trim() && !line.includes('**') && !line.includes('['));

                        // Parse each metric line into structured format
                        const parsedMetrics = metricLines.map(line => {
                            // Handle metric lines with values and justifications
                            const valueMatch = line.match(/^([^:]+):\s*([^,]+)(?:,\s*Justification:\s*(.+))?$/);
                            if (valueMatch) {
                                const metricName = valueMatch[1].trim();
                                const metricValue = valueMatch[2].trim();
                                const justification = valueMatch[3] ? valueMatch[3].trim() : null;

                                if (justification) {
                                    return `<div style="margin: 2px 0;"><strong>${metricName}:</strong> <span style="color: #ffff00;">${metricValue}</span><br><small style="color: #cccccc;">${justification}</small></div>`;
                                } else {
                                    return `<strong>${metricName}:</strong> <span style="color: #ffff00;">${metricValue}</span>`;
                                }
                            }

                            // Fallback for other formats
                            const colonMatch = line.match(/^([^:]+):\s*(.+)$/);
                            if (colonMatch) {
                                const key = colonMatch[1].trim();
                                const value = colonMatch[2].trim();
                                return `<strong>${key}:</strong> ${value}`;
                            }
                            return line.trim();
                        }).filter(metric => metric.length > 0);

                        formattedMetrics = parsedMetrics.join('') || 'No metrics available';
                    }

                    // Extract analysis section (clean version without frameworks)
                    const analysisMatch = response.match(/\*\*ANALYSIS\*\*(.*?)(?=\*\*FINDINGS\*\*|\*\*CONCLUSIONS\*\*|\*\*ACTIONS\*\*|$)/s);
                    if (analysisMatch) {
                        let analysisText = analysisMatch[1].trim();
                        // Clean up the analysis text more thoroughly
                        analysisText = analysisText
                            .replace(/\*\*CONCLUSIONS\*\*.*/s, '') // Remove conclusions section
                            .replace(/\*\*ACTIONS\*\*.*/s, '') // Remove actions section
                            .replace(/^\s*[-‚Ä¢*]\s*/gm, '') // Remove bullet points
                            .replace(/\s+/g, ' ') // Normalize whitespace
                            .replace(/\*\*.*?\*\*/g, '') // Remove any remaining bold markers
                            .trim();

                        formattedAnalysis = analysisText || 'Analysis not available';
                    }

                    return `<div style="margin: 6px 0; padding: 6px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                        <strong>${memberName}:</strong><br>
                        <div style="margin: 4px 0; color: #00ff88; font-size: 10px;">${formattedMetrics}</div>
                        <div style="margin: 4px 0; color: #ffffff; font-size: 11px; line-height: 1.3;">${formattedAnalysis}</div>
                    </div>`;
                }).join('');

                // Build AI-powered consensus object
                const consensusResult = {
                    status: 'APPROVED',
                    summary: synthesis,
                    confidence: confidenceScore,
                    theme: 'ai_synthesized_consensus',
                    responses: validResponses,
                    crossMemberPatterns: patterns,
                    emergentInsights: insights,
                    riskAssessment: { overall: riskAssessment },
                    recommendations: recommendations.split('\n').filter(line => line.trim().startsWith('1.') || line.trim().startsWith('2.') || line.trim().startsWith('3.')).map(line => line.trim().substring(3).trim()),
                    collaborationScore: Math.round(confidenceScore * 100),
                    crossPollination: patterns.split('‚Ä¢').filter(item => item.trim()).slice(0, 3).map(item => item.trim()),
                    emergentInsights: insights.split('‚Ä¢').filter(item => item.trim()).slice(0, 2).map(item => item.trim())
                };

                // Add collaboration metrics
                const collaborationSection = `
                    <strong>üîÑ AI-POWERED COLLABORATIVE SYNTHESIS</strong><br>
                    <div style="margin: 8px 0; padding: 8px; background: rgba(0, 170, 255, 0.1); border-left: 3px solid #00aaff; border-radius: 4px;">
                        <div style="color: #00ff88; font-weight: bold;">AI Synthesis Confidence: ${Math.round(confidenceScore * 100)}%</div>
                        <div style="margin-top: 4px; font-size: 10px;">Cross-Member Patterns: ${consensusResult.crossPollination?.length || 0} identified</div>
                        <div style="margin-top: 4px; font-size: 10px; color: #ff88ff;">Emergent Insights: ${consensusResult.emergentInsights?.length || 0} synthesized</div>
                    </div>`;

                // Update consensus display with AI-synthesized insights
                const consensusHTML = `
                    <div class="intel-entry intel-insight">
                        <div class="intel-timestamp">${new Date().toLocaleTimeString()}</div>
                        <strong>üß† AI-SYNTHESIZED COUNCIL CONSENSUS</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(204, 136, 204, 0.1); border-left: 3px solid #cc88cc; border-radius: 4px;">
                            ${synthesis}
                        </div>
                        <strong>üîç MEMBER ANALYSES</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(0, 255, 136, 0.1); border-left: 3px solid #00ff88; border-radius: 4px;">
                            ${memberInsights}
                        </div>
                        ${collaborationSection}
                        <strong>üéØ AI RISK ASSESSMENT</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255, 170, 0, 0.1); border-left: 3px solid #ffaa00; border-radius: 4px;">
                            ${riskAssessment}
                        </div>
                        <strong>üìã AI STRATEGIC RECOMMENDATIONS</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255, 136, 255, 0.1); border-left: 3px solid #ff88ff; border-radius: 4px;">
                            ${recommendations}
                        </div>
                    </div>
                `;

                document.getElementById('consensusFeed').innerHTML = consensusHTML + document.getElementById('consensusFeed').innerHTML;

                return consensusResult;

            } catch (error) {
                console.error('AI consensus synthesis failed:', error);

                // Fallback to basic consensus if AI fails
                const themes = {
                    governance_gap: 0,
                    performance_issue: 0,
                    innovation_opportunity: 0,
                    sovereignty_concern: 0,
                    memory_anomaly: 0
                };

                validResponses.forEach(r => {
                    const text = r.response.toLowerCase();
                    if (text.includes('governance') || text.includes('authority')) themes.governance_gap++;
                    if (text.includes('performance') || text.includes('efficiency')) themes.performance_issue++;
                    if (text.includes('innovation') || text.includes('opportunity')) themes.innovation_opportunity++;
                    if (text.includes('autonomy') || text.includes('sovereignty')) themes.sovereignty_concern++;
                    if (text.includes('memory') || text.includes('retention')) themes.memory_anomaly++;
                });

                const primaryTheme = Object.entries(themes).sort((a, b) => b[1] - a[1])[0][0];
                const confidence = validResponses.length / 5;

                const summary = `AI synthesis failed - using basic consensus. Primary concern: ${primaryTheme.replace('_', ' ')}. Confidence: ${(confidence * 100).toFixed(0)}%.`;

                return {
                    status: 'DEGRADED',
                    summary: summary,
                    confidence: confidence,
                    theme: primaryTheme,
                    responses: validResponses,
                    error: 'AI synthesis unavailable'
                };
            }
        }

        // ========================================
        // INTELLIGENCE MANAGEMENT
        // ========================================

        async function generateIntelligenceEntry(analysis, consensus) {
            const severity = consensus.confidence > 0.8 ? 'critical' :
                           consensus.confidence > 0.6 ? 'warning' : 'insight';

            // Generate unified AI-powered intelligence report
            let intelligenceReport;
            try {
                intelligenceReport = await generateUnifiedIntelligence(analysis, consensus);
            } catch (error) {
                console.error('Intelligence generation failed:', error);
                intelligenceReport = {
                    actionable: ['Intelligence synthesis failed', 'Manual analysis required', 'Check system logs'],
                    correlations: 'Analysis failed due to AI synthesis error',
                    recommendations: 'Manual intelligence assessment needed',
                    risk_assessment: 'Unable to assess risks automatically',
                    strategic_implications: 'Strategic analysis unavailable'
                };
            }

            return {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                type: analysis.type || 'intelligence_report',
                severity: severity,
                theme: consensus.theme || 'intelligence_synthesis',
                summary: consensus.summary || 'AI-powered intelligence analysis completed',
                data: analysis.data,
                consensus: consensus,
                actionable: intelligenceReport.actionable,
                correlations: intelligenceReport.correlations,
                recommendations: intelligenceReport.recommendations,
                risk_assessment: intelligenceReport.risk_assessment,
                strategic_implications: intelligenceReport.strategic_implications
            };
        }

        async function generateUnifiedIntelligence(analysis, consensus) {
            // Determine if we have council consensus data or need standalone analysis
            const hasConsensus = consensus && consensus.responses && consensus.responses.length > 0;

            if (hasConsensus) {
                try {
                    // Use council-based intelligence synthesis
                    const allResponses = consensus.responses || [];
                    const responseTexts = allResponses.map(r => `${councilMembers[r.member].name}: ${r.response}`).join('\n\n');

                    const intelPrompt = `COMPREHENSIVE CANVAS INTELLIGENCE SYNTHESIS

You are analyzing the complete ecosystem: document evolution, dashboard state, memory banks, and insights.

DJINN COUNCIL COMPREHENSIVE ANALYSIS:
${responseTexts.substring(0, 2000)}

COMPLETE SYSTEM STATE:
Summary: ${consensus.summary || 'Comprehensive analysis completed'}
Confidence Level: ${(consensus.confidence * 100).toFixed(1)}%
Primary Theme: ${consensus.theme || 'Ecosystem analysis'}

MEMORY BANK STATUS:
- Council Memory Reports: ${Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0)} total reports across all members
- AI System Memory: ${Object.keys(JSON.parse(localStorage.getItem('ai_memory_state') || '{}')).length} systems with stored memories
- Canvas Content: ${JSON.stringify(analysis.data).length} characters
- Dashboard Metrics: Active surveillance and monitoring

ANALYSIS SCOPE: Document evolution + Complete memory analysis + Dashboard monitoring + All insights synthesis

[INTELLIGENCE ASSESSMENT]
What patterns emerge from the complete ecosystem analysis? Consider: canvas content evolution, memory bank trends across all 25 reports per agent, dashboard metrics, stored insights, and cross-system correlations. What does the comprehensive data reveal?

[RISK EVALUATION]
What risks exist across the entire ecosystem? Analyze: content development trajectory, memory fragmentation across agents, insight accumulation patterns, dashboard anomalies, and system coherence issues.

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [Document/content development action based on comprehensive analysis]
‚Ä¢ [Memory management or insight synthesis improvement]
‚Ä¢ [Dashboard monitoring or metric optimization strategy]

[STRATEGIC IMPLICATIONS]
How should the complete canvas ecosystem evolve? What does the analysis of all memories, insights, dashboard state, and content patterns suggest for strategic development?

REQUIREMENTS: Synthesize insights from ALL data sources - document content, memory banks, dashboard metrics, and stored insights. Focus on comprehensive ecosystem intelligence.`;
                    const intelligenceResponse = await queryOllama('gemma3:1b', intelPrompt);

                    // Parse the structured response
                    const correlations = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s)?.[1]?.trim() || 'No correlations identified';
                    const riskAssessment = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s)?.[1]?.trim() || 'Risk assessment unavailable';
                    const recommendations = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s)?.[1]?.trim() || 'No recommendations available';
                    const strategic = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s)?.[1]?.trim() || 'Strategic analysis pending';

                    // Format recommendations as array
                    const actionableItems = recommendations.split('\n')
                        .filter(line => line.trim().startsWith('‚Ä¢'))
                        .map(line => line.trim().substring(1).trim())
                        .filter(item => item.length > 0);

                    return {
                        actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review council consensus'],
                        correlations: correlations,
                        recommendations: recommendations,
                        risk_assessment: riskAssessment,
                        strategic_implications: strategic
                    };

                } catch (error) {
                    console.error('Council-based intelligence synthesis failed:', error);
                    // Fall back to standalone analysis
                }
            }

            // Standalone intelligence analysis (fallback or when no consensus available)
            const canvasContent = analysis.data?.content || localStorage.getItem('sovereign_canvas_content') || '';

            const standalonePrompt = `INTELLIGENCE ANALYSIS

REAL AI SYSTEMS STATUS (ONLY THESE SYSTEMS EXIST):
${Object.entries(djinnCouncilMemory.canvasAISystems).map(([systemName, systemData]) => {
    const interactionCount = systemData.interactions ? systemData.interactions.length : 0;
    return `${systemName.toUpperCase()}: ${interactionCount} tracked interactions`;
}).join('\n')}

CANVAS CONTENT:
${canvasContent.substring(0, 1500)}${canvasContent.length > 1500 ? '\n[Content truncated]' : ''}

THREE-LAYER FRAMEWORK:
- LAYER 1: AI SYSTEMS (ONLY narra, nazar, whale, djinn, watchtower systems)
- LAYER 2: CANVAS CONTENT (data being analyzed)
- LAYER 3: EVOLUTION (content changes over time)

CRITICAL: Only analyze the 5 real AI systems listed above. Do NOT invent or reference any other systems.

Provide concise intelligence analysis (max 500 words):

[INTELLIGENCE ASSESSMENT]
[Analysis of the 5 real AI systems and their interaction with canvas content]

[RISK EVALUATION]
[Risks in the 5 AI systems operations vs. content processes]

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [Recommendation for the real AI systems]
‚Ä¢ [Content evolution recommendation]
‚Ä¢ [Interaction optimization for real systems]

[STRATEGIC IMPLICATIONS]
[Broader implications for all layers]`;

            try {
                const intelligenceResponse = await queryOllama('gemma3:1b', standalonePrompt);

                // Parse the structured response
                const assessmentMatch = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s);
                const riskMatch = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s);
                const recommendationsMatch = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s);
                const strategicMatch = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s);

                const assessment = assessmentMatch ? assessmentMatch[1].trim() : 'Intelligence assessment completed';
                const riskAssessment = riskMatch ? riskMatch[1].trim() : 'Risk evaluation completed';
                const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : 'Recommendations provided';
                const strategic = strategicMatch ? strategicMatch[1].trim() : 'Strategic analysis completed';

                // Format recommendations as array
                const actionableItems = recommendations.split('\n')
                    .filter(line => line.trim().startsWith('‚Ä¢'))
                    .map(line => line.trim().substring(1).trim())
                    .filter(item => item.length > 0);

                return {
                    actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review AI system performance'],
                    correlations: assessment,
                    recommendations: recommendations,
                    risk_assessment: riskAssessment,
                    strategic_implications: strategic
                };

            } catch (error) {
                console.error('Standalone intelligence generation failed:', error);
                // Fallback analysis
                return {
                    actionable: [
                        'AI intelligence synthesis failed - using basic analysis',
                        'Manual review of AI systems recommended',
                        'Monitor canvas content for emerging patterns'
                    ],
                    correlations: 'Basic intelligence assessment due to synthesis failure',
                    recommendations: 'Manual intelligence analysis required',
                    risk_assessment: 'Unable to assess risks automatically - manual review needed',
                    strategic_implications: 'Strategic intelligence analysis unavailable'
                };
            }
        }

        async function generateStandaloneIntelligence(analysis) {
            // Get current AI memory and canvas data for standalone analysis
            const canvasContent = analysis.data?.content || localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemoryData = analysis.data?.memory || localStorage.getItem('ai_memory_state') || '{}';

            let parsedMemory = {};
            try {
                parsedMemory = JSON.parse(aiMemoryData);
            } catch (e) {
                console.warn('Failed to parse AI memory for intelligence:', e);
            }

            const standalonePrompt = `INTELLIGENCE ANALYSIS

AI SYSTEMS STATUS:
${Object.entries(parsedMemory).map(([systemName, systemData]) => {
    const memoryCount = systemData?.conversationHistory?.length || 0;
    const insightCount = systemData?.keyInsights?.length || 0;
    return `${systemName.toUpperCase()}: ${memoryCount} interactions, ${insightCount} insights`;
}).join('\n')}

CANVAS CONTENT:
${canvasContent.substring(0, 1500)}${canvasContent.length > 1500 ? '\n[Content truncated]' : ''}

THREE-LAYER FRAMEWORK:
- LAYER 1: AI SYSTEMS (performance, memory)
- LAYER 2: CANVAS CONTENT (data being analyzed)
- LAYER 3: EVOLUTION (content changes over time)

Provide concise intelligence analysis (max 500 words):

[INTELLIGENCE ASSESSMENT]
[Analysis differentiating AI systems from content evolution]

[RISK EVALUATION] 
[Risks in AI operations vs. content processes]

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [AI system recommendation]
‚Ä¢ [Content evolution recommendation]
‚Ä¢ [Interaction optimization]

[STRATEGIC IMPLICATIONS]
[Broader implications for all layers]

Keep under 500 words.`;

            try {
                // Use gemma3:1b for standalone intelligence analysis
                const intelligenceResponse = await queryOllama('gemma3:1b', standalonePrompt);

                // Parse the structured response
                const assessmentMatch = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s);
                const riskMatch = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s);
                const recommendationsMatch = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s);
                const strategicMatch = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s);

                const assessment = assessmentMatch ? assessmentMatch[1].trim() : 'Intelligence assessment completed';
                const riskAssessment = riskMatch ? riskMatch[1].trim() : 'Risk evaluation completed';
                const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : 'Recommendations provided';
                const strategic = strategicMatch ? strategicMatch[1].trim() : 'Strategic analysis completed';

                // Format recommendations as array
                const actionableItems = recommendations.split('\n')
                    .filter(line => line.trim().startsWith('‚Ä¢'))
                    .map(line => line.trim().substring(1).trim())
                    .filter(item => item.length > 0);

                return {
                    actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review AI system performance'],
                    correlations: assessment,
                    recommendations: recommendations,
                    risk_assessment: riskAssessment,
                    strategic_implications: strategic
                };

            } catch (error) {
                console.error('Standalone intelligence generation failed:', error);
                // Fallback analysis
                return {
                    actionable: [
                        'AI intelligence synthesis failed - using basic analysis',
                        'Manual review of AI systems recommended',
                        'Monitor canvas content for emerging patterns'
                    ],
                    correlations: 'Basic intelligence assessment due to synthesis failure',
                    recommendations: 'Manual intelligence analysis required',
                    risk_assessment: 'Unable to assess risks automatically - manual review needed',
                    strategic_implications: 'Strategic intelligence analysis unavailable'
                };
            }
        }

        async function generateAIPoweredIntel(analysis, consensus) {
            // Compile all council member responses and analysis data
            const allResponses = consensus.responses || [];
            const responseTexts = allResponses.map(r => `${councilMembers[r.member].name}: ${r.response}`).join('\n\n');

            const intelPrompt = `INTELLIGENCE SYNTHESIS

COUNCIL ANALYSES:
${responseTexts.substring(0, 2000)}${responseTexts.length > 2000 ? '\n[Analyses truncated]' : ''}

SYSTEM DATA:
Content: ${JSON.stringify(analysis.data).length} chars
Confidence: ${(consensus.confidence * 100).toFixed(1)}%

Synthesize intelligence (max 400 words):

[INTELLIGENCE ASSESSMENT]
[Key correlations and patterns]

[RISK EVALUATION]
[Risk assessment]

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [Specific actionable item 1]
‚Ä¢ [Specific actionable item 2]
‚Ä¢ [Specific actionable item 3]

[STRATEGIC IMPLICATIONS]
[Strategic analysis]`;

            try {
                // Use gemma3:1b for intelligence synthesis
                const intelligenceResponse = await queryOllama('gemma3:1b', intelPrompt);

                // Parse the structured response
                const correlations = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s)?.[1]?.trim() || 'No correlations identified';
                const riskAssessment = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s)?.[1]?.trim() || 'Risk assessment unavailable';
                const recommendations = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s)?.[1]?.trim() || 'No recommendations available';
                const strategic = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s)?.[1]?.trim() || 'Strategic analysis pending';

                // Format recommendations as array
                const actionableItems = recommendations.split('\n')
                    .filter(line => line.trim().startsWith('‚Ä¢'))
                    .map(line => line.trim().substring(1).trim())
                    .filter(item => item.length > 0);

                return {
                    actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review council consensus'],
                    correlations: correlations,
                    recommendations: recommendations,
                    risk_assessment: riskAssessment,
                    strategic_implications: strategic
                };

            } catch (error) {
                console.error('Intelligence synthesis failed:', error);
                // Fallback to basic analysis
                return {
                    actionable: [
                        'System analysis completed with limited AI synthesis',
                        'Manual review of council responses recommended',
                        'Monitor for recurring patterns in future analyses'
                    ],
                    correlations: 'Basic correlation analysis due to synthesis failure',
                    recommendations: 'Manual intelligence assessment required',
                    risk_assessment: 'Unable to assess risks automatically'
                };
            }
        }

        function storeIntelligence(report) {
            surveillanceState.intelligenceReports.unshift(report);
            
            // Limit storage
            if (surveillanceState.intelligenceReports.length > DJINN_CONFIG.MEMORY_LIMIT) {
                surveillanceState.intelligenceReports.pop();
            }
            
            surveillanceState.reportCount++;
            document.getElementById('reportCount').textContent = surveillanceState.reportCount;
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('djinn_intelligence', JSON.stringify(surveillanceState.intelligenceReports));
            } catch (error) {
                console.error('Failed to store intelligence:', error);
            }
        }

        function displayIntelligence(report) {
            // Handle legacy reports that might not have all properties
            const severity = report.severity || 'insight';
            const reportType = report.type || 'unknown';
            const summary = report.summary || 'No summary available';
            const timestamp = report.timestamp || new Date().toISOString();
            
            const severityClass = `intel-${severity}`;
            const html = `
                <div class="intel-entry ${severityClass}">
                    <div class="intel-timestamp">${new Date(timestamp).toLocaleTimeString()}</div>
                    <div style="margin-bottom: 12px; font-weight: bold; font-size: 12px;">
                        [${severity.toUpperCase()}] ${reportType}
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Consensus</div>
                        <div class="intel-content">${summary}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Intelligence Assessment</div>
                        <div class="intel-content">${report.correlations || 'Analysis in progress'}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Risk Evaluation</div>
                        <div class="intel-content">${report.risk_assessment || 'Risk assessment pending'}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Actionable Recommendations</div>
                        <div class="intel-content">
                            ${Array.isArray(report.actionable) ?
                                `<ul class="intel-recommendations">${report.actionable.map(a => `<li>${a}</li>`).join('')}</ul>` :
                                (report.actionable || 'No recommendations available')
                            }
                        </div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Strategic Implications</div>
                        <div class="intel-content">${report.strategic_implications || 'Strategic analysis pending'}</div>
                    </div>
                </div>
            `;

            const feed = document.getElementById('intelligenceFeed');
            feed.innerHTML = html + feed.innerHTML;

            // Limit display
            const entries = feed.querySelectorAll('.intel-entry');
            if (entries.length > 20) {
                entries[entries.length - 1].remove();
            }
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================

        function updateCanvasPreview(canvasContent) {
            // Update statistics
            const length = canvasContent.length;
            const words = canvasContent.split(/\s+/).filter(w => w.length > 0).length;
            const lines = canvasContent.split('\n').length;
            const modified = length > 0 ? new Date().toLocaleTimeString() : 'Never';
            
            document.getElementById('canvasLength').textContent = length.toLocaleString();
            document.getElementById('canvasWords').textContent = words.toLocaleString();
            document.getElementById('canvasLines').textContent = lines.toLocaleString();
            document.getElementById('canvasModified').textContent = modified;
            
            // Update content preview - show full canvas content
            let preview = '';
            if (canvasContent.length > 0) {
                // Try to extract meaningful content, avoiding HTML/script tags
                let cleanContent = canvasContent;
                
                // Remove script tags and their content
                cleanContent = cleanContent.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
                
                // Remove HTML tags but keep text
                cleanContent = cleanContent.replace(/<[^>]*>/g, ' ');
                
                // Remove multiple spaces and clean up
                cleanContent = cleanContent.replace(/\s+/g, ' ').trim();
                
                // Show full cleaned content
                preview = cleanContent;
                
                // If we still have no meaningful content, show raw content
                if (preview.trim().length === 0) {
                    preview = canvasContent;
                }
            } else {
                preview = 'No canvas content detected yet. Start typing in the Canvas to see content here.';
            }
            
            document.getElementById('canvasContentPreview').textContent = preview;
            
            // Update monitor status based on content
            const statusEl = document.getElementById('canvasMonitorStatus');
            if (length > 0) {
                statusEl.textContent = 'ACTIVE';
                statusEl.style.background = 'rgba(0, 255, 136, 0.2)';
                statusEl.style.color = '#00ff88';
            } else {
                statusEl.textContent = 'WAITING';
                statusEl.style.background = 'rgba(255, 170, 0, 0.2)';
                statusEl.style.color = '#ffaa00';
            }
        }

        function generateLocalAnalysis(model, prompt) {
            // This function should never be called - all analysis must come from Ollama
            throw new Error('Local analysis disabled. Only real Ollama AI responses are allowed.');
        }

        function hashContent(content) {
            let hash = 0;
            if (!content || content.length === 0) return hash;
            for (let i = 0; i < content.length; i++) {
                const char = content.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        function logSurveillance(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const feed = document.getElementById('surveillanceFeed');
            
            const color = type === 'error' ? '#ff6666' : 
                         type === 'change' ? '#00ff88' :
                         type === 'memory' ? '#ffaa00' : '#9999ff';
            
            const html = `<div style="margin-bottom: 4px; color: ${color};">[${timestamp}] ${message}</div>`;
            feed.innerHTML = html + feed.innerHTML;
            
            // Limit log entries
            const logs = feed.children;
            if (logs.length > 50) {
                feed.removeChild(logs[logs.length - 1]);
            }
        }

        function updateTimestamp() {
            document.getElementById('lastAnalysis').textContent = new Date().toLocaleTimeString();
        }

        function updateCouncilStatus(status) {
            document.getElementById('councilStatus').textContent = status;
            if (status === 'ANALYZING') {
                document.getElementById('canvasStatus').textContent = 'ANALYZING';
            } else {
                document.getElementById('canvasStatus').textContent = 'ACTIVE';
            }
        }

        function updateQueueStatus() {
            document.getElementById('queueStatus').textContent = surveillanceState.analysisQueue.length;
        }

        function startPolling() {
            document.getElementById('pollingStatus').textContent = `${DJINN_CONFIG.POLLING_INTERVAL / 1000}s`;
        }

        // ========================================
        // USER CONTROLS
        // ========================================

        async function triggerCouncilAnalysis() {
            console.log('Manual analysis triggered');
            
            // Force a fresh analysis
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
            
            queueAnalysis('manual_analysis', {
                content: canvasContent,
                memory: aiMemory,
                type: 'manual',
                timestamp: new Date().toISOString()
            });
            
            await processAnalysisQueue();
        }

        async function generateIntelReport() {
            console.log('Generating AI-powered intelligence report...');

            // Get current canvas data and AI memory
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
            const currentAnalysis = {
                type: 'intelligence_report_generation',
                data: {
                    content: canvasContent,
                    memory: aiMemory,
                    timestamp: new Date().toISOString()
                }
            };

            try {
                // Generate AI-powered intelligence report using current data
                const intelligenceEntry = await generateIntelligenceEntry(currentAnalysis, {
                    responses: [], // Will be populated by AI analysis
                    theme: 'intelligence_synthesis',
                    confidence: 0.8,
                    summary: 'AI-powered intelligence synthesis in progress'
                });

                // Display the AI-generated intelligence report
                displayIntelligence(intelligenceEntry);

                // Show success message
                alert(`AI-Powered Intelligence Report Generated!\n\n` +
                      `Report ID: ${intelligenceEntry.id}\n` +
                      `Severity: ${intelligenceEntry.severity}\n` +
                      `Theme: ${intelligenceEntry.theme}\n\n` +
                      `Check the Intelligence Report panel for the AI-synthesized analysis.`);

            } catch (error) {
                console.error('AI intelligence report generation failed:', error);
                alert('AI intelligence report generation failed. Check console for details.');
            }
        }

        function clearIntelligence() {
            if (confirm('Clear all intelligence data and response cache? This cannot be undone.')) {
                surveillanceState.intelligenceReports = [];
                surveillanceState.reportCount = 0;
                document.getElementById('reportCount').textContent = '0';
                document.getElementById('intelligenceFeed').innerHTML = '<div style="color: #666; font-style: italic;">Intelligence cleared</div>';
                document.getElementById('consensusFeed').innerHTML = '<div style="color: #666; font-style: italic;">Consensus cleared</div>';
                localStorage.removeItem('djinn_intelligence');
                
                // Also clear response cache to force fresh AI responses
                responseCache.clear();
                console.log('Response cache cleared for fresh AI responses');
            }
        }


        function exportIntelligence() {
            const intelligence = generateIntelligencePackage();
            const data = {
                timestamp: new Date().toISOString(),
                system: 'DJINN_COUNCIL_SHADOW_GOVERNANCE',
                intelligence: intelligence,
                rawMemory: djinnCouncilMemory
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `djinn_intelligence_${new Date().toISOString().replace(/:/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function emergencyAnalysis() {
            try {
                console.log('üö® Emergency analysis initiated');
                
                // Clear queue and force immediate analysis
                surveillanceState.analysisQueue = [];
                
                // Get all current data
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                
                queueAnalysis('emergency_analysis', {
                    content: canvasContent,
                    memory: aiMemory,
                    feeds: aiFeeds,
                    type: 'emergency',
                    timestamp: new Date().toISOString()
                });
                
                // Process immediately
                await processAnalysisQueue();
                
                // Generate report
                generateIntelReport();
            } catch (error) {
                console.error('Emergency analysis failed:', error);
                alert('Emergency analysis encountered an error. Check console for details.');
            }
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        // Load stored intelligence on startup
        function loadStoredIntelligence() {
            try {
                const stored = localStorage.getItem('djinn_intelligence');
                if (stored) {
                    const parsedReports = JSON.parse(stored);
                    
                    // Filter out any corrupted or incomplete reports
                    surveillanceState.intelligenceReports = parsedReports.filter(report => {
                        return report && typeof report === 'object' && report.timestamp;
                    });
                    
                    surveillanceState.reportCount = surveillanceState.intelligenceReports.length;
                    document.getElementById('reportCount').textContent = surveillanceState.reportCount;
                    
                    // Save cleaned data back to localStorage
                    localStorage.setItem('djinn_intelligence', JSON.stringify(surveillanceState.intelligenceReports));
                    
                    // Display recent reports
                    surveillanceState.intelligenceReports.slice(0, 5).forEach(report => {
                        displayIntelligence(report);
                    });
                }
            } catch (error) {
                console.error('Failed to load stored intelligence:', error);
                // Clear corrupted data
                localStorage.removeItem('djinn_intelligence');
                surveillanceState.intelligenceReports = [];
                surveillanceState.reportCount = 0;
                document.getElementById('reportCount').textContent = '0';
            }
        }

        // Start surveillance when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üßû‚Äç‚ôÇÔ∏è DJINN Council Shadow Governance System v1.0');
            console.log('Accessing shared localStorage at:', window.location.origin);
            
            // Clear old cached responses to force fresh analysis with improved prompts
            responseCache.clear();
            console.log('Cache cleared - improved analysis prompts enabled');

            // Force immediate fresh analysis of current canvas content
            setTimeout(() => {
                triggerCouncilAnalysis();
            }, 2000);
            
            loadStoredIntelligence();
            initializeSurveillance();
            
            // Add maximize functionality
            addMaximizeFeature();
            
            // Reset member statuses
            Object.values(councilMembers).forEach(member => {
                document.getElementById(member.status).textContent = 'READY';
            });

            // Initialize fixed header tooltip system
            initializeHeaderTooltips();

            // Initialize council memory system
            initializeDjinnCouncilMemory();
            addMemoryControls();
        });

        // ========================================
        // FIXED HEADER TOOLTIP SYSTEM
        // ========================================

        function initializeHeaderTooltips() {
            const tooltipDisplay = document.getElementById('tooltip-display');
            const tooltipElements = document.querySelectorAll('[data-tooltip]');

            tooltipElements.forEach(element => {
                element.addEventListener('mouseenter', function() {
                    const tooltipText = this.getAttribute('data-tooltip');
                    if (tooltipText) {
                        showTooltip(tooltipText);
                    }
                });

                element.addEventListener('mouseleave', function() {
                    hideTooltip();
                });
            });
        }

        function showTooltip(text) {
            const tooltipDisplay = document.getElementById('tooltip-display');
            tooltipDisplay.textContent = text;
            tooltipDisplay.classList.add('visible');
        }

        function hideTooltip() {
            const tooltipDisplay = document.getElementById('tooltip-display');
            tooltipDisplay.classList.remove('visible');
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (surveillanceState.pollingTimer) {
                clearInterval(surveillanceState.pollingTimer);
            }
        });
    </script>
</body>
</html>