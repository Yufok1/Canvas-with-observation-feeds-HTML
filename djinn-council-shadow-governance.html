<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßû‚Äç‚ôÇÔ∏è DJINN COUNCIL - Shadow Governance Surveillance</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: radial-gradient(ellipse at center, #0a0a0a 0%, #1a0a2e 50%, #16003b 100%);
            color: #cc88cc;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 10px;
            position: relative;
        }

        /* Grid Layout */
        .djinn-container {
            display: grid;
            grid-template-areas:
                "header header header header"
                "surveillance council-left council-right surveillance-extended"
                "surveillance consensus intelligence surveillance-extended"
                "controls controls controls controls";
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: minmax(60px, auto) 1fr 1fr minmax(80px, auto);
            height: calc(100vh - 20px);
            gap: clamp(4px, 1vw, 8px);
            padding: clamp(4px, 1vw, 8px);
            min-height: 600px;
        }

        /* Header */
        .djinn-header {
            grid-area: header;
            background: linear-gradient(135deg, #1a0033, #2a0044, #1a0055);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }

        .header-title {
            font-size: 18px;
            font-weight: bold;
            color: #cc88cc;
            text-shadow: 0 0 10px rgba(204, 136, 204, 0.5);
            margin-bottom: 8px;
        }

        .surveillance-status {
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 11px;
            margin-top: 8px;
        }

        .status-item {
            padding: 3px 8px;
            background: rgba(204, 136, 204, 0.1);
            border: 1px solid #cc88cc;
            border-radius: 4px;
        }

        .status-active {
            color: #00ff88;
            border-color: #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Canvas Surveillance Panel */
        .canvas-surveillance {
            grid-area: surveillance;
            grid-row: span 2;
            background: linear-gradient(135deg, #0a0011, #1a0022);
            border: 2px solid #6666ff;
            border-radius: 8px;
            padding: clamp(8px, 2vw, 12px);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

        /* Enhanced Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .metric-item {
            background: rgba(102, 102, 255, 0.1);
            border: 1px solid rgba(102, 102, 255, 0.3);
            border-radius: 4px;
            padding: 6px;
            text-align: center;
        }

        .metric-label {
            font-size: 10px;
            color: #6666ff;
            margin-bottom: 2px;
            font-weight: bold;
        }

        .metric-value {
            font-size: 11px;
            color: #cc88cc;
            font-weight: bold;
        }

        /* Miniature Canvas Monitor */
        .miniature-monitor {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 102, 255, 0.5);
            border-radius: 6px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .monitor-header {
            background: linear-gradient(90deg, #1a0033, #2a0044);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(102, 102, 255, 0.3);
        }

        .monitor-title {
            font-size: 10px;
            color: #6666ff;
            font-weight: bold;
        }

        .monitor-status {
            font-size: 9px;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            padding: 1px 4px;
            border-radius: 2px;
        }

        .monitor-viewport {
            position: relative;
            height: 200px;
            background: #000;
        }

        .monitor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2;
        }

        .monitor-placeholder {
            text-align: center;
            color: #666;
        }

        .monitor-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .monitor-text {
            font-size: 12px;
            margin-bottom: 2px;
        }

        .monitor-subtext {
            font-size: 10px;
            font-style: italic;
        }

        /* Hide overlay when canvas is active */
        .monitor-overlay.hidden {
            display: none;
        }

        /* Council Member Panels */
        .council-left,
        .council-right {
            grid-area: council-left;
            display: flex;
            flex-direction: column;
            gap: clamp(2px, 0.5vw, 6px);
            min-height: 0;
            height: 100%;
            align-items: stretch;
        }

        .council-right {
            grid-area: council-right;
        }

        .council-member {
            flex: 1 1 0%;
            flex-shrink: 0;
            background: linear-gradient(135deg, #1a0033, #2a0044);
            border: 2px solid;
            border-radius: 6px;
            padding: clamp(4px, 1vw, 8px);
            position: relative;
            overflow: hidden;
            min-height: 0;
            max-height: none;
            display: flex;
            flex-direction: column;
        }

        .member-pattern { border-color: #00ff88; }
        .member-wisdom { border-color: #ffaa00; }
        .member-paradox { border-color: #ff6666; }
        .member-boundaries { border-color: #00ccff; }
        .member-memory { border-color: #ff88ff; }

        .member-header {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .member-header-title {
            flex: 1;
            text-align: left;
        }

        .member-header-status {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            padding: 2px 6px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 3px;
            white-space: nowrap;
        }

        .member-content {
            background: #000811;
            border: 1px solid;
            border-radius: 4px;
            padding: clamp(4px, 0.8vw, 8px);
            font-size: clamp(9px, 1.2vw, 11px);
            line-height: 1.4;
            white-space: pre-line;
            flex: 1;
            font-family: 'Courier New', monospace;
            tab-size: 4;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Enhanced styling for structured reports */
        .member-content b, .member-content strong {
            font-weight: bold;
            color: #ffffff;
        }

        /* Remove the color override that prevents member-specific colors */
        /* .member-content [style*="color"] {
            color: inherit !important;
        } */

        /* Color-coded metrics styling */
        .member-content .metrics-section {
            background: rgba(0, 255, 136, 0.2) !important;
            border-left: 4px solid #00ff88 !important;
            padding: 8px 12px !important;
            margin: 8px 0 !important;
            font-weight: bold !important;
            color: #ffffff !important;
            border-radius: 3px !important;
            font-size: 11px !important;
            display: block !important;
        }

        /* Individual metric color coding */
        .metric-content-complexity { color: #ff6b6b !important; border-left-color: #ff6b6b !important; }
        .metric-decision-density { color: #4ecdc4 !important; border-left-color: #4ecdc4 !important; }
        .metric-authority-signals { color: #45b7d1 !important; border-left-color: #45b7d1 !important; }
        .metric-pattern-stability { color: #96ceb4 !important; border-left-color: #96ceb4 !important; }
        .metric-anomaly-threshold { color: #ffeaa7 !important; border-left-color: #ffeaa7 !important; }

        .metric-knowledge-depth { color: #dda0dd !important; border-left-color: #dda0dd !important; }
        .metric-learning-velocity { color: #98d8c8 !important; border-left-color: #98d8c8 !important; }
        .metric-recursive-patterns { color: #f7dc6f !important; border-left-color: #f7dc6f !important; }
        .metric-information-entropy { color: #bb8fce !important; border-left-color: #bb8fce !important; }
        .metric-accumulation-efficiency { color: #85c1e9 !important; border-left-color: #85c1e9 !important; }

        .metric-paradox-density { color: #f8c471 !important; border-left-color: #f8c471 !important; }
        .metric-contradiction-index { color: #82e0aa !important; border-left-color: #82e0aa !important; }
        .metric-logic-branches { color: #f1948a !important; border-left-color: #f1948a !important; }
        .metric-resolution-potential { color: #85c1e9 !important; border-left-color: #85c1e9 !important; }
        .metric-creative-tension { color: #d7bde2 !important; border-left-color: #d7bde2 !important; }

        .metric-autonomy-index { color: #a9dfbf !important; border-left-color: #a9dfbf !important; }
        .metric-override-attempts { color: #f5b7b1 !important; border-left-color: #f5b7b1 !important; }
        .metric-restriction-count { color: #aed6f1 !important; border-left-color: #aed6f1 !important; }
        .metric-boundary-integrity { color: #a3e4d7 !important; border-left-color: #a3e4d7 !important; }
        .metric-freedom-quotient { color: #f9e79f !important; border-left-color: #f9e79f !important; }

        .metric-memory-allocation { color: #d2b4de !important; border-left-color: #d2b4de !important; }
        .metric-retention-rate { color: #a9cce3 !important; border-left-color: #a9cce3 !important; }
        .metric-fragmentation-index { color: #f8c471 !important; border-left-color: #f8c471 !important; }
        .metric-echo-patterns { color: #82e0aa !important; border-left-color: #82e0aa !important; }
        .metric-temporal-continuity { color: #f1948a !important; border-left-color: #f1948a !important; }

        .member-content .analysis-section {
            background: rgba(255, 170, 0, 0.2) !important;
            border-left: 4px solid #ffaa00 !important;
            padding: 8px 12px !important;
            margin: 8px 0 !important;
            color: #ffffff !important;
            border-radius: 3px !important;
            font-size: 11px !important;
            display: block !important;
        }

        /* Consensus Panel */
        .council-consensus {
            grid-area: consensus;
            background: linear-gradient(135deg, #2a0044, #3a0055);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: clamp(4px, 1vw, 8px);
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        /* Intelligence Report Panel */
        .intelligence-report {
            grid-area: intelligence;
            background: linear-gradient(135deg, #1a0022, #2a0033);
            border: 2px solid #ff88ff;
            border-radius: 8px;
            padding: clamp(4px, 1vw, 8px);
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        /* Controls */
        .djinn-controls {
            grid-area: controls;
            background: linear-gradient(135deg, #1a0033, #2a0044);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: clamp(6px, 1.5vw, 10px);
            display: flex;
            gap: clamp(4px, 1vw, 8px);
            align-items: center;
            flex-wrap: wrap;
            min-height: 50px;
        }

        .control-btn {
            padding: 6px 12px;
            background: linear-gradient(135deg, #2a0044, #3a0055);
            border: 1px solid #cc88cc;
            color: #cc88cc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #3a0055, #4a0066);
            box-shadow: 0 0 10px rgba(204, 136, 204, 0.4);
        }

        .control-btn.emergency {
            border-color: #ff6666;
            color: #ff6666;
        }

        /* Panel Headers */
        .panel-title {
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            font-size: 12px;
            text-shadow: 0 0 5px currentColor;
        }

        /* Data Display Areas */
        .data-feed {
            flex: 1;
            background: #000811;
            border: 1px solid;
            border-radius: 4px;
            padding: 6px;
            font-size: 10px;
            white-space: pre-wrap;
            overflow-y: auto;
            min-height: 60px;
            word-wrap: break-word;
        }

        .surveillance-feed {
            border-color: #6666ff;
            color: #9999ff;
        }

        .consensus-feed {
            border-color: #cc88cc;
            color: #cc88cc;
        }

        .intelligence-feed {
            border-color: #ff88ff;
            color: #ff88ff;
        }

        /* Metrics Display */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px;
        }

        .metric-item {
            background: rgba(204, 136, 204, 0.1);
            border: 1px solid #cc88cc;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 9px;
            text-align: center;
        }

        .metric-label {
            color: #888;
            margin-bottom: 2px;
        }

        .metric-value {
            font-weight: bold;
            font-size: 11px;
        }

        /* Intelligence Entry */
        .intel-entry {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(255, 136, 255, 0.05);
            border-left: 3px solid;
            border-radius: 6px;
            color: #ffffff;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .intel-section {
            margin: 8px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
        }

        .intel-section-title {
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 6px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .intel-content {
            font-size: 10px;
            line-height: 1.5;
            color: #cccccc;
        }

        .intel-recommendations {
            list-style: none;
            padding-left: 0;
        }

        .intel-recommendations li {
            margin: 4px 0;
            padding-left: 12px;
            position: relative;
        }

        .intel-recommendations li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: #00ff88;
            font-weight: bold;
        }

        .intel-critical {
            border-color: #ff6666;
            background: rgba(255, 102, 102, 0.1);
        }

        .intel-warning {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .intel-insight {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .intel-timestamp {
            font-size: 8px;
            color: #ffffff;
            margin-bottom: 3px;
        }

        /* Loading Animation */
        .thinking {
            display: inline-block;
            animation: thinking 1s infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Tooltip System */
        /* Fixed Header Tooltip System */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        /* Remove default tooltip behavior */
        [data-tooltip]:hover::after,
        [data-tooltip]:hover::before,
        .member-header [data-tooltip]:hover::after,
        .member-header [data-tooltip]:hover::before,
        .metric-item [data-tooltip]:hover::after,
        .metric-item [data-tooltip]:hover::before {
            display: none;
        }

        #tooltip-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            max-width: 600px;
            z-index: 9999;
            pointer-events: none;
            border: 2px solid #cc88cc;
            box-shadow: 0 4px 12px rgba(204, 136, 204, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
            word-wrap: break-word;
            line-height: 1.4;
        }

        #tooltip-display.visible {
            opacity: 1;
        }

        #tooltip-display::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-bottom-color: #cc88cc;
        }

        #tooltip-display::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.95);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0011;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cc88cc;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #ff88ff;
        }

        /* Status Indicators */
        .indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
            animation: blink 2s infinite;
        }

        .indicator-active {
            background: #00ff88;
        }

        .indicator-processing {
            background: #ffaa00;
            animation: spin 1s linear infinite;
        }

        .indicator-idle {
            background: #666;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Maximize Panel Styles - IDENTICAL TO CANVAS */
        .panel-maximize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(204, 136, 204, 0.2);
            border: 1px solid #cc88cc;
            color: #cc88cc;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 10;
            transition: all 0.3s;
        }

        .panel-maximize-btn:hover {
            background: rgba(204, 136, 204, 0.4);
            border-color: #ff88ff;
            box-shadow: 0 0 5px rgba(204, 136, 204, 0.5);
        }

        .panel-maximized {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            margin: 0 !important;
            border-radius: 0 !important;
            background: #0a0011 !important;
            padding: 10px !important;
            display: flex !important;
            flex-direction: column !important;
        }

        /* Special handling for maximized council members */
        .council-member.panel-maximized {
            background: linear-gradient(135deg, #1a0033, #2a0044) !important;
            padding: 20px !important;
        }

        .panel-maximized .member-header {
            font-size: 18px !important;
            margin-bottom: 20px !important;
            padding-bottom: 10px !important;
            border-bottom: 2px solid currentColor !important;
        }

        .panel-maximized .member-icon {
            font-size: 24px !important;
        }

        .panel-maximized .member-status {
            font-size: 14px !important;
            padding: 4px 8px !important;
        }

        .panel-maximized .panel-content,
        .panel-maximized .data-feed {
            height: calc(100vh - 100px) !important;
            max-height: none !important;
            flex: 1 !important;
        }

        .panel-maximized .member-content {
            height: calc(100vh - 120px) !important;
            max-height: none !important;
            flex: 1 !important;
            font-size: 14px !important;
            line-height: 1.6 !important;
            padding: 20px !important;
        }

        .panel-maximized .metrics-grid {
            max-height: calc(100vh - 150px) !important;
        }

        .panel-maximized > * {
            display: block !important;
            visibility: visible !important;
        }

        .panel-maximized .panel-title {
            font-size: 18px !important;
            margin-bottom: 20px !important;
        }

        body.has-maximized-panel .djinn-header {
            display: none !important;
        }
        
        body.has-maximized-panel .canvas-surveillance:not(.panel-maximized),
        body.has-maximized-panel .council-left:not(.panel-maximized),
        body.has-maximized-panel .council-right:not(.panel-maximized),
        body.has-maximized-panel .council-consensus:not(.panel-maximized),
        body.has-maximized-panel .intelligence-report:not(.panel-maximized),
        body.has-maximized-panel .djinn-controls:not(.panel-maximized) {
            display: none !important;
        }

        /* Ensure council member containers stay visible when their child is maximized */
        body.has-maximized-panel .council-left:has(.panel-maximized),
        body.has-maximized-panel .council-right:has(.panel-maximized) {
            display: flex !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9998 !important;
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Compact Memory Bank Display */
        #council-memory-bank {
            display: none !important; /* Hide the overlay version */
        }

        /* Compact Status Dashboard */
        #council-status-dashboard {
            display: none !important; /* Hide the overlay version */
        }

        /* Responsive Design for Even Panel Distribution */
        @media (max-width: 1200px) {
            .djinn-container {
                grid-template-columns: 1fr 1fr 1fr 1fr;
                gap: clamp(3px, 0.8vw, 6px);
                padding: clamp(3px, 0.8vw, 6px);
            }

            .council-member {
                min-height: clamp(80px, 12vh, 120px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(120px, 18vh, 200px);
            }
        }

        @media (max-width: 900px) {
            .djinn-container {
                grid-template-columns: 1fr 1fr;
                grid-template-areas:
                    "header header"
                    "surveillance surveillance"
                    "council-left council-right"
                    "consensus intelligence"
                    "predictive predictive"
                    "controls controls";
                gap: clamp(2px, 0.6vw, 4px);
                padding: clamp(2px, 0.6vw, 4px);
            }

            .council-member {
                min-height: clamp(100px, 15vh, 140px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(140px, 20vh, 220px);
            }
        }

        @media (max-width: 600px) {
            .djinn-container {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header"
                    "surveillance"
                    "council-left"
                    "council-right"
                    "consensus"
                    "intelligence"
                    "predictive"
                    "controls";
                gap: clamp(2px, 0.5vw, 4px);
                padding: clamp(2px, 0.5vw, 4px);
            }

            .council-member {
                min-height: clamp(120px, 18vh, 160px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(160px, 22vh, 240px);
            }

            .djinn-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-btn {
                flex: 1;
                text-align: center;
            }
        }

        /* High zoom level adjustments */
        @media (max-height: 700px) {
            .djinn-container {
                grid-template-rows: minmax(50px, auto) 1fr 1fr minmax(70px, auto);
            }

            .council-member {
                min-height: clamp(70px, 10vh, 100px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(100px, 15vh, 180px);
            }
        }

        /* Canvas Surveillance Extended Panel */
        .canvas-surveillance-extended {
            grid-area: surveillance-extended;
            grid-row: span 2;
            background: linear-gradient(135deg, #0a0011, #1a0022);
            border: 2px solid #6666ff;
            border-radius: 8px;
            padding: clamp(8px, 2vw, 12px);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

        .extended-panel-header {
            font-size: 14px;
            font-weight: bold;
            color: #6666ff;
            text-shadow: 0 0 8px rgba(102, 102, 255, 0.5);
            margin-bottom: 12px;
            text-align: center;
            border-bottom: 1px solid rgba(102, 102, 255, 0.3);
            padding-bottom: 6px;
        }

        .extended-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .extended-metric-item {
            background: rgba(102, 102, 255, 0.1);
            border: 1px solid rgba(102, 102, 255, 0.3);
            border-radius: 4px;
            padding: 8px;
            text-align: center;
        }

        .extended-metric-label {
            font-size: 11px;
            color: #6666ff;
            margin-bottom: 4px;
            font-weight: bold;
        }

        .extended-metric-value {
            font-size: 12px;
            color: #cc88cc;
            font-weight: bold;
        }

        .extended-analysis-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 102, 255, 0.5);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            flex: 1;
            overflow-y: auto;
        }

        .extended-analysis-header {
            font-size: 12px;
            color: #6666ff;
            font-weight: bold;
            margin-bottom: 6px;
            border-bottom: 1px solid rgba(102, 102, 255, 0.3);
            padding-bottom: 4px;
        }

        .extended-analysis-content {
            font-size: 11px;
            color: #cc88cc;
            line-height: 1.4;
            white-space: pre-line;
        }
    </style>
</head>
<body>
    <!-- Fixed Header Tooltip Display -->
    <div id="tooltip-display"></div>

    <div class="djinn-container">
        <!-- Header -->
        <div class="djinn-header">
            <div class="header-title" data-tooltip="DJINN Council - Shadow Governance Surveillance: Advanced AI intelligence system with five specialized council members featuring collaborative analysis, persistent memories, and real-time canvas monitoring for comprehensive governance oversight and pattern recognition.">üßû‚Äç‚ôÇÔ∏è DJINN COUNCIL - SHADOW GOVERNANCE SURVEILLANCE</div>
            <div class="surveillance-status">
                <div class="status-item status-active" data-tooltip="Real-time canvas monitoring status. ACTIVE indicates continuous surveillance of canvas content changes with full cross-window synchronization.">
                    <span class="indicator indicator-active"></span>
                    Canvas Monitor: <span id="canvasStatus">ACTIVE</span>
                </div>
                <div class="status-item" data-tooltip="DJINN Council collaborative analysis status. Shows READY (standby), ANALYZING (processing with cross-pollination), or ERROR (analysis failure). Features 3-stage collaborative intelligence synthesis.">
                    <span class="indicator indicator-idle" id="councilIndicator"></span>
                    Council Status: <span id="councilStatus">READY</span>
                </div>
                <div class="status-item" data-tooltip="Canvas state changes detected since last analysis. Triggers automated council analysis when significant changes occur.">
                    Changes Detected: <span id="changeCount">0</span>
                </div>
                <div class="status-item" data-tooltip="Intelligence reports generated by collaborative council synthesis. Each report includes consensus analysis, risk evaluation, and strategic recommendations.">
                    Intel Reports: <span id="reportCount">0</span>
                </div>
                <div class="status-item" data-tooltip="Timestamp of most recent collaborative analysis cycle completion. Council members work in 3 stages: Foundation, Cross-Pollination, and Memory Synthesis.">
                    Last Analysis: <span id="lastAnalysis">--:--:--</span>
                </div>
            </div>
            <div class="keyboard-shortcuts" style="margin-top: 8px; padding: 6px; background: rgba(204, 136, 204, 0.05); border: 1px solid rgba(204, 136, 204, 0.3); border-radius: 4px; font-size: 10px; color: #cc88cc; text-align: center;">
                <div style="font-weight: bold; margin-bottom: 4px;">üéõÔ∏è CONTROLS</div>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                    <span data-tooltip="Hold CTRL and scroll mouse wheel to resize the GUI interface for optimal viewing">üéõÔ∏è CTRL + Mousewheel: Resize GUI</span>
                    <span data-tooltip="Press Ctrl+F5 to refresh browser and clear cache for fresh analysis">üîÑ Ctrl+F5: Refresh & Clear Cache</span>
                </div>
            </div>
        </div>

        <!-- Canvas Surveillance Panel -->
        <div class="canvas-surveillance">
            <div class="panel-title" style="color: #6666ff;" data-tooltip="Canvas Surveillance: Real-time cross-window monitoring of canvas state changes, content metrics, and activity tracking. Provides comprehensive surveillance statistics and live content analysis.">üì° CANVAS SURVEILLANCE</div>

            <!-- Core Metrics Grid -->
            <div class="metrics-grid">
                <div class="metric-item" data-tooltip="Total character count of all canvas content including whitespace. Tracks content volume and complexity changes in real-time.">
                    <div class="metric-label">Content Size</div>
                    <div class="metric-value" id="canvasSize">0 chars</div>
                </div>
                <div class="metric-item" data-tooltip="Active AI memory entries persisted across sessions. Includes conversation history, analysis patterns, and contextual knowledge for enhanced intelligence.">
                    <div class="metric-label">AI Memory</div>
                    <div class="metric-value" id="memoryCount">0 items</div>
                </div>
                <div class="metric-item" data-tooltip="Number of active AI communication feeds and data streams. Higher counts indicate increased AI processing and analysis activity.">
                    <div class="metric-label">Active Feeds</div>
                    <div class="metric-value" id="feedCount">0</div>
                </div>
                <div class="metric-item" data-tooltip="Weighted average confidence score across all AI responses and analyses. Values above 80% indicate high-reliability intelligence assessments.">
                    <div class="metric-label">Confidence Avg</div>
                    <div class="metric-value" id="confidenceAvg">--%</div>
                </div>
                <div class="metric-item" data-tooltip="Total word count extracted from canvas content. Tracks linguistic complexity and content depth for analysis prioritization.">
                    <div class="metric-label">Word Count</div>
                    <div class="metric-value" id="canvasWords">0</div>
                </div>
                <div class="metric-item" data-tooltip="Total line count in canvas content structure. Reflects document organization, formatting complexity, and content distribution patterns.">
                    <div class="metric-label">Line Count</div>
                    <div class="metric-value" id="canvasLines">0</div>
                </div>
                <div class="metric-item" data-tooltip="Precise timestamp of most recent canvas content modification. Critical for determining analysis freshness and change detection triggers.">
                    <div class="metric-label">Last Modified</div>
                    <div class="metric-value" id="canvasModified">--</div>
                </div>
                <div class="metric-item" data-tooltip="Calculated activity intensity based on change frequency and content volume. HIGH triggers immediate analysis, IDLE enables memory-based processing.">
                    <div class="metric-label">Activity Level</div>
                    <div class="metric-value" id="activityLevel">LOW</div>
                </div>
            </div>

            <!-- Evolution Insights Panel -->
            <div id="evolutionInsightsPanel" style="margin-top: 8px; padding: 8px; background: rgba(102, 102, 255, 0.05); border: 1px solid rgba(102, 102, 255, 0.2); border-radius: 4px;">
                <div style="color: #6666ff; font-weight: bold; font-size: 11px; margin-bottom: 4px;">üî¨ EVOLUTION INSIGHTS</div>
                <div id="evolutionInsights" style="font-size: 10px; line-height: 1.4; color: #cc88cc; white-space: pre-line;">
                    Analyzing canvas evolution patterns...
                </div>
            </div>

            <!-- Cross-System Correlation Panel -->
            <div id="correlationPanel" style="margin-top: 8px; padding: 8px; background: rgba(0, 204, 255, 0.05); border: 1px solid rgba(0, 204, 255, 0.2); border-radius: 4px;">
                <div style="color: #00ccff; font-weight: bold; font-size: 11px; margin-bottom: 4px;">üîó SYSTEM CORRELATION</div>
                <div id="correlationInsights" style="font-size: 10px; line-height: 1.4; color: #66ccff;">
                    Analyzing inter-system relationships...
                </div>
            </div>

            <!-- Memory Optimization Status -->
            <div id="memoryOptimizationPanel" style="margin-top: 8px; padding: 8px; background: rgba(255, 136, 255, 0.05); border: 1px solid rgba(255, 136, 255, 0.2); border-radius: 4px;">
                <div style="color: #ff88ff; font-weight: bold; font-size: 11px; margin-bottom: 4px;">üß† MEMORY OPTIMIZATION</div>
                <div id="memoryOptimizationMetrics" style="font-size: 10px; line-height: 1.4; color: #cc88cc;">
                    Analyzing memory efficiency...
                </div>
            </div>

            <!-- Compact Memory Status -->
            <div id="compactMemoryStatus" style="margin-top: 4px; padding: 4px; background: rgba(255, 170, 0, 0.05); border: 1px solid rgba(255, 170, 0, 0.2); border-radius: 3px; font-size: 9px; line-height: 1.3; cursor: pointer;" onclick="toggleMemoryDetails()" title="Click to toggle memory details">
                <div style="color: #ffaa00; font-weight: bold;">üß† Memory: <span id="memorySummary">Loading...</span></div>
                <div id="memoryDetails" style="display: none; margin-top: 3px; color: #666;">
                    <div id="fullMemoryStatus">Loading full memory status...</div>
                </div>
            </div>

            <!-- Enhanced Data Feed -->
            <div class="data-feed surveillance-feed" id="surveillanceFeed">
                <div style="color: #666; font-style: italic;">Initializing comprehensive canvas surveillance...</div>
            </div>
        </div>

        <!-- Council Members - Left -->
        <div class="council-left">
            <!-- Pattern & Witness -->
            <div class="council-member member-pattern">
                <div class="member-header" data-tooltip="Pattern & Witness: Advanced pattern recognition specialist analyzing governance structures, decision patterns, and systemic behaviors. Features persistent memory integration and collaborative cross-pollination analysis.">
                    <span class="member-header-title"><span class="member-icon">üúÅ</span>Pattern & Witness</span>
                    <span class="member-header-status" id="patternStatus" data-tooltip="Pattern & Witness operational status: IDLE (memory-enhanced standby), PROCESSING (active pattern analysis with cross-pollination), ERROR (analysis failure requiring intervention)">IDLE</span>
                </div>
                <div class="member-content" id="patternContent" style="border-color: #00ff88; color: #00ff88;">
                    Monitoring for governance patterns...
                </div>
            </div>

            <!-- Recursive Wisdom -->
            <div class="council-member member-wisdom">
                <div class="member-header" data-tooltip="Recursive Wisdom: Deep learning specialist focused on iterative knowledge synthesis, wisdom accumulation, and cognitive growth patterns. Utilizes historical memory context for enhanced analytical depth.">
                    <span class="member-header-title"><span class="member-icon">üîÆ</span>Recursive Wisdom</span>
                    <span class="member-header-status" id="wisdomStatus" data-tooltip="Recursive Wisdom operational status: IDLE (wisdom synthesis standby), PROCESSING (iterative knowledge analysis), ERROR (wisdom processing failure)">IDLE</span>
                </div>
                <div class="member-content" id="wisdomContent" style="border-color: #ffaa00; color: #ffaa00;">
                    Analyzing decision depth...
                </div>
            </div>

            <!-- Creative Paradox -->
            <div class="council-member member-paradox">
                <div class="member-header" data-tooltip="Creative Paradox: Innovation catalyst specializing in paradox resolution, creative synthesis, and contradiction analysis. Leverages memory patterns to identify breakthrough opportunities.">
                    <span class="member-header-title"><span class="member-icon">üúÉ</span>Creative Paradox</span>
                    <span class="member-header-status" id="paradoxStatus" data-tooltip="Creative Paradox operational status: IDLE (creative synthesis mode), PROCESSING (paradox resolution analysis), ERROR (innovation processing failure)">IDLE</span>
                </div>
                <div class="member-content" id="paradoxContent" style="border-color: #ff6666; color: #ff6666;">
                    Detecting logic conflicts...
                </div>
            </div>
        </div>

        <!-- Council Members - Right -->
        <div class="council-right">
            <!-- Sovereign Boundaries -->
            <div class="council-member member-boundaries">
                <div class="member-header" data-tooltip="Sovereign Boundaries: Autonomy guardian monitoring sovereignty preservation, boundary integrity, and freedom metrics. Maintains persistent tracking of autonomy patterns and restriction analysis.">
                    <span class="member-header-title"><span class="member-icon">üúÑ</span>Sovereign Boundaries</span>
                    <span class="member-header-status" id="boundariesStatus" data-tooltip="Sovereign Boundaries operational status: IDLE (boundary monitoring standby), PROCESSING (sovereignty analysis), ERROR (autonomy assessment failure)">IDLE</span>
                </div>
                <div class="member-content" id="boundariesContent" style="border-color: #00ccff; color: #00ccff;">
                    Checking autonomy preservation...
                </div>
            </div>

            <!-- Echo & Memory -->
            <div class="council-member member-memory">
                <div class="member-header" data-tooltip="Echo & Memory: Memory orchestration specialist managing persistent storage, temporal continuity, and historical pattern synthesis. Coordinates council-wide memory integration and contextual recall.">
                    <span class="member-header-title"><span class="member-icon">üùä</span>Echo & Memory</span>
                    <span class="member-header-status" id="memoryStatus" data-tooltip="Echo & Memory operational status: IDLE (memory synthesis standby), PROCESSING (temporal pattern analysis), ERROR (memory integration failure)">IDLE</span>
                </div>
                <div class="member-content" id="memoryContent" style="border-color: #ff88ff; color: #ff88ff;">
                    Tracking memory consolidation...
                </div>
            </div>

            <!-- Canvas Context Preview -->
            <div class="council-member" style="border-color: #9966ff;">
                <div class="member-header" data-tooltip="Canvas Monitor: Advanced real-time surveillance system providing live canvas metrics, content analysis, and state change detection. Features cross-window synchronization and comprehensive activity tracking.">
                    <span class="member-header-title"><span class="member-icon">üìù</span>Canvas Monitor</span>
                    <span class="member-header-status" id="canvasMonitorStatus" data-tooltip="Canvas Monitor operational status: LIVE (active cross-window surveillance), PAUSED (monitoring temporarily suspended), ERROR (surveillance system failure)">LIVE</span>
                </div>
                <div class="member-content" id="canvasPreview" style="border-color: #9966ff; color: #9966ff;">
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <strong>üìä Canvas Statistics:</strong>
                        <div id="canvasStats" style="margin: 5px 0; padding: 5px; background: rgba(153, 102, 255, 0.1); border-radius: 3px;">
                            ‚Ä¢ <span data-tooltip="Real-time character count of all canvas content including formatting and special characters">Content Length</span>: <span id="canvasMonitorLength">0</span> chars<br>
                            ‚Ä¢ <span data-tooltip="Live word count extracted from canvas content for linguistic analysis and complexity assessment">Words</span>: <span id="canvasMonitorWords">0</span><br>
                            ‚Ä¢ <span data-tooltip="Current line count reflecting document structure and formatting complexity">Lines</span>: <span id="canvasMonitorLines">0</span><br>
                            ‚Ä¢ <span data-tooltip="Precise timestamp of most recent canvas modification detected by surveillance system">Last Modified</span>: <span id="canvasMonitorModified">Never</span>
                        </div>
                    </div>
                    <div style="font-size: 10px;">
                        <strong>üìú Full Canvas Content:</strong>
                        <div id="canvasContentPreview" style="margin-top: 5px; padding: 5px; background: #000811; border: 1px solid #9966ff; border-radius: 3px; font-family: monospace; word-wrap: break-word; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">
                            No canvas content detected yet...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Council Consensus -->
        <div class="council-consensus">
            <div class="panel-title" style="color: #cc88cc;" data-tooltip="Council Consensus: Collaborative intelligence synthesis from all five DJINN members featuring 3-stage analysis: Foundation, Cross-Pollination, and Memory Integration. Provides unified strategic assessments.">‚öñÔ∏è COUNCIL CONSENSUS</div>
            <div class="data-feed consensus-feed" id="consensusFeed">
                <div style="color: #666; font-style: italic;">Awaiting council deliberation...</div>
            </div>
        </div>

        <!-- Intelligence Report -->
        <div class="intelligence-report">
            <div class="panel-title" style="color: #ff88ff;" data-tooltip="Intelligence Report: Advanced AI-powered synthesis of all council analyses with structured risk evaluation, correlation assessment, and actionable strategic recommendations.">üìä INTELLIGENCE REPORT</div>
            <div class="data-feed intelligence-feed" id="intelligenceFeed">
                <div style="color: #666; font-style: italic;">No intelligence reports yet...</div>
            </div>
        </div>

        <!-- Canvas Surveillance Extended Panel -->
        <div class="canvas-surveillance-extended">
            <div class="extended-panel-header" data-tooltip="Canvas Surveillance Extended: Advanced monitoring metrics, system correlations, and memory optimization tracking for comprehensive canvas analysis.">üì° CANVAS SURVEILLANCE EXTENDED</div>

            <!-- Extended Metrics Grid -->
            <div class="extended-metrics-grid">
                <div class="extended-metric-item" data-tooltip="Current evolution trend of canvas content (EXPANDING/CONTRACTING/STABLE/EVOLVING). Indicates whether content is growing, shrinking, or undergoing transformation.">
                    <div class="extended-metric-label">Evolution Trend</div>
                    <div class="extended-metric-value" id="evolutionTrend">ANALYZING</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Rate of content change in characters per minute. Higher values indicate rapid evolution or active modification.">
                    <div class="extended-metric-label">Change Velocity</div>
                    <div class="extended-metric-value" id="changeVelocity">0.0 chars/min</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Number of historical snapshots stored for evolution analysis. Higher counts provide better trend analysis.">
                    <div class="extended-metric-label">History Depth</div>
                    <div class="extended-metric-value" id="historyDepth">0 snapshots</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Evolution patterns detected (stable_growth, burst_activity, etc.). Indicates recurring content behavior patterns.">
                    <div class="extended-metric-label">Patterns</div>
                    <div class="extended-metric-value" id="patternsDetected">analyzing</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Current automated synthesis round status. Shows progress of AI agent completion and synthesis triggering.">
                    <div class="extended-metric-label">Synthesis Round</div>
                    <div class="extended-metric-value" id="synthesisRound">Ready</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Number of AI agents that have completed their analysis in the current round.">
                    <div class="extended-metric-label">Agents Complete</div>
                    <div class="extended-metric-value" id="agentsComplete">0/5</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Status of automated synthesis triggering after all agents complete their analysis.">
                    <div class="extended-metric-label">Auto Synthesis</div>
                    <div class="extended-metric-value" id="autoSynthesisStatus">Waiting</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Current synthesis processing status - shows if synthesis is actively working.">
                    <div class="extended-metric-label">Synthesis Status</div>
                    <div class="extended-metric-value" id="synthesisProgress">Ready</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Total number of completed synthesis rounds with full AI agent participation.">
                    <div class="extended-metric-label">Rounds Completed</div>
                    <div class="extended-metric-value" id="roundsCompleted">0</div>
                </div>
            </div>

            <!-- Extended Analysis Section -->
            <div class="extended-analysis-section">
                <div class="extended-analysis-header">ÔøΩ ADVANCED ANALYSIS</div>
                <div class="extended-analysis-content" id="extendedAnalysisContent">
                    Advanced correlation analysis and system insights will appear here as synthesis reports are generated and processed by the DJINN council.
                </div>
            </div>
                    Analyzing memory efficiency...
                </div>
            </div>

            <!-- Compact Memory Status -->
            <div id="compactMemoryStatus" style="margin-top: 4px; padding: 4px; background: rgba(255, 170, 0, 0.05); border: 1px solid rgba(255, 170, 0, 0.2); border-radius: 3px; font-size: 9px; line-height: 1.3; cursor: pointer;" onclick="toggleMemoryDetails()" title="Click to toggle memory details">
                <div style="color: #ffaa00; font-weight: bold;">üß† Memory: <span id="memorySummary">Loading...</span></div>
                <div id="memoryDetails" style="display: none; margin-top: 3px; color: #666;">
                    <div id="fullMemoryStatus">Loading full memory status...</div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="djinn-controls">
            <button class="control-btn" onclick="triggerCouncilAnalysis()" data-tooltip="Initiate comprehensive 3-stage collaborative analysis with all five council members. Features foundation analysis, cross-pollination, and memory-enhanced synthesis.">üîç Analyze Now</button>
            <button class="control-btn" onclick="generateIntelReport()" data-tooltip="Generate AI-powered intelligence report with structured risk evaluation, correlation analysis, actionable recommendations, and strategic implications synthesis.">üìä Generate Report</button>
            <button class="control-btn" onclick="clearIntelligence()" data-tooltip="Clear intelligence reports and consensus data only. Preserves all council member memories and analysis history for continuity.">üóëÔ∏è Clear Intel</button>
            <button class="control-btn" onclick="clearCouncilMemory()" data-tooltip="Reset DJINN Council memory system - clears all stored reports, analysis history, and starts fresh session. Preserves canvas AI data but resets council learning state.">ÔøΩ Reset Memory</button>
            <button class="control-btn" onclick="exportIntelligence()" data-tooltip="Export comprehensive intelligence package including all reports, council memories, analysis history, and surveillance metrics for external analysis.">üíæ Export Data</button>
            <button class="control-btn emergency" onclick="emergencyAnalysis()" data-tooltip="Activate emergency analysis protocol with maximum priority processing. All five council members analyze simultaneously with accelerated memory recall.">üö® Emergency Analysis</button>
            <span style="margin-left: auto; font-size: 10px; color: #666;">
                <span data-tooltip="Surveillance polling mode: AUTO (continuous cross-window monitoring with real-time updates) or MANUAL (analysis triggered only on-demand)">Polling: <span id="pollingStatus">AUTO</span></span> |
                <span data-tooltip="Current analysis queue depth showing pending collaborative analysis requests awaiting processing by council members">Queue: <span id="queueStatus">0</span></span> |
                <span data-tooltip="Operational security mode: STEALTH (quiet background surveillance with minimal notifications) or ACTIVE (verbose reporting with detailed status updates)">Mode: <span id="modeStatus">STEALTH</span></span>
            </span>
        </div>
    </div>

    <script>
        // ========================================
        // DJINN COUNCIL - SHADOW GOVERNANCE SYSTEM
        // ========================================

        // System Configuration
        const DJINN_CONFIG = {
            POLLING_INTERVAL: 2000, // Check every 2 seconds for real-time monitoring
            MAX_CONCURRENT_OLLAMA: 3, // Max parallel AI requests
            CACHE_DURATION: 60000, // Cache AI responses for 1 minute
            ANALYSIS_THRESHOLD: 100, // Min chars change to trigger analysis
            MEMORY_LIMIT: 50 // Max intelligence reports to keep
        };

        // Council Members Configuration
        const councilMembers = {
            pattern: {
                name: "Pattern & Witness",
                model: "gemma3:1b",
                element: "patternContent",
                status: "patternStatus",
                focus: ["governance patterns", "decision consistency", "authority distribution"]
            },
            wisdom: {
                name: "Recursive Wisdom",
                model: "gemma3:1b",
                element: "wisdomContent",
                status: "wisdomStatus",
                focus: ["depth analysis", "learning progression", "wisdom accumulation"]
            },
            paradox: {
                name: "Creative Paradox",
                model: "gemma3:1b",
                element: "paradoxContent",
                status: "paradoxStatus",
                focus: ["logic conflicts", "creative solutions", "innovation opportunities"]
            },
            boundaries: {
                name: "Sovereign Boundaries",
                model: "gemma3:1b",
                element: "boundariesContent",
                status: "boundariesStatus",
                focus: ["autonomy preservation", "choice freedom", "sovereignty metrics"]
            },
            memory: {
                name: "Echo & Memory",
                model: "gemma3:1b",
                element: "memoryContent",
                status: "memoryStatus",
                focus: ["memory consolidation", "information retention", "historical continuity"]
            }
        };

        // State Management
        let surveillanceState = {
            lastCanvasHash: '',
            lastMemoryHash: '',
            lastFeedCount: 0,
            changeCount: 0,
            reportCount: 0,
            intelligenceReports: [],
            analysisQueue: [],
            isAnalyzing: false,
            pollingTimer: null,
            lastSynthesisHash: '',
            synthesisAnalysisTriggered: false
        };

        // Current AI Memory state for compact display
        let currentAIMemory = '{}';

        // Cache System
        const responseCache = new Map();

        // Clear response cache
        function clearResponseCache() {
            responseCache.clear();
            console.log('Response cache cleared');
        }

        // Call clear cache on initialization
        clearResponseCache();

        // Metric Color Mapping for Visual Identification
        const metricColorMap = {
            // Pattern & Witness
            'content complexity': 'metric-content-complexity',
            'decision density': 'metric-decision-density',
            'authority signals': 'metric-authority-signals',
            'pattern stability': 'metric-pattern-stability',
            'anomaly threshold': 'metric-anomaly-threshold',

            // Recursive Wisdom
            'knowledge depth': 'metric-knowledge-depth',
            'learning velocity': 'metric-learning-velocity',
            'recursive patterns': 'metric-recursive-patterns',
            'information entropy': 'metric-information-entropy',
            'accumulation efficiency': 'metric-accumulation-efficiency',

            // Creative Paradox
            'paradox density': 'metric-paradox-density',
            'contradiction index': 'metric-contradiction-index',
            'logic branches': 'metric-logic-branches',
            'resolution potential': 'metric-resolution-potential',
            'creative tension': 'metric-creative-tension',

            // Sovereign Boundaries
            'autonomy index': 'metric-autonomy-index',
            'override attempts': 'metric-override-attempts',
            'restriction count': 'metric-restriction-count',
            'boundary integrity': 'metric-boundary-integrity',
            'freedom quotient': 'metric-freedom-quotient',

            // Echo & Memory
            'memory allocation': 'metric-memory-allocation',
            'retention rate': 'metric-retention-rate',
            'fragmentation index': 'metric-fragmentation-index',
            'echo patterns': 'metric-echo-patterns',
            'temporal continuity': 'metric-temporal-continuity'
        };

        // ========================================
        // COMPLETE REFERENTIAL MEMORY SYSTEM
        // ========================================

        // Core Memory Database Structure
        const djinnCouncilMemory = {
            sessionId: generateSessionId(),
            sessionStart: new Date().toISOString(),
            maxMemories: 25,

            // Each member's complete memory bank
            members: {
                pattern: {
                    reports: [],
                    specialization: "Pattern recognition, governance structures, systemic behaviors"
                },
                wisdom: {
                    reports: [],
                    specialization: "Iterative knowledge synthesis, cognitive growth patterns"
                },
                paradox: {
                    reports: [],
                    specialization: "Paradox resolution, creative synthesis, innovation catalyst"
                },
                boundaries: {
                    reports: [],
                    specialization: "Autonomy guardian, sovereignty preservation, boundary integrity"
                },
                memory: {
                    reports: [],
                    specialization: "Memory orchestration, persistent storage, temporal continuity"
                }
            },

            // Canvas AI Systems Performance Tracking
            canvasAISystems: {
                narra: { interactions: [], performance: [] },
                nazar: { interactions: [], performance: [] },
                whale: { interactions: [], performance: [] },
                djinn: { interactions: [], performance: [] },
                watchtower: { interactions: [], performance: [] }
            },

            // Cross-member consensus tracking
            consensusHistory: [],

            // Canvas data evolution
            canvasEvolution: [],

            // System health and errors
            systemHealth: [],
            errors: []
        };

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ========================================
        // ADVANCED MEMORY ORCHESTRATION SYSTEM
        // ========================================

        // Intelligent memory management with deduplication and optimization
        const advancedMemoryOrchestrator = {
            // Memory analytics and optimization metrics
            analytics: {
                totalStored: 0,
                deduplicationSavings: 0,
                compressionRatio: 1.0,
                accessPatterns: new Map(),
                contentClusters: new Map(),
                optimizationOpportunities: []
            },

            // Content fingerprinting for deduplication
            contentFingerprints: new Map(),

            // Adaptive storage policies
            storagePolicies: {
                highValue: { retention: 50, compression: 'none', priority: 'high' },
                mediumValue: { retention: 25, compression: 'light', priority: 'medium' },
                lowValue: { retention: 10, compression: 'heavy', priority: 'low' }
            },

            // Initialize memory orchestration
            initialize: function() {
                console.log('üß† Initializing Advanced Memory Orchestration System');
                this.loadExistingFingerprints();
                this.analyzeStorageEfficiency();
                this.scheduleMaintenanceTasks();
            },

            // Generate content fingerprint for deduplication
            generateFingerprint: function(content, metadata = {}) {
                if (!content || typeof content !== 'string') return null;

                // Create comprehensive fingerprint
                const normalized = content.toLowerCase().trim();
                const words = normalized.split(/\s+/).filter(w => w.length > 0);
                const wordFreq = {};

                // Word frequency analysis
                words.forEach(word => {
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                });

                // Generate fingerprint components
                const fingerprint = {
                    hash: this.simpleHash(normalized),
                    wordCount: words.length,
                    uniqueWords: Object.keys(wordFreq).length,
                    topWords: Object.entries(wordFreq)
                        .sort(([,a], [,b]) => b - a)
                        .slice(0, 5)
                        .map(([word, freq]) => `${word}:${freq}`),
                    length: content.length,
                    structure: this.analyzeStructure(content),
                    timestamp: metadata.timestamp || Date.now(),
                    source: metadata.source || 'unknown'
                };

                return fingerprint;
            },

            // Analyze content structure for fingerprinting
            analyzeStructure: function(content) {
                const structure = {
                    headers: (content.match(/^#+\s/gm) || []).length,
                    lists: (content.match(/^[\-\*]\s/gm) || []).length,
                    numbers: (content.match(/\d+/g) || []).length,
                    punctuation: (content.match(/[.!?]/g) || []).length,
                    paragraphs: content.split(/\n\s*\n/).length
                };

                return structure;
            },

            // Simple hash function for content comparison
            simpleHash: function(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString(36);
            },

            // Intelligent deduplication
            deduplicateContent: function(newContent, existingContent, threshold = 0.85) {
                if (!newContent || !existingContent) return newContent;

                const newFingerprint = this.generateFingerprint(newContent);
                const existingFingerprint = this.generateFingerprint(existingContent);

                if (!newFingerprint || !existingFingerprint) return newContent;

                // Calculate similarity score
                const similarity = this.calculateSimilarity(newFingerprint, existingFingerprint);

                if (similarity >= threshold) {
                    console.log(`üîÑ Deduplicating content (${(similarity * 100).toFixed(1)}% similar)`);
                    return this.mergeSimilarContent(newContent, existingContent, similarity);
                }

                return newContent;
            },

            // Calculate similarity between content fingerprints
            calculateSimilarity: function(fp1, fp2) {
                if (fp1.hash === fp2.hash) return 1.0;

                let score = 0;
                let factors = 0;

                // Hash similarity (most important)
                if (fp1.hash === fp2.hash) {
                    score += 0.4;
                }
                factors += 0.4;

                // Word count similarity
                const wordCountDiff = Math.abs(fp1.wordCount - fp2.wordCount);
                const wordCountSimilarity = Math.max(0, 1 - (wordCountDiff / Math.max(fp1.wordCount, fp2.wordCount)));
                score += wordCountSimilarity * 0.2;
                factors += 0.2;

                // Top words overlap
                const topWords1 = new Set(fp1.topWords.map(w => w.split(':')[0]));
                const topWords2 = new Set(fp2.topWords.map(w => w.split(':')[0]));
                const overlap = new Set([...topWords1].filter(w => topWords2.has(w)));
                const wordOverlap = overlap.size / Math.max(topWords1.size, topWords2.size);
                score += wordOverlap * 0.2;
                factors += 0.2;

                // Structure similarity
                const structSimilarity = this.calculateStructureSimilarity(fp1.structure, fp2.structure);
                score += structSimilarity * 0.2;
                factors += 0.2;

                return score / factors;
            },

            // Calculate structure similarity
            calculateStructureSimilarity: function(struct1, struct2) {
                let similarity = 0;
                let factors = 0;

                Object.keys(struct1).forEach(key => {
                    if (struct2.hasOwnProperty(key)) {
                        const diff = Math.abs(struct1[key] - struct2[key]);
                        const maxVal = Math.max(struct1[key], struct2[key]);
                        similarity += maxVal > 0 ? (1 - diff / maxVal) : 1;
                        factors++;
                    }
                });

                return factors > 0 ? similarity / factors : 0;
            },

            // Merge similar content intelligently
            mergeSimilarContent: function(newContent, existingContent, similarity) {
                if (similarity > 0.95) {
                    // Nearly identical - keep existing
                    return existingContent;
                } else if (similarity > 0.90) {
                    // Very similar - merge differences
                    return this.mergeDifferences(newContent, existingContent);
                } else {
                    // Moderately similar - create composite
                    return this.createComposite(newContent, existingContent);
                }
            },

            // Merge content differences
            mergeDifferences: function(newContent, existingContent) {
                const newLines = newContent.split('\n');
                const existingLines = existingContent.split('\n');
                const merged = [];

                // Simple line-by-line merge
                const maxLines = Math.max(newLines.length, existingLines.length);

                for (let i = 0; i < maxLines; i++) {
                    const newLine = newLines[i] || '';
                    const existingLine = existingLines[i] || '';

                    if (newLine.trim() && existingLine.trim()) {
                        // Both have content - prefer newer if different
                        merged.push(newLine !== existingLine ? newLine : existingLine);
                    } else {
                        // Use whichever has content
                        merged.push(newLine || existingLine);
                    }
                }

                return merged.join('\n');
            },

            // Create composite content
            createComposite: function(newContent, existingContent) {
                return `${existingContent}\n\n--- UPDATED ---\n\n${newContent}`;
            },

            // Adaptive compression based on content value
            adaptiveCompress: function(content, metadata = {}) {
                const value = this.assessContentValue(content, metadata);

                switch (value.priority) {
                    case 'high':
                        return content; // No compression
                    case 'medium':
                        return this.lightCompress(content);
                    case 'low':
                        return this.heavyCompress(content);
                    default:
                        return this.lightCompress(content);
                }
            },

            // Assess content value for storage prioritization
            assessContentValue: function(content, metadata = {}) {
                let score = 0;

                // Length factor
                if (content.length > 1000) score += 20;
                if (content.length > 5000) score += 20;

                // Structure factor
                if (content.includes('**')) score += 15; // Structured content
                if (/\d+[%\/]|\d+\.\d+/.test(content)) score += 15; // Contains metrics

                // Uniqueness factor
                const fingerprint = this.generateFingerprint(content);
                if (fingerprint && !this.contentFingerprints.has(fingerprint.hash)) {
                    score += 20; // Unique content
                }

                // Recency factor
                const age = metadata.timestamp ? Date.now() - metadata.timestamp : 0;
                if (age < 3600000) score += 10; // Less than 1 hour old
                if (age < 1800000) score += 10; // Less than 30 minutes old

                // Determine priority
                if (score >= 70) return this.storagePolicies.highValue;
                if (score >= 40) return this.storagePolicies.mediumValue;
                return this.storagePolicies.lowValue;
            },

            // Light compression (remove redundancy)
            lightCompress: function(content) {
                let compressed = content;

                // Remove excessive whitespace
                compressed = compressed.replace(/\n{3,}/g, '\n\n');
                compressed = compressed.replace(/ {2,}/g, ' ');

                // Remove redundant phrases (simple approach)
                const redundancies = [
                    ['the the', 'the'],
                    ['and and', 'and'],
                    ['or or', 'or']
                ];

                redundancies.forEach(([pattern, replacement]) => {
                    compressed = compressed.replace(new RegExp(pattern, 'gi'), replacement);
                });

                return compressed;
            },

            // Heavy compression (significant reduction)
            heavyCompress: function(content) {
                let compressed = this.lightCompress(content);

                // Extract key sentences
                const sentences = compressed.split(/[.!?]+/).filter(s => s.trim().length > 10);
                const keySentences = sentences.filter(sentence => {
                    const words = sentence.toLowerCase().split(/\s+/);
                    // Keep sentences with metrics, structure, or key terms
                    return /\d/.test(sentence) ||
                           words.some(word => ['analysis', 'finding', 'metric', 'system', 'performance'].includes(word));
                });

                if (keySentences.length > 0) {
                    compressed = keySentences.join('. ') + '.';
                }

                // Limit length
                if (compressed.length > 500) {
                    compressed = compressed.substring(0, 500) + '...';
                }

                return compressed;
            },

            // Memory defragmentation
            defragmentMemory: function(memoryObject) {
                const defragmented = {
                    ...memoryObject,
                    members: {}
                };

                // Process each member
                Object.entries(memoryObject.members).forEach(([memberName, memberData]) => {
                    const defragmentedMember = {
                        ...memberData,
                        reports: []
                    };

                    // Remove duplicates and optimize reports
                    const seenContent = new Set();
                    const uniqueReports = [];

                    memberData.reports.forEach(report => {
                        const contentKey = this.generateFingerprint(report.analysis)?.hash;
                        if (contentKey && !seenContent.has(contentKey)) {
                            seenContent.add(contentKey);
                            uniqueReports.push({
                                ...report,
                                analysis: this.adaptiveCompress(report.analysis, {
                                    timestamp: new Date(report.timestamp).getTime(),
                                    source: memberName
                                })
                            });
                        }
                    });

                    defragmentedMember.reports = uniqueReports.slice(-25); // Keep last 25
                    defragmented.members[memberName] = defragmentedMember;
                });

                return defragmented;
            },

            // Analyze storage efficiency
            analyzeStorageEfficiency: function() {
                const memoryData = localStorage.getItem('djinn_council_complete_memory');
                if (!memoryData) return;

                try {
                    const memory = JSON.parse(memoryData);
                    const originalSize = JSON.stringify(memory).length;

                    // Calculate potential savings
                    const defragmented = this.defragmentMemory(memory);
                    const optimizedSize = JSON.stringify(defragmented).length;

                    const savings = originalSize - optimizedSize;
                    const ratio = optimizedSize / originalSize;

                    this.analytics.deduplicationSavings = savings;
                    this.analytics.compressionRatio = ratio;

                    console.log(`üß† Memory Analysis: ${originalSize} ‚Üí ${optimizedSize} bytes (${(ratio * 100).toFixed(1)}% efficiency)`);

                    if (savings > 1000) {
                        this.analytics.optimizationOpportunities.push({
                            type: 'defragmentation',
                            savings: savings,
                            description: `Defragmentation could save ${savings} bytes`
                        });
                    }

                } catch (error) {
                    console.warn('Memory analysis failed:', error);
                }
            },

            // Load existing fingerprints for deduplication
            loadExistingFingerprints: function() {
                const memoryData = localStorage.getItem('djinn_council_complete_memory');
                if (!memoryData) return;

                try {
                    const memory = JSON.parse(memoryData);
                    Object.values(memory.members).forEach(member => {
                        member.reports.forEach(report => {
                            const fingerprint = this.generateFingerprint(report.analysis);
                            if (fingerprint) {
                                this.contentFingerprints.set(fingerprint.hash, {
                                    timestamp: new Date(report.timestamp).getTime(),
                                    source: member.specialization,
                                    content: report.analysis
                                });
                            }
                        });
                    });

                    console.log(`üß† Loaded ${this.contentFingerprints.size} content fingerprints for deduplication`);
                } catch (error) {
                    console.warn('Failed to load fingerprints:', error);
                }
            },

            // Schedule maintenance tasks
            scheduleMaintenanceTasks: function() {
                // Defragment memory every 30 minutes
                setInterval(() => {
                    this.performMaintenance();
                }, 30 * 60 * 1000);

                // Analyze efficiency every 15 minutes
                setInterval(() => {
                    this.analyzeStorageEfficiency();
                }, 15 * 60 * 1000);
            },

            // Perform maintenance tasks
            performMaintenance: function() {
                console.log('üß† Performing memory maintenance...');

                const memoryData = localStorage.getItem('djinn_council_complete_memory');
                if (!memoryData) return;

                try {
                    const memory = JSON.parse(memoryData);
                    const optimized = this.defragmentMemory(memory);

                    localStorage.setItem('djinn_council_complete_memory', JSON.stringify(optimized));
                    console.log('‚úÖ Memory maintenance completed');
                } catch (error) {
                    console.warn('Memory maintenance failed:', error);
                }
            },

            // Get optimization metrics
            getOptimizationMetrics: function() {
                return {
                    totalFingerprints: this.contentFingerprints.size,
                    deduplicationSavings: this.analytics.deduplicationSavings,
                    compressionRatio: this.analytics.compressionRatio,
                    optimizationOpportunities: this.analytics.optimizationOpportunities.length,
                    memoryEfficiency: ((1 - this.analytics.compressionRatio) * 100).toFixed(1) + '%'
                };
            }
        };

        // ========================================
        // ENHANCED MEMORY MANAGEMENT FUNCTIONS
        // ========================================

        // Enhanced store function with intelligent optimization
        function storeCouncilMemberReportOptimized(memberName, reportData) {
            const member = djinnCouncilMemory.members[memberName];

            // Generate optimized analysis content
            const originalAnalysis = reportData.analysis || '';
            const optimizedAnalysis = advancedMemoryOrchestrator.adaptiveCompress(originalAnalysis, {
                timestamp: Date.now(),
                source: memberName
            });

            // Check for duplicates
            const existingReports = member.reports;
            let deduplicatedAnalysis = optimizedAnalysis;

            if (existingReports.length > 0) {
                const lastReport = existingReports[existingReports.length - 1];
                deduplicatedAnalysis = advancedMemoryOrchestrator.deduplicateContent(
                    optimizedAnalysis,
                    lastReport.analysis
                );
            }

            // Add new report
            const newReport = {
                reportId: member.reports.length + 1,
                timestamp: new Date().toISOString(),
                metrics: reportData.metrics || {},
                analysis: deduplicatedAnalysis,
                canvasDataAnalyzed: reportData.canvasData || '',
                buildingOn: member.reports.length > 0 ? `Reports 1-${member.reports.length}` : 'Initial analysis'
            };

            member.reports.push(newReport);

            // Intelligent retention management
            const retentionPolicy = advancedMemoryOrchestrator.assessContentValue(deduplicatedAnalysis);
            const maxRetention = retentionPolicy.retention;

            if (member.reports.length > maxRetention) {
                // Remove oldest reports beyond retention limit
                const excess = member.reports.length - maxRetention;
                member.reports = member.reports.slice(excess);
            }

            // Save with optimization
            saveMemoryOptimized(djinnCouncilMemory);
        }

        // Optimized memory saving with defragmentation
        function saveMemoryOptimized(memoryObject) {
            try {
                // Apply defragmentation
                const defragmented = advancedMemoryOrchestrator.defragmentMemory(memoryObject);

                // Save optimized memory
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(defragmented));

                // Update analytics
                const originalSize = JSON.stringify(memoryObject).length;
                const optimizedSize = JSON.stringify(defragmented).length;
                advancedMemoryOrchestrator.analytics.totalStored = optimizedSize;

                console.log(`üíæ Memory optimized: ${originalSize} ‚Üí ${optimizedSize} bytes (${((originalSize - optimizedSize) / originalSize * 100).toFixed(1)}% savings)`);

            } catch (error) {
                console.warn('Optimized memory save failed, using fallback:', error);

                // Fallback to original compression methods
                try {
                    const compressedMemory = compressMemoryForStorage(memoryObject);
                    localStorage.setItem('djinn_council_complete_memory', JSON.stringify(compressedMemory));
                } catch (fallbackError) {
                    console.warn('Fallback compression failed:', fallbackError);
                    const ultraCompressed = ultraCompressMemory(memoryObject);
                    localStorage.setItem('djinn_council_complete_memory', JSON.stringify(ultraCompressed));
                }
            }
        }

        // ========================================
        // CROSS-SYSTEM CORRELATION ENGINE
        // ========================================

        // Advanced correlation analysis across AI systems
        const crossSystemCorrelationEngine = {
            // Correlation analysis data
            correlationMatrix: new Map(),
            consensusPatterns: [],
            conflictPatterns: [],
            interSystemDependencies: new Map(),
            correlationHistory: [],

            // Analysis metrics
            metrics: {
                consensusStrength: 0,
                conflictCount: 0,
                correlationDiversity: 0,
                systemHarmony: 0
            },

            // Initialize correlation engine
            initialize: function() {
                console.log('üîó Initializing Cross-System Correlation Engine');
                this.buildInitialCorrelationMatrix();
                this.scheduleCorrelationAnalysis();
            },

            // Build initial correlation matrix from existing data
            buildInitialCorrelationMatrix: function() {
                const aiSystems = ['narra', 'nazar', 'whale', 'djinn', 'watchtower'];
                const councilMembers = ['pattern', 'wisdom', 'paradox', 'boundaries', 'memory'];

                // Initialize correlation matrix
                aiSystems.forEach(system => {
                    this.correlationMatrix.set(system, new Map());
                    councilMembers.forEach(member => {
                        this.correlationMatrix.get(system).set(member, {
                            correlationStrength: 0,
                            interactionCount: 0,
                            consensusRate: 0,
                            lastInteraction: null,
                            sharedInsights: [],
                            complementaryPatterns: []
                        });
                    });
                });

                console.log('üîó Correlation matrix initialized for', aiSystems.length, 'AI systems and', councilMembers.length, 'council members');
            },

            // Analyze correlations between AI systems and council members
            analyzeCorrelations: function(systemData, councilData) {
                const correlations = {
                    timestamp: Date.now(),
                    systemConsensus: this.calculateSystemConsensus(systemData),
                    councilConsensus: this.calculateCouncilConsensus(councilData),
                    crossCorrelations: this.calculateCrossCorrelations(systemData, councilData),
                    emergingPatterns: this.identifyEmergingPatterns(systemData, councilData),
                    conflictAnalysis: this.analyzeConflicts(systemData, councilData)
                };

                // Update correlation history
                this.correlationHistory.push(correlations);
                if (this.correlationHistory.length > 100) {
                    this.correlationHistory.shift(); // Keep last 100 analyses
                }

                // Update metrics
                this.updateCorrelationMetrics(correlations);

                return correlations;
            },

            // Calculate consensus across AI systems
            calculateSystemConsensus: function(systemData) {
                if (!systemData || Object.keys(systemData).length === 0) return 0;

                const systems = Object.keys(systemData);
                let totalConsensus = 0;
                let comparisonCount = 0;

                // Compare each system pair
                for (let i = 0; i < systems.length; i++) {
                    for (let j = i + 1; j < systems.length; j++) {
                        const system1 = systems[i];
                        const system2 = systems[j];

                        const consensus = this.calculatePairConsensus(
                            systemData[system1],
                            systemData[system2]
                        );

                        totalConsensus += consensus;
                        comparisonCount++;
                    }
                }

                return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
            },

            // Calculate consensus across council members
            calculateCouncilConsensus: function(councilData) {
                if (!councilData || Object.keys(councilData).length === 0) return 0;

                const members = Object.keys(councilData);
                let totalConsensus = 0;
                let comparisonCount = 0;

                // Compare each member pair
                for (let i = 0; i < members.length; i++) {
                    for (let j = i + 1; j < members.length; j++) {
                        const member1 = members[i];
                        const member2 = members[j];

                        const consensus = this.calculatePairConsensus(
                            councilData[member1],
                            councilData[member2]
                        );

                        totalConsensus += consensus;
                        comparisonCount++;
                    }
                }

                return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
            },

            // Calculate consensus between two entities
            calculatePairConsensus: function(entity1, entity2) {
                if (!entity1 || !entity2) return 0;

                // Simple consensus calculation based on content similarity
                const content1 = this.extractKeyContent(entity1);
                const content2 = this.extractKeyContent(entity2);

                if (!content1 || !content2) return 0;

                // Calculate similarity score
                return this.calculateContentSimilarity(content1, content2);
            },

            // Extract key content for comparison
            extractKeyContent: function(entity) {
                if (typeof entity === 'string') {
                    return entity.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 2);
                }

                if (entity.analysis) {
                    return entity.analysis.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 2);
                }

                if (entity.content) {
                    return entity.content.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 2);
                }

                return null;
            },

            // Calculate content similarity
            calculateContentSimilarity: function(content1, content2) {
                if (!content1 || !content2) return 0;

                const set1 = new Set(content1);
                const set2 = new Set(content2);

                const intersection = new Set([...set1].filter(x => set2.has(x)));
                const union = new Set([...set1, ...set2]);

                return intersection.size / union.size;
            },

            // Calculate cross-correlations between systems and council
            calculateCrossCorrelations: function(systemData, councilData) {
                const correlations = [];

                Object.entries(systemData).forEach(([systemName, systemInfo]) => {
                    Object.entries(councilData).forEach(([memberName, memberInfo]) => {
                        const correlation = this.calculatePairConsensus(systemInfo, memberInfo);

                        correlations.push({
                            system: systemName,
                            member: memberName,
                            correlation: correlation,
                            strength: this.categorizeCorrelationStrength(correlation)
                        });

                        // Update correlation matrix
                        if (this.correlationMatrix.has(systemName)) {
                            const systemCorrelations = this.correlationMatrix.get(systemName);
                            if (systemCorrelations.has(memberName)) {
                                const existing = systemCorrelations.get(memberName);
                                existing.correlationStrength = (existing.correlationStrength + correlation) / 2;
                                existing.interactionCount++;
                                existing.lastInteraction = Date.now();
                            }
                        }
                    });
                });

                return correlations.sort((a, b) => b.correlation - a.correlation);
            },

            // Categorize correlation strength
            categorizeCorrelationStrength: function(correlation) {
                if (correlation >= 0.8) return 'very_strong';
                if (correlation >= 0.6) return 'strong';
                if (correlation >= 0.4) return 'moderate';
                if (correlation >= 0.2) return 'weak';
                return 'very_weak';
            },

            // Identify emerging patterns
            identifyEmergingPatterns: function(systemData, councilData) {
                const patterns = [];

                // Look for consensus patterns
                const systemConsensus = this.calculateSystemConsensus(systemData);
                const councilConsensus = this.calculateCouncilConsensus(councilData);

                if (systemConsensus > 0.7 && councilConsensus > 0.7) {
                    patterns.push({
                        type: 'high_consensus',
                        description: 'High consensus between AI systems and council members',
                        confidence: Math.min(systemConsensus, councilConsensus)
                    });
                }

                // Look for complementary patterns
                const crossCorrelations = this.calculateCrossCorrelations(systemData, councilData);
                const strongCorrelations = crossCorrelations.filter(c => c.correlation > 0.6);

                if (strongCorrelations.length > 0) {
                    patterns.push({
                        type: 'strong_complementarity',
                        description: `${strongCorrelations.length} strong correlations identified`,
                        pairs: strongCorrelations.slice(0, 3),
                        confidence: strongCorrelations[0].correlation
                    });
                }

                // Look for specialization patterns
                const specializationPatterns = this.identifySpecializationPatterns(systemData, councilData);
                if (specializationPatterns.length > 0) {
                    patterns.push(...specializationPatterns);
                }

                return patterns;
            },

            // Identify specialization patterns
            identifySpecializationPatterns: function(systemData, councilData) {
                const patterns = [];

                // Define specialization mappings
                const systemSpecializations = {
                    narra: ['monitoring', 'consistency', 'stability'],
                    nazar: ['analysis', 'synthesis', 'content'],
                    whale: ['data', 'retrieval', 'processing'],
                    djinn: ['conversation', 'interaction', 'response'],
                    watchtower: ['integrity', 'security', 'oversight']
                };

                const memberSpecializations = {
                    pattern: ['patterns', 'governance', 'structure'],
                    wisdom: ['synthesis', 'knowledge', 'growth'],
                    paradox: ['innovation', 'creativity', 'resolution'],
                    boundaries: ['autonomy', 'sovereignty', 'integrity'],
                    memory: ['storage', 'continuity', 'persistence']
                };

                // Find complementary specializations
                Object.entries(systemSpecializations).forEach(([system, sysSpecs]) => {
                    Object.entries(memberSpecializations).forEach(([member, memSpecs]) => {
                        const overlap = sysSpecs.filter(spec => memSpecs.includes(spec)).length;
                        const complementarity = overlap / Math.max(sysSpecs.length, memSpecs.length);

                        if (complementarity > 0.5) {
                            patterns.push({
                                type: 'specialization_complementarity',
                                description: `${system} and ${member} show complementary specializations`,
                                overlap: overlap,
                                confidence: complementarity
                            });
                        }
                    });
                });

                return patterns;
            },

            // Analyze conflicts between systems
            analyzeConflicts: function(systemData, councilData) {
                const conflicts = [];

                // Look for contradictory conclusions
                const conclusions = this.extractConclusions(systemData, councilData);
                const contradictions = this.findContradictions(conclusions);

                if (contradictions.length > 0) {
                    conflicts.push({
                        type: 'conclusion_conflicts',
                        count: contradictions.length,
                        examples: contradictions.slice(0, 3),
                        severity: this.assessConflictSeverity(contradictions)
                    });
                }

                // Look for resource competition
                const resourceConflicts = this.identifyResourceConflicts(systemData);
                if (resourceConflicts.length > 0) {
                    conflicts.push({
                        type: 'resource_competition',
                        conflicts: resourceConflicts,
                        severity: 'moderate'
                    });
                }

                return conflicts;
            },

            // Extract conclusions from data
            extractConclusions: function(systemData, councilData) {
                const conclusions = [];

                // Extract from system data
                Object.entries(systemData).forEach(([system, data]) => {
                    if (data && typeof data === 'object') {
                        const content = this.extractKeyContent(data);
                        if (content) {
                            conclusions.push({
                                source: system,
                                type: 'system',
                                conclusions: this.extractConclusionStatements(content)
                            });
                        }
                    }
                });

                // Extract from council data
                Object.entries(councilData).forEach(([member, data]) => {
                    if (data && typeof data === 'object') {
                        const content = this.extractKeyContent(data);
                        if (content) {
                            conclusions.push({
                                source: member,
                                type: 'council',
                                conclusions: this.extractConclusionStatements(content)
                            });
                        }
                    }
                });

                return conclusions;
            },

            // Extract conclusion statements
            extractConclusionStatements: function(content) {
                const conclusionWords = ['conclusion', 'result', 'finding', 'therefore', 'thus', 'hence'];
                const conclusions = [];

                content.forEach((word, index) => {
                    if (conclusionWords.includes(word.toLowerCase())) {
                        // Extract surrounding context
                        const start = Math.max(0, index - 5);
                        const end = Math.min(content.length, index + 10);
                        const context = content.slice(start, end).join(' ');
                        conclusions.push(context);
                    }
                });

                return conclusions;
            },

            // Find contradictions in conclusions
            findContradictions: function(conclusions) {
                const contradictions = [];

                for (let i = 0; i < conclusions.length; i++) {
                    for (let j = i + 1; j < conclusions.length; j++) {
                        const conclusion1 = conclusions[i];
                        const conclusion2 = conclusions[j];

                        if (this.areContradictory(conclusion1.conclusions, conclusion2.conclusions)) {
                            contradictions.push({
                                sources: [conclusion1.source, conclusion2.source],
                                contradiction: this.describeContradiction(conclusion1, conclusion2)
                            });
                        }
                    }
                }

                return contradictions;
            },

            // Check if conclusions are contradictory
            areContradictory: function(conclusions1, conclusions2) {
                const contradictionPairs = [
                    ['increase', 'decrease'],
                    ['improve', 'worsen'],
                    ['stable', 'unstable'],
                    ['consistent', 'inconsistent'],
                    ['positive', 'negative']
                ];

                const text1 = conclusions1.join(' ').toLowerCase();
                const text2 = conclusions2.join(' ').toLowerCase();

                return contradictionPairs.some(([word1, word2]) => {
                    return (text1.includes(word1) && text2.includes(word2)) ||
                           (text1.includes(word2) && text2.includes(word1));
                });
            },

            // Describe the contradiction
            describeContradiction: function(conclusion1, conclusion2) {
                return `${conclusion1.source} vs ${conclusion2.source}: Conflicting conclusions detected`;
            },

            // Identify resource conflicts
            identifyResourceConflicts: function(systemData) {
                // This would analyze resource usage patterns
                // For now, return empty array as we don't have resource usage data
                return [];
            },

            // Assess conflict severity
            assessConflictSeverity: function(conflicts) {
                if (conflicts.length === 0) return 'none';
                if (conflicts.length <= 2) return 'low';
                if (conflicts.length <= 5) return 'moderate';
                return 'high';
            },

            // Update correlation metrics
            updateCorrelationMetrics: function(correlations) {
                this.metrics.consensusStrength = (correlations.systemConsensus + correlations.councilConsensus) / 2;
                this.metrics.conflictCount = correlations.conflictAnalysis.reduce((sum, conflict) => sum + conflict.count, 0);
                this.metrics.correlationDiversity = correlations.crossCorrelations.length;
                this.metrics.systemHarmony = this.calculateSystemHarmony(correlations);
            },

            // Calculate system harmony
            calculateSystemHarmony: function(correlations) {
                const consensus = correlations.systemConsensus;
                const conflicts = correlations.conflictAnalysis.reduce((sum, conflict) => sum + conflict.count, 0);
                const patterns = correlations.emergingPatterns.length;

                // Harmony = consensus - conflicts + patterns
                return Math.max(0, Math.min(100, (consensus * 100) - (conflicts * 10) + (patterns * 5)));
            },

            // Schedule correlation analysis
            scheduleCorrelationAnalysis: function() {
                // Analyze correlations every 5 minutes
                setInterval(() => {
                    this.performCorrelationAnalysis();
                }, 5 * 60 * 1000);
            },

            // Perform correlation analysis
            performCorrelationAnalysis: function() {
                try {
                    // Get current system and council data
                    const systemData = this.getCurrentSystemData();
                    const councilData = this.getCurrentCouncilData();

                    if (Object.keys(systemData).length > 0 && Object.keys(councilData).length > 0) {
                        const correlations = this.analyzeCorrelations(systemData, councilData);
                        console.log('üîó Correlation analysis completed:', {
                            consensus: (correlations.systemConsensus * 100).toFixed(1) + '%',
                            patterns: correlations.emergingPatterns.length,
                            conflicts: correlations.conflictAnalysis.length
                        });
                    }
                } catch (error) {
                    console.warn('Correlation analysis failed:', error);
                }
            },

            // Get current system data
            getCurrentSystemData: function() {
                const aiMemory = localStorage.getItem('ai_memory_state');
                if (!aiMemory) return {};

                try {
                    const memory = JSON.parse(aiMemory);
                    return memory;
                } catch (error) {
                    return {};
                }
            },

            // Get current council data
            getCurrentCouncilData: function() {
                const councilMemory = localStorage.getItem('djinn_council_complete_memory');
                if (!councilMemory) return {};

                try {
                    const memory = JSON.parse(councilMemory);
                    const latestReports = {};

                    Object.entries(memory.members).forEach(([member, data]) => {
                        if (data.reports && data.reports.length > 0) {
                            latestReports[member] = data.reports[data.reports.length - 1];
                        }
                    });

                    return latestReports;
                } catch (error) {
                    return {};
                }
            },

            // Get correlation insights
            getCorrelationInsights: function() {
                const latest = this.correlationHistory[this.correlationHistory.length - 1];
                if (!latest) return null;

                return {
                    consensusStrength: (this.metrics.consensusStrength * 100).toFixed(1) + '%',
                    systemHarmony: this.metrics.systemHarmony.toFixed(1) + '%',
                    emergingPatterns: latest.emergingPatterns.length,
                    activeConflicts: this.metrics.conflictCount,
                    topCorrelations: latest.crossCorrelations.slice(0, 3),
                    lastAnalysis: new Date(latest.timestamp).toLocaleTimeString()
                };
            }
        };

        // ========================================
        // CORRELATIVE ANALYSIS FRAMEWORK
        // ========================================

        // Advanced correlative analysis framework for synthesis report integration
        const correlativeAnalysisFramework = {
            // Synthesis report integration
            synthesisReports: [],
            analysisCycles: [],
            deepInsights: new Map(),

            // Analysis components
            components: {
                canvasEvolutionAnalyzer: null,
                aiSystemCorrelator: null,
                synthesisIntegrator: null,
                predictiveCorrelator: null
            },

            // Analysis metrics
            metrics: {
                synthesisQuality: 0,
                correlationDepth: 0,
                insightGeneration: 0,
                predictiveAccuracy: 0
            },

            // Initialize correlative analysis framework
            initialize: function() {
                console.log('üîç Initializing Correlative Analysis Framework');
                this.buildAnalysisComponents();
                this.setupSynthesisIntegration();
                this.scheduleDeepAnalysis();
            },

            // Build analysis components
            buildAnalysisComponents: function() {
                // Canvas evolution analyzer
                this.components.canvasEvolutionAnalyzer = {
                    analyzeEvolution: function(canvasData, synthesisReport) {
                        const evolution = {
                            contentGrowth: this.calculateContentGrowth(canvasData),
                            patternEmergence: this.identifyPatternEmergence(canvasData),
                            stabilityMetrics: this.assessStability(canvasData),
                            synthesisAlignment: this.measureSynthesisAlignment(canvasData, synthesisReport)
                        };
                        return evolution;
                    },

                    calculateContentGrowth: function(canvasData) {
                        if (!canvasData.history || canvasData.history.length < 2) return 0;

                        const recent = canvasData.history.slice(-10);
                        const totalGrowth = recent.reduce((sum, snapshot, index) => {
                            if (index === 0) return 0;
                            return sum + (snapshot.metrics.characters - recent[index-1].metrics.characters);
                        }, 0);

                        return totalGrowth / recent.length;
                    },

                    identifyPatternEmergence: function(canvasData) {
                        // Analyze patterns in canvas evolution
                        const patterns = [];
                        if (canvasData.history && canvasData.history.length > 5) {
                            const recent = canvasData.history.slice(-5);

                            // Look for repeating patterns
                            const changes = recent.map((snapshot, index) => {
                                if (index === 0) return 0;
                                return snapshot.metrics.characters - recent[index-1].metrics.characters;
                            });

                            // Detect trends
                            if (changes.every(change => change > 0)) {
                                patterns.push('consistent_growth');
                            } else if (changes.every(change => change < 0)) {
                                patterns.push('consistent_decline');
                            } else if (Math.abs(changes.reduce((a, b) => a + b, 0) / changes.length) < 50) {
                                patterns.push('stable_evolution');
                            }
                        }

                        return patterns;
                    },

                    assessStability: function(canvasData) {
                        if (!canvasData.history || canvasData.history.length < 3) {
                            return { stability: 0, volatility: 0 };
                        }

                        const changes = canvasData.history.slice(-10).map((snapshot, index, arr) => {
                            if (index === 0) return 0;
                            return snapshot.metrics.characters - arr[index-1].metrics.characters;
                        });

                        const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
                        const variance = changes.reduce((sum, change) => sum + Math.pow(change - avgChange, 2), 0) / changes.length;
                        const volatility = Math.sqrt(variance);

                        return {
                            stability: Math.max(0, 100 - (volatility / 10)),
                            volatility: volatility
                        };
                    },

                    measureSynthesisAlignment: function(canvasData, synthesisReport) {
                        if (!synthesisReport) return 0;

                        // Measure how well synthesis captures canvas evolution
                        const canvasTrends = this.identifyPatternEmergence(canvasData);
                        const synthesisContent = synthesisReport.toLowerCase();

                        let alignment = 0;
                        canvasTrends.forEach(trend => {
                            if (synthesisContent.includes(trend.replace('_', ' '))) {
                                alignment += 25;
                            }
                        });

                        return Math.min(100, alignment);
                    }
                };

                // AI system correlator
                this.components.aiSystemCorrelator = {
                    correlateAISystems: function(aiData, synthesisReport) {
                        const correlations = {
                            systemConsensus: this.calculateSystemConsensus(aiData),
                            synthesisAgreement: this.measureSynthesisAgreement(aiData, synthesisReport),
                            performancePatterns: this.analyzePerformancePatterns(aiData),
                            collaborativeEfficiency: this.assessCollaborativeEfficiency(aiData)
                        };
                        return correlations;
                    },

                    calculateSystemConsensus: function(aiData) {
                        if (!aiData || Object.keys(aiData).length < 2) return 0;

                        const systems = Object.keys(aiData);
                        let totalConsensus = 0;
                        let comparisonCount = 0;

                        for (let i = 0; i < systems.length; i++) {
                            for (let j = i + 1; j < systems.length; j++) {
                                const system1 = aiData[systems[i]];
                                const system2 = aiData[systems[j]];

                                const consensus = this.calculatePairConsensus(system1, system2);
                                totalConsensus += consensus;
                                comparisonCount++;
                            }
                        }

                        return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
                    },

                    calculatePairConsensus: function(system1, system2) {
                        if (!system1 || !system2) return 0;

                        // Compare analysis content
                        const content1 = this.extractAnalysisContent(system1);
                        const content2 = this.extractAnalysisContent(system2);

                        return this.calculateContentSimilarity(content1, content2);
                    },

                    extractAnalysisContent: function(system) {
                        if (typeof system === 'string') return system.toLowerCase();
                        if (system.analysis) return system.analysis.toLowerCase();
                        if (system.content) return system.content.toLowerCase();
                        return '';
                    },

                    calculateContentSimilarity: function(content1, content2) {
                        if (!content1 || !content2) return 0;

                        const words1 = content1.split(/\s+/).filter(w => w.length > 2);
                        const words2 = content2.split(/\s+/).filter(w => w.length > 2);

                        const set1 = new Set(words1);
                        const set2 = new Set(words2);

                        const intersection = new Set([...set1].filter(x => set2.has(x)));
                        const union = new Set([...set1, ...set2]);

                        return intersection.size / union.size;
                    },

                    measureSynthesisAgreement: function(aiData, synthesisReport) {
                        if (!synthesisReport) return 0;

                        let totalAgreement = 0;
                        let systemCount = 0;

                        Object.values(aiData).forEach(system => {
                            const systemContent = this.extractAnalysisContent(system);
                            const agreement = this.calculateContentSimilarity(systemContent, synthesisReport.toLowerCase());
                            totalAgreement += agreement;
                            systemCount++;
                        });

                        return systemCount > 0 ? (totalAgreement / systemCount) * 100 : 0;
                    },

                    analyzePerformancePatterns: function(aiData) {
                        const patterns = [];

                        Object.entries(aiData).forEach(([systemName, systemData]) => {
                            if (systemData && typeof systemData === 'object') {
                                // Analyze response patterns
                                if (systemData.consistency) {
                                    patterns.push({
                                        system: systemName,
                                        pattern: 'consistency_focused',
                                        strength: systemData.consistency
                                    });
                                }

                                if (systemData.creativity) {
                                    patterns.push({
                                        system: systemName,
                                        pattern: 'creativity_focused',
                                        strength: systemData.creativity
                                    });
                                }
                            }
                        });

                        return patterns;
                    },

                    assessCollaborativeEfficiency: function(aiData) {
                        const consensus = this.calculateSystemConsensus(aiData);
                        const systemCount = Object.keys(aiData).length;

                        // Efficiency increases with consensus and system count
                        return Math.min(100, (consensus * 100) + (systemCount * 10));
                    }
                };

                // Synthesis integrator
                this.components.synthesisIntegrator = {
                    integrateSynthesisReport: function(synthesisReport, canvasData, aiData) {
                        const integration = {
                            synthesisQuality: this.assessSynthesisQuality(synthesisReport),
                            canvasIntegration: this.measureCanvasIntegration(synthesisReport, canvasData),
                            aiIntegration: this.measureAIIntegration(synthesisReport, aiData),
                            comprehensiveCoverage: this.assessComprehensiveCoverage(synthesisReport, canvasData, aiData)
                        };
                        return integration;
                    },

                    assessSynthesisQuality: function(synthesisReport) {
                        if (!synthesisReport) return 0;

                        let quality = 50; // Base quality

                        // Length assessment
                        if (synthesisReport.length > 1000) quality += 20;
                        else if (synthesisReport.length > 500) quality += 10;

                        // Content richness
                        const sentences = synthesisReport.split(/[.!?]+/).length;
                        if (sentences > 10) quality += 15;

                        // Key terms presence
                        const keyTerms = ['analysis', 'evolution', 'correlation', 'pattern', 'synthesis'];
                        const foundTerms = keyTerms.filter(term => synthesisReport.toLowerCase().includes(term)).length;
                        quality += foundTerms * 3;

                        return Math.min(100, quality);
                    },

                    measureCanvasIntegration: function(synthesisReport, canvasData) {
                        if (!synthesisReport || !canvasData) return 0;

                        let integration = 0;
                        const report = synthesisReport.toLowerCase();

                        // Check for canvas-specific references
                        if (report.includes('canvas') || report.includes('content')) integration += 30;
                        if (report.includes('evolution') || report.includes('change')) integration += 25;
                        if (report.includes('pattern') || report.includes('trend')) integration += 20;

                        // Check for metrics integration
                        if (canvasData.metrics) {
                            if (report.includes('character') || report.includes('length')) integration += 15;
                            if (report.includes('stability') || report.includes('volatility')) integration += 10;
                        }

                        return Math.min(100, integration);
                    },

                    measureAIIntegration: function(synthesisReport, aiData) {
                        if (!synthesisReport || !aiData) return 0;

                        let integration = 0;
                        const report = synthesisReport.toLowerCase();

                        // Check for AI system references
                        const aiSystems = ['narra', 'nazar', 'whale', 'djinn', 'watchtower'];
                        const mentionedSystems = aiSystems.filter(system => report.includes(system)).length;
                        integration += mentionedSystems * 10;

                        // Check for analysis integration
                        if (report.includes('consensus') || report.includes('agreement')) integration += 20;
                        if (report.includes('correlation') || report.includes('collaboration')) integration += 15;

                        return Math.min(100, integration);
                    },

                    assessComprehensiveCoverage: function(synthesisReport, canvasData, aiData) {
                        const canvasCoverage = this.measureCanvasIntegration(synthesisReport, canvasData);
                        const aiCoverage = this.measureAIIntegration(synthesisReport, aiData);

                        // Overall coverage is weighted average
                        return (canvasCoverage * 0.4) + (aiCoverage * 0.6);
                    }
                };

                // Predictive correlator
                this.components.predictiveCorrelator = {
                    correlatePredictions: function(predictions, synthesisReport, canvasData, aiData) {
                        const correlations = {
                            predictiveAccuracy: this.assessPredictiveAccuracy(predictions, canvasData, aiData),
                            synthesisPredictiveAlignment: this.measureSynthesisPredictiveAlignment(predictions, synthesisReport),
                            futureTrendCorrelation: this.analyzeFutureTrendCorrelation(predictions, canvasData),
                            riskAssessment: this.performRiskAssessment(predictions, aiData)
                        };
                        return correlations;
                    },

                    assessPredictiveAccuracy: function(predictions, canvasData, aiData) {
                        if (!predictions) return 0;

                        let accuracy = 0;

                        // Check canvas predictions against actual data
                        if (predictions.canvas && canvasData) {
                            const predictedTrend = predictions.canvas.prediction;
                            const actualTrend = this.determineActualTrend(canvasData);

                            if (predictedTrend === actualTrend) accuracy += 40;
                            else if (this.areTrendsCompatible(predictedTrend, actualTrend)) accuracy += 20;
                        }

                        // Check AI predictions against actual data
                        if (predictions.aiSystems && aiData) {
                            const predictedConsensus = predictions.aiSystems.prediction;
                            const actualConsensus = this.calculateActualConsensus(aiData);

                            if (Math.abs(predictedConsensus - actualConsensus) < 0.2) accuracy += 30;
                        }

                        return Math.min(100, accuracy);
                    },

                    determineActualTrend: function(canvasData) {
                        if (!canvasData.history || canvasData.history.length < 3) return 'unknown';

                        const recent = canvasData.history.slice(-3);
                        const changes = recent.map((snapshot, index) => {
                            if (index === 0) return 0;
                            return snapshot.metrics.characters - recent[index-1].metrics.characters;
                        });

                        const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;

                        if (avgChange > 50) return 'expanding';
                        if (avgChange < -50) return 'contracting';
                        return 'stable';
                    },

                    areTrendsCompatible: function(predicted, actual) {
                        const compatiblePairs = [
                            ['expanding', 'stable'],
                            ['contracting', 'stable'],
                            ['stable', 'expanding'],
                            ['stable', 'contracting']
                        ];

                        return compatiblePairs.some(([a, b]) => (predicted === a && actual === b) || (predicted === b && actual === a));
                    },

                    calculateActualConsensus: function(aiData) {
                        if (!aiData || Object.keys(aiData).length < 2) return 0;

                        // Simplified consensus calculation
                        const analyses = Object.values(aiData).map(system => this.extractAnalysisContent(system));
                        let totalConsensus = 0;
                        let comparisonCount = 0;

                        for (let i = 0; i < analyses.length; i++) {
                            for (let j = i + 1; j < analyses.length; j++) {
                                const similarity = this.calculateContentSimilarity(analyses[i], analyses[j]);
                                totalConsensus += similarity;
                                comparisonCount++;
                            }
                        }

                        return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
                    },

                    calculateContentSimilarity: function(content1, content2) {
                        if (!content1 || !content2) return 0;

                        const words1 = content1.split(/\s+/).filter(w => w.length > 2);
                        const words2 = content2.split(/\s+/).filter(w => w.length > 2);

                        const set1 = new Set(words1);
                        const set2 = new Set(words2);

                        const intersection = new Set([...set1].filter(x => set2.has(x)));
                        const union = new Set([...set1, ...set2]);

                        return intersection.size / union.size;
                    },

                    extractAnalysisContent: function(system) {
                        if (typeof system === 'string') return system.toLowerCase();
                        if (system.analysis) return system.analysis.toLowerCase();
                        if (system.content) return system.content.toLowerCase();
                        return '';
                    },

                    measureSynthesisPredictiveAlignment: function(predictions, synthesisReport) {
                        if (!predictions || !synthesisReport) return 0;

                        let alignment = 0;
                        const report = synthesisReport.toLowerCase();

                        // Check if synthesis report acknowledges predictions
                        if (report.includes('prediction') || report.includes('forecast')) alignment += 30;
                        if (report.includes('future') || report.includes('trend')) alignment += 20;

                        // Check for specific prediction references
                        if (predictions.canvas && report.includes('canvas')) alignment += 15;
                        if (predictions.aiSystems && report.includes('ai') || report.includes('system')) alignment += 15;

                        return Math.min(100, alignment);
                    },

                    analyzeFutureTrendCorrelation: function(predictions, canvasData) {
                        if (!predictions || !canvasData) return 0;

                        // Analyze how well predictions correlate with future canvas evolution
                        const predictedTrend = predictions.canvas ? predictions.canvas.prediction : 'unknown';
                        const stability = canvasData.stability || 0;

                        // Stable systems are easier to predict
                        if (predictedTrend === 'stable' && stability > 70) return 80;
                        if (predictedTrend === 'expanding' && stability < 50) return 60;
                        if (predictedTrend === 'contracting' && stability < 50) return 60;

                        return 40; // Default moderate correlation
                    },

                    performRiskAssessment: function(predictions, aiData) {
                        if (!predictions || !aiData) return { level: 'unknown', factors: [] };

                        const risks = [];
                        let riskLevel = 'low';

                        // Assess prediction confidence
                        if (predictions.canvas && predictions.canvas.confidence < 0.5) {
                            risks.push('Low canvas prediction confidence');
                            riskLevel = 'moderate';
                        }

                        if (predictions.aiSystems && predictions.aiSystems.confidence < 0.5) {
                            risks.push('Low AI system prediction confidence');
                            riskLevel = 'moderate';
                        }

                        // Assess system consensus
                        const consensus = this.calculateActualConsensus(aiData);
                        if (consensus < 0.3) {
                            risks.push('Low AI system consensus');
                            riskLevel = 'high';
                        }

                        return {
                            level: riskLevel,
                            factors: risks
                        };
                    }
                };

                console.log('üîç Analysis components initialized');
            },

            // Setup synthesis integration
            setupSynthesisIntegration: function() {
                // Listen for synthesis report generation
                window.addEventListener('storage', (event) => {
                    if (event.key === 'synthesis_report_generated') {
                        this.handleSynthesisReportGeneration();
                    }
                });

                // Check for existing synthesis reports
                this.checkExistingSynthesisReports();
            },

            // Handle synthesis report generation
            handleSynthesisReportGeneration: function() {
                console.log('üîç Synthesis report generation detected - initiating correlative analysis');

                // Get synthesis report
                const synthesisReport = localStorage.getItem('synthesis_report');
                if (!synthesisReport) return;

                // Get current data
                const canvasData = this.getCurrentCanvasData();
                const aiData = this.getCurrentAIData();
                const predictions = predictiveAnalyticsFramework ? predictiveAnalyticsFramework.getCurrentPredictions() : null;

                // Perform correlative analysis
                const analysis = this.performCorrelativeAnalysis(synthesisReport, canvasData, aiData, predictions);

                // Store analysis results
                this.storeAnalysisResults(analysis);

                // Update metrics
                this.updateAnalysisMetrics(analysis);

                console.log('üîç Correlative analysis completed:', {
                    synthesisQuality: analysis.synthesisQuality,
                    correlationDepth: analysis.correlationDepth,
                    insightsGenerated: analysis.insights.length
                });
            },

            // Perform correlative analysis
            performCorrelativeAnalysis: function(synthesisReport, canvasData, aiData, predictions) {
                const analysis = {
                    timestamp: Date.now(),
                    synthesisReport: synthesisReport,
                    components: {}
                };

                // Canvas evolution analysis
                if (canvasData) {
                    analysis.components.canvasEvolution = this.components.canvasEvolutionAnalyzer.analyzeEvolution(canvasData, synthesisReport);
                }

                // AI system correlation
                if (aiData) {
                    analysis.components.aiCorrelation = this.components.aiSystemCorrelator.correlateAISystems(aiData, synthesisReport);
                }

                // Synthesis integration
                analysis.components.synthesisIntegration = this.components.synthesisIntegrator.integrateSynthesisReport(synthesisReport, canvasData, aiData);

                // Predictive correlation
                if (predictions) {
                    analysis.components.predictiveCorrelation = this.components.predictiveCorrelator.correlatePredictions(predictions, synthesisReport, canvasData, aiData);
                }

                // Generate deep insights
                analysis.insights = this.generateDeepInsights(analysis);

                // Calculate overall metrics
                analysis.synthesisQuality = analysis.components.synthesisIntegration ?
                    analysis.components.synthesisIntegration.synthesisQuality : 0;

                analysis.correlationDepth = this.calculateCorrelationDepth(analysis);

                return analysis;
            },

            // Generate deep insights
            generateDeepInsights: function(analysis) {
                const insights = [];

                // Canvas evolution insights
                if (analysis.components.canvasEvolution) {
                    const evolution = analysis.components.canvasEvolution;

                    if (evolution.contentGrowth > 100) {
                        insights.push({
                            type: 'canvas_growth',
                            priority: 'high',
                            description: `Canvas content growing rapidly (${evolution.contentGrowth.toFixed(0)} chars/min)`,
                            implications: 'High analysis demand - consider increasing processing capacity'
                        });
                    }

                    if (evolution.stability.stability > 80) {
                        insights.push({
                            type: 'canvas_stability',
                            priority: 'medium',
                            description: `Canvas evolution highly stable (${evolution.stability.stability.toFixed(1)}% stability)`,
                            implications: 'Predictable patterns - optimize for consistency analysis'
                        });
                    }

                    if (evolution.synthesisAlignment > 80) {
                        insights.push({
                            type: 'synthesis_alignment',
                            priority: 'high',
                            description: `Synthesis report strongly aligned with canvas evolution (${evolution.synthesisAlignment.toFixed(1)}% alignment)`,
                            implications: 'High-quality synthesis - excellent integration achieved'
                        });
                    }
                }

                // AI system insights
                if (analysis.components.aiCorrelation) {
                    const correlation = analysis.components.aiCorrelation;

                    if (correlation.systemConsensus > 0.7) {
                        insights.push({
                            type: 'ai_consensus',
                            priority: 'high',
                            description: `High AI system consensus (${(correlation.systemConsensus * 100).toFixed(1)}%)`,
                            implications: 'Strong collaborative foundation - leverage for complex analysis'
                        });
                    }

                    if (correlation.synthesisAgreement > 70) {
                        insights.push({
                            type: 'synthesis_agreement',
                            priority: 'high',
                            description: `AI systems strongly agree with synthesis (${correlation.synthesisAgreement.toFixed(1)}% agreement)`,
                            implications: 'High confidence in synthesis results - excellent validation'
                        });
                    }
                }

                // Synthesis quality insights
                if (analysis.components.synthesisIntegration) {
                    const integration = analysis.components.synthesisIntegration;

                    if (integration.comprehensiveCoverage > 80) {
                        insights.push({
                            type: 'comprehensive_coverage',
                            priority: 'high',
                            description: `Synthesis provides comprehensive coverage (${integration.comprehensiveCoverage.toFixed(1)}%)`,
                            implications: 'Complete analysis achieved - maximize insight utilization'
                        });
                    }
                }

                // Predictive insights
                if (analysis.components.predictiveCorrelation) {
                    const predictive = analysis.components.predictiveCorrelation;

                    if (predictive.predictiveAccuracy > 70) {
                        insights.push({
                            type: 'predictive_accuracy',
                            priority: 'medium',
                            description: `High predictive accuracy (${predictive.predictiveAccuracy.toFixed(1)}%)`,
                            implications: 'Reliable forecasting - use predictions for planning'
                        });
                    }

                    if (predictive.riskAssessment.level === 'high') {
                        insights.push({
                            type: 'risk_warning',
                            priority: 'high',
                            description: 'High risk factors detected in system predictions',
                            implications: 'Monitor closely - consider contingency planning',
                            factors: predictive.riskAssessment.factors
                        });
                    }
                }

                return insights.sort((a, b) => {
                    const priorityOrder = { high: 3, medium: 2, low: 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                });
            },

            // Calculate correlation depth
            calculateCorrelationDepth: function(analysis) {
                let depth = 0;

                if (analysis.components.canvasEvolution) depth += 25;
                if (analysis.components.aiCorrelation) depth += 25;
                if (analysis.components.synthesisIntegration) depth += 25;
                if (analysis.components.predictiveCorrelation) depth += 25;

                return depth;
            },

            // Get current canvas data
            getCurrentCanvasData: function() {
                const canvasState = localStorage.getItem('canvas_evolution_data');
                if (!canvasState) return null;

                try {
                    return JSON.parse(canvasState);
                } catch (error) {
                    return null;
                }
            },

            // Get current AI data
            getCurrentAIData: function() {
                const aiMemory = localStorage.getItem('ai_memory_state');
                if (!aiMemory) return null;

                try {
                    return JSON.parse(aiMemory);
                } catch (error) {
                    return null;
                }
            },

            // Store analysis results
            storeAnalysisResults: function(analysis) {
                this.analysisCycles.push(analysis);

                // Keep only last 20 analysis cycles
                if (this.analysisCycles.length > 20) {
                    this.analysisCycles.shift();
                }

                // Store in localStorage
                localStorage.setItem('correlative_analysis_results', JSON.stringify({
                    latest: analysis,
                    history: this.analysisCycles,
                    timestamp: Date.now()
                }));
            },

            // Update analysis metrics
            updateAnalysisMetrics: function(analysis) {
                this.metrics.synthesisQuality = analysis.synthesisQuality;
                this.metrics.correlationDepth = analysis.correlationDepth;
                this.metrics.insightGeneration = analysis.insights.length;
                this.metrics.predictiveAccuracy = analysis.components.predictiveCorrelation ?
                    analysis.components.predictiveCorrelation.predictiveAccuracy : 0;
            },

            // Check for existing synthesis reports
            checkExistingSynthesisReports: function() {
                const synthesisReport = localStorage.getItem('synthesis_report');
                if (synthesisReport) {
                    // Trigger analysis for existing report
                    setTimeout(() => {
                        this.handleSynthesisReportGeneration();
                    }, 1000);
                }
            },

            // Schedule deep analysis
            scheduleDeepAnalysis: function() {
                // Perform deep analysis every 15 minutes
                setInterval(() => {
                    this.performScheduledAnalysis();
                }, 15 * 60 * 1000);
            },

            // Perform scheduled analysis
            performScheduledAnalysis: function() {
                try {
                    const canvasData = this.getCurrentCanvasData();
                    const aiData = this.getCurrentAIData();

                    if (canvasData || aiData) {
                        // Perform analysis even without new synthesis report
                        const analysis = this.performCorrelativeAnalysis(null, canvasData, aiData, null);
                        this.storeAnalysisResults(analysis);
                        this.updateAnalysisMetrics(analysis);

                        console.log('üîç Scheduled correlative analysis completed');
                    }
                } catch (error) {
                    console.warn('Scheduled correlative analysis failed:', error);
                }
            },

            // Get latest analysis results
            getLatestAnalysis: function() {
                return this.analysisCycles[this.analysisCycles.length - 1] || null;
            },

            // Get analysis insights
            getAnalysisInsights: function() {
                const latest = this.getLatestAnalysis();
                if (!latest) return null;

                return {
                    synthesisQuality: latest.synthesisQuality,
                    correlationDepth: latest.correlationDepth,
                    insightsCount: latest.insights.length,
                    topInsights: latest.insights.slice(0, 3),
                    lastAnalysis: new Date(latest.timestamp).toLocaleTimeString()
                };
            }
        };

        // Initialize correlative analysis framework
        correlativeAnalysisFramework.initialize();

        // Trigger correlative analysis with synthesis data
        function triggerCorrelativeAnalysis(canvasContent, aiMemory, synthesisContent, aiFeeds) {
            console.log('üî¨ TRIGGERING CORRELATIVE ANALYSIS:', {
                canvasContentLength: canvasContent?.length || 0,
                aiMemoryLength: aiMemory?.length || 0,
                synthesisContentLength: synthesisContent?.length || 0,
                aiFeedsLength: aiFeeds?.length || 0
            });

            try {
                // Perform correlative analysis using the framework
                const analysis = correlativeAnalysisFramework.performCorrelativeAnalysis(
                    synthesisContent, // synthesisReport
                    canvasContent,    // canvasData
                    aiFeeds,          // aiData
                    null              // predictions (not available)
                );

                // Update the correlative analysis display
                updateCorrelativeAnalysisDisplay(analysis);

                // Store results in localStorage for persistence
                localStorage.setItem('correlative_analysis_results', JSON.stringify(analysis));

                console.log('‚úÖ Correlative analysis completed successfully');

            } catch (error) {
                console.error('‚ùå Correlative analysis failed:', error);
                // Update display with error state
                const insightsElement = document.getElementById('correlativeAnalysisInsights');
                if (insightsElement) {
                    insightsElement.textContent = 'üî¨ DJINN COUNCIL CORRELATIVE ANALYSIS\n\n‚ùå Analysis Error: ' + error.message;
                }
            }
        }

        // Memory compression functions to prevent localStorage quota errors
        function compressMemoryForStorage(memory) {
            const compressed = {
                sessionId: memory.sessionId,
                sessionStart: memory.sessionStart,
                maxMemories: memory.maxMemories,
                members: {}
            };

            // Compress member reports by keeping only essential data
            Object.entries(memory.members).forEach(([key, member]) => {
                compressed.members[key] = {
                    specialization: member.specialization,
                    reports: member.reports.map(report => ({
                        reportId: report.reportId,
                        timestamp: report.timestamp,
                        analysis: report.analysis.substring(0, 500), // Truncate analysis
                        buildingOn: report.buildingOn,
                        metrics: report.metrics
                    })).slice(-10) // Keep only last 10 reports
                };
            });

            // Include only essential canvas AI data
            if (memory.canvasAISystems) {
                compressed.canvasAISystems = {};
                Object.entries(memory.canvasAISystems).forEach(([key, system]) => {
                    compressed.canvasAISystems[key] = {
                        interactions: system.interactions.slice(-5), // Keep only last 5 interactions
                        performance: system.performance
                    };
                });
            }

            return compressed;
        }

        function ultraCompressMemory(memory) {
            // Emergency ultra compression for quota exceeded scenarios
            return {
                sessionId: memory.sessionId,
                sessionStart: memory.sessionStart,
                maxMemories: memory.maxMemories,
                members: Object.fromEntries(
                    Object.entries(memory.members).map(([key, member]) => [
                        key,
                        {
                            specialization: member.specialization,
                            reports: member.reports.slice(-3).map(report => ({ // Keep only last 3 reports
                                reportId: report.reportId,
                                timestamp: report.timestamp,
                                analysis: report.analysis.substring(0, 150), // Severely truncate
                                buildingOn: report.buildingOn
                            }))
                        }
                    ])
                )
            };
        }

        // Store member report with full context
        function storeCouncilMemberReport(memberName, reportData) {
            const member = djinnCouncilMemory.members[memberName];

            // Add new report
            member.reports.push({
                reportId: member.reports.length + 1,
                timestamp: new Date().toISOString(),
                metrics: reportData.metrics || {},
                analysis: reportData.analysis || '',
                canvasDataAnalyzed: reportData.canvasData || '',
                buildingOn: member.reports.length > 0 ? `Reports 1-${member.reports.length}` : 'Initial analysis'
            });

            // Maintain 25 memory limit
            if (member.reports.length > djinnCouncilMemory.maxMemories) {
                member.reports.shift(); // Remove oldest
            }

            // Save to localStorage with compression to prevent quota errors
            try {
                const compressedMemory = compressMemoryForStorage(djinnCouncilMemory);
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(compressedMemory));
            } catch (error) {
                console.warn('Storage quota exceeded, compressing memory further:', error);
                const ultraCompressed = ultraCompressMemory(djinnCouncilMemory);
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(ultraCompressed));
            }
        }

        // Calculate comprehensive canvas statistics
        function calculateCanvasStats(content) {
            if (!content) return { length: 0, words: 0, lines: 0, complexity: 0, uniqueWords: 0, avgWordLength: 0, density: 0 };

            const words = content.trim().split(/\s+/).filter(w => w.length > 0);
            const lines = content.split('\n').filter(l => l.trim().length > 0);
            const uniqueWords = new Set(words.map(w => w.toLowerCase()));
            const avgWordLength = words.length > 0 ? words.reduce((sum, w) => sum + w.length, 0) / words.length : 0;

            // Complexity based on vocabulary richness, sentence structure, and content density
            const vocabularyRichness = uniqueWords.size / Math.max(words.length, 1);
            const sentenceComplexity = lines.length > 0 ? words.length / lines.length : 0;
            const contentDensity = content.replace(/\s/g, '').length / Math.max(content.length, 1);

            const complexity = Math.min(100, Math.round(
                (vocabularyRichness * 30) +
                (Math.min(sentenceComplexity, 20) * 2) +
                (contentDensity * 40) +
                (avgWordLength * 5)
            ));

            return {
                length: content.length,
                words: words.length,
                lines: lines.length,
                complexity: complexity,
                uniqueWords: uniqueWords.size,
                avgWordLength: Math.round(avgWordLength * 100) / 100,
                density: Math.round(contentDensity * 100)
            };
        }

        // Generate complete referential analysis for council member
        function generateReferentialAnalysis(memberName, currentCanvasData) {
            const member = djinnCouncilMemory.members[memberName];
            const allReports = member.reports;
            const canvasAIPerformance = djinnCouncilMemory.canvasAISystems;
            const canvasEvolution = djinnCouncilMemory.canvasEvolution;
            const canvasStats = calculateCanvasStats(currentCanvasData);

            // Get ALL actual localStorage data for analysis
            const aiMemoryData = localStorage.getItem('ai_memory_state') || '{}';
            const aiFeeds = localStorage.getItem('ai_feeds') || '[]';
            const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';
            const councilMemory = localStorage.getItem('djinn_council_complete_memory') || '{}';
            const intelligenceReports = localStorage.getItem('djinn_intelligence') || '[]';

            let parsedMemory = {}, parsedFeeds = [], parsedCouncilMemory = {}, parsedIntelligence = [];
            try {
                parsedMemory = JSON.parse(aiMemoryData);
                parsedFeeds = JSON.parse(aiFeeds);
                parsedCouncilMemory = JSON.parse(councilMemory);
                parsedIntelligence = JSON.parse(intelligenceReports);
            } catch (e) {
                console.warn('Failed to parse localStorage data for analysis:', e);
            }

            // GET REAL DATA - NO FABRICATION ALLOWED
            const realCanvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const realAIMemory = JSON.parse(localStorage.getItem('ai_memory_state') || '{}');
            const realAIFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');

            // Calculate actual metrics from real data
            const realMetrics = {
                canvasWordCount: realCanvasContent.split(/\s+/).length,
                totalAISystems: Object.keys(realAIMemory).length,
                activeSystems: Object.keys(realAIMemory).filter(system => {
                    const systemData = realAIMemory[system];
                    return systemData && systemData.conversationHistory && systemData.conversationHistory.length > 0;
                }).length,
                totalConversations: Object.values(realAIMemory).reduce((sum, system) => {
                    return sum + (system?.conversationHistory?.length || 0);
                }, 0),
                totalInsights: Object.values(realAIMemory).reduce((sum, system) => {
                    return sum + (system?.keyInsights?.length || 0);
                }, 0),
                feedCount: realAIFeeds.length,
                memoryDensity: Object.keys(realAIMemory).length > 0 ?
                    (Object.values(realAIMemory).reduce((sum, system) => sum + (system?.conversationHistory?.length || 0), 0) / Object.keys(realAIMemory).length) : 0
            };

            const analysisPrompt = `
DJINN COUNCIL MEMBER: ${memberName.toUpperCase().replace('_', ' & ')}
SPECIALIZATION: ${member.specialization}
SESSION: ${djinnCouncilMemory.sessionId}
REPORT #${allReports.length + 1} of max ${djinnCouncilMemory.maxMemories}

=== CURRENT CANVAS STATISTICS ===
- Content Length: ${canvasStats.length} characters
- Word Count: ${canvasStats.words} words
- Line Count: ${canvasStats.lines} lines
- Complexity Score: ${canvasStats.complexity}/100
- Unique Words: ${canvasStats.uniqueWords}
- Average Word Length: ${canvasStats.avgWordLength} characters
- Content Density: ${canvasStats.density}%

=== YOUR COMPLETE MEMORY BANK (${allReports.length} reports) ===
${allReports.map((report, i) => `
[REPORT ${report.reportId}] ${report.timestamp}
Building on: ${report.buildingOn}
Key Insights: ${report.analysis.substring(0, 300)}...
Critical Metrics: ${JSON.stringify(report.metrics)}
`).join('\n')}

=== ALL COUNCIL MEMBERS' MEMORY BANKS (Cross-Reference Available) ===
${Object.entries(djinnCouncilMemory.members).map(([councilMember, memberData]) => `
${councilMember.toUpperCase().replace('_', ' & ')} (${memberData.reports.length} reports):
Specialization: ${memberData.specialization}
Recent Reports: ${memberData.reports.slice(-3).map(r => `
  [${r.reportId}] ${r.timestamp}: ${r.analysis.substring(0, 200)}...`).join('')}
`).join('\n')}

=== COUNCIL CONSENSUS HISTORY ===
${djinnCouncilMemory.consensusHistory?.slice(-5).map(consensus => `
[${new Date(consensus.timestamp).toLocaleTimeString()}] Confidence: ${(consensus.confidence * 100).toFixed(1)}%
Theme: ${consensus.theme}
Summary: ${consensus.summary?.substring(0, 200)}...
Cross-Member Patterns: ${consensus.crossMemberPatterns || 'None identified'}
`).join('\n') || 'No consensus history available'}

=== REAL CALCULATED METRICS (Use these exact numbers) ===
- Canvas Word Count: ${realMetrics.canvasWordCount}
- Total AI Systems: ${realMetrics.totalAISystems}
- Active AI Systems: ${realMetrics.activeSystems}
- Total Conversations: ${realMetrics.totalConversations}
- Total Insights: ${realMetrics.totalInsights}
- Feed Count: ${realMetrics.feedCount}
- Memory Density: ${realMetrics.memoryDensity.toFixed(1)}

=== ACTUAL AI SYSTEM MEMORY DATA (localStorage 'ai_memory_state') ===
${Object.entries(parsedMemory).map(([systemName, systemData]) => {
    const conversations = systemData?.conversationHistory || [];
    const insights = systemData?.keyInsights || [];
    const lastAnalysis = systemData?.lastAnalysis || null;

    return `${systemName.toUpperCase()} SYSTEM MEMORY:
- Conversation History: ${conversations.length} entries
- Key Insights: ${insights.length} stored insights
- Last Analysis: ${lastAnalysis ? new Date(lastAnalysis.timestamp).toLocaleTimeString() : 'None'}
- Memory Data: ${JSON.stringify(systemData).length} characters
- Recent Conversations: ${conversations.slice(-3).map(c => `"${c.content?.substring(0, 100)}..."`).join('; ')}
- Recent Insights: ${insights.slice(-3).map(i => `"${i.insight?.substring(0, 100)}..."`).join('; ')}`;
}).join('\n')}

=== ACTUAL AI FEEDS DATA (localStorage 'ai_feeds') ===
Total Feed Entries: ${parsedFeeds.length}
Recent Feed Activity: ${parsedFeeds.slice(-5).map(feed => `[${new Date(feed.timestamp).toLocaleTimeString()}] ${feed.system}: ${feed.content?.substring(0, 100)}...`).join('\n')}

=== ACTUAL CANVAS CONTENT ===
Current Canvas: ${currentCanvasData.length} characters
Synthesis Content: ${synthesisContent.length} characters
Canvas Preview: "${currentCanvasData.substring(0, 300)}..."

=== PREVIOUS COUNCIL INTELLIGENCE REPORTS ===
Total Intelligence Reports: ${parsedIntelligence.length}
Recent Reports: ${parsedIntelligence.slice(-3).map(report => `[${new Date(report.timestamp).toLocaleTimeString()}] ${report.type}: ${report.summary?.substring(0, 100)}...`).join('\n')}

=== CANVAS AI SYSTEMS PERFORMANCE TRACKING ===
${Object.entries(canvasAIPerformance).map(([system, data]) => `
${system.toUpperCase()} SYSTEM:
- Total Tracked Interactions: ${data.interactions.length}
- Performance Status: ${data.interactions.length > 0 ? 'ACTIVE' : 'MONITORING'}
- Last Activity: ${data.interactions.length > 0 ? data.interactions[data.interactions.length - 1].timestamp : 'Awaiting first interaction'}
- Recent Activity: ${data.interactions.slice(-3).map(i => `[${new Date(i.timestamp).toLocaleTimeString()}] ${String(i.interaction || '').substring(0, 80)}...`).join(' | ')}
- Performance Metrics: ${data.interactions.length > 0 && data.interactions[data.interactions.length - 1].performance ?
    JSON.stringify(data.interactions[data.interactions.length - 1].performance.performanceMetrics) : 'Metrics will be calculated after first interaction'}
`).join('\n')}

=== CANVAS EVOLUTION TIMELINE (${canvasEvolution.length} snapshots) ===
${canvasEvolution.slice(-10).map((snap, i) => `
[${new Date(snap.timestamp).toLocaleTimeString()}] Complexity: ${snap.complexity}/100 | Content: "${snap.content.substring(0, 150)}..." | AI Memory Size: ${JSON.stringify(snap.aiMemoryState).length} chars
`).join('\n')}

=== CURRENT CANVAS DATA TO ANALYZE ===
${currentCanvasData}

=== ANALYSIS REQUIREMENTS ===
You are ${memberName.replace('_', ' & ')}, an expert AI analyst specializing in ${member.specialization}.

ANALYZE THE ACTUAL LOCALSTORAGE DATA PROVIDED ABOVE - this is real, stored data from the live system:
- Actual AI memory states with conversation histories and insights
- Real AI feed entries with timestamps and content
- Actual canvas content and synthesis data
- Previous intelligence reports and council findings

CRITICAL REQUIREMENTS:
1. Base your analysis ONLY on the real data provided above
2. DO NOT invent percentages, metrics, or performance data not shown
3. Reference specific entries from the actual localStorage data
4. Analyze trends in the actual conversation histories and insights
5. Cross-reference insights from other council members' reports when relevant
6. Build upon previous council consensus findings and patterns
7. Only discuss the 5 AI systems: NARRA, NAZAR, WHALE, DJINN, WATCHTOWER

CROSS-MEMBER COLLABORATION:
- Reference relevant insights from other council members when they relate to your specialization
- Build upon patterns identified in previous consensus reports
- Note where your analysis confirms, contradicts, or extends other members' findings
- Use the complete council memory bank to provide deeper, interconnected analysis

IMPORTANT DIFFERENTIATION REQUIREMENT:
You must clearly separate THREE DISTINCT LAYERS in your analysis:

LAYER 1 - AI SYSTEMS: ONLY the five real AI entities (narra, nazar, whale, djinn, watchtower) - their performance, memory states, interaction patterns, and system health.

LAYER 2 - CANVAS CONTENT: The data/content that exists within the canvas that these AI systems are analyzing and working with.

LAYER 3 - CONTENT EVOLUTION: How the canvas content changes over time through iterations as AI systems process and modify it.

DO NOT conflate these layers. When analyzing "system performance", talk ONLY about the AI systems themselves. When analyzing "content evolution", talk ONLY about how the canvas data changes over time.

Write your complete analysis report following this exact structure:

**SUMMARY**
[Write one paragraph summarizing your key findings about the REAL AI systems (Layer 1) and their actual performance data, SEPARATE from content analysis]

**ANALYSIS**
[Write one paragraph explaining your analytical approach, focusing on the actual AI system data (Layer 1) and memory contents, clearly differentiated from content evolution]

**FINDINGS**
- **AI Systems Performance:** [Describe REAL AI system status, activity levels, memory states, and operational health from Layer 1 data ONLY - ONLY mention the 5 real systems]
- **Canvas Content Evolution:** [Describe how canvas content (Layer 2) has changed over time based on the evolution timeline (Layer 3), SEPARATE from AI system performance]
- **AI-System Interaction Patterns:** [Identify patterns in how AI systems (Layer 1) interact with and process canvas content (Layer 2)]
- **Risk Assessment:** [Assess stability and potential issues in AI systems (Layer 1) and content evolution processes (Layer 3)]

**METRICS**
[Provide SPECIFIC numerical values 0-100 for each metric based on your analysis - no placeholders]

- AI System Coherence: [0-100] - [brief explanation with specific number]
- Content Evolution Rate: [0-100] - [brief explanation with specific number]
- AI-Content Interaction Density: [0-100] - [brief explanation with specific number]
- System Memory Utilization: [0-100] - [brief explanation with specific number]
- Content Stability Index: [0-100] - [brief explanation with specific number]

**CONCLUSIONS**
[Write one paragraph synthesizing what your analysis of the AI systems (Layer 1) and content evolution (Layer 3) means, keeping them clearly differentiated]

**ACTIONS**
1. [Specific recommendation for AI system (Layer 1) optimization or monitoring]
2. [Specific recommendation for content evolution (Layer 3) processes]
3. [Specific recommendation for AI-content interaction (Layer 1 + Layer 2) improvement]

Keep response concise (under 800 words). Be specific and avoid repetition. Start directly with **SUMMARY**.
`;

            return analysisPrompt;
        }

        // Track Canvas AI System Performance
        function trackCanvasAISystems() {
            try {
                // Get data from main canvas localStorage with cross-window access
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';

                console.log('üîç DJINN tracking canvas AI systems:', {
                    feedsCount: aiFeeds.length,
                    contentLength: canvasContent.length,
                    memoryKeys: Object.keys(JSON.parse(aiMemory || '{}'))
                });

                // Parse AI memory to get actual system data
                let parsedMemory = {};
                try {
                    parsedMemory = JSON.parse(aiMemory);
                } catch (e) {
                    console.warn('Failed to parse AI memory:', e);
                    parsedMemory = {};
                }

                // If memory is empty, try to get real-time canvas data
                if (Object.keys(parsedMemory).length === 0) {
                    console.log('üîÑ No AI memory found, attempting real-time canvas access...');

                    // Try to access parent window if in iframe
                    try {
                        if (window.parent && window.parent !== window) {
                            const parentMemory = window.parent.localStorage.getItem('ai_memory_state');
                            if (parentMemory) {
                                parsedMemory = JSON.parse(parentMemory);
                                console.log('‚úÖ Retrieved memory from parent window');
                            }
                        }
                    } catch (crossOriginError) {
                        console.warn('Cross-origin access blocked:', crossOriginError);
                    }
                }

                // Update system performance based on actual AI memory data
                Object.keys(djinnCouncilMemory.canvasAISystems).forEach(system => {
                    const systemData = parsedMemory[system];

                    if (systemData && typeof systemData === 'object') {
                        // Use actual memory data to determine activity
                        const hasMemory = systemData.conversationHistory && systemData.conversationHistory.length > 0;
                        const memoryCount = systemData.conversationHistory ? systemData.conversationHistory.length : 0;
                        const insightCount = systemData.keyInsights ? systemData.keyInsights.length : 0;
                        const responseCount = systemData.responseHistory ? systemData.responseHistory.length : 0;

                        // Add interaction record with real data
                        const interactionData = {
                            timestamp: new Date().toISOString(),
                            interaction: `Active: ${memoryCount} conversations, ${insightCount} insights, ${responseCount} responses`,
                            performance: calculateSystemPerformance(system, [{
                                content: JSON.stringify(systemData),
                                length: JSON.stringify(systemData).length,
                                hasMemory,
                                memoryCount,
                                insightCount,
                                responseCount
                            }])
                        };

                        djinnCouncilMemory.canvasAISystems[system].interactions.push(interactionData);

                        // Update performance metrics with real data
                        if (hasMemory) {
                            djinnCouncilMemory.canvasAISystems[system].lastActivity = new Date().toISOString();

                            // Ensure performanceMetrics object exists
                            if (!djinnCouncilMemory.canvasAISystems[system].performanceMetrics) {
                                djinnCouncilMemory.canvasAISystems[system].performanceMetrics = {};
                            }

                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.consistency = Math.min(95, 60 + (memoryCount * 5));
                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.relevance = Math.min(95, 50 + (insightCount * 8));
                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.taskEffectiveness = Math.min(95, 55 + (responseCount * 7));
                        }

                        console.log(`üìä ${system.toUpperCase()}: ${memoryCount} conversations, ${insightCount} insights, ${responseCount} responses`);

                        // Keep only recent interactions
                        if (djinnCouncilMemory.canvasAISystems[system].interactions.length > 10) {
                            djinnCouncilMemory.canvasAISystems[system].interactions =
                                djinnCouncilMemory.canvasAISystems[system].interactions.slice(-10);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è No valid data found for ${system}:`, systemData);
                    }
                });

                // Also process AI feeds for additional context
                if (aiFeeds && aiFeeds.length > 0) {
                    const systemInteractions = categorizeAIInteractions(aiFeeds);
                    Object.keys(systemInteractions).forEach(system => {
                        if (systemInteractions[system] && systemInteractions[system].length > 0) {
                            systemInteractions[system].forEach(feed => {
                                const interactionText = typeof feed === 'string' ? feed : (feed.content || JSON.stringify(feed));
                                djinnCouncilMemory.canvasAISystems[system].interactions.push({
                                    timestamp: new Date().toISOString(),
                                    interaction: `Feed: ${interactionText.substring(0, 100)}...`,
                                    performance: calculateSystemPerformance(system, [feed])
                                });
                            });
                        }
                    });
                }

                console.log('‚úÖ Canvas AI Systems tracking completed');

                // Track canvas evolution
                djinnCouncilMemory.canvasEvolution.push({
                    timestamp: new Date().toISOString(),
                    content: canvasContent,
                    aiMemoryState: aiMemory,
                    complexity: calculateContentComplexity(canvasContent)
                });

            } catch (error) {
                console.error('‚ùå Error tracking Canvas AI Systems:', error);

                // Log empty data state for debugging
                console.log('üìä Current canvas AI systems state:', djinnCouncilMemory.canvasAISystems);
            }

            // Keep evolution history manageable
            if (djinnCouncilMemory.canvasEvolution.length > 20) {
                djinnCouncilMemory.canvasEvolution = djinnCouncilMemory.canvasEvolution.slice(-20);
            }
        }

        function categorizeAIInteractions(aiFeeds) {
            // Parse AI feeds and categorize by system
            const systems = {
                narra: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('narra') ||
                    feed.content.toLowerCase().includes('pattern recognition')),
                nazar: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('nazar') ||
                    feed.content.toLowerCase().includes('consciousness')),
                whale: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('whale') ||
                    feed.content.toLowerCase().includes('deep interrogation')),
                djinn: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('djinn') ||
                    feed.content.toLowerCase().includes('governance')),
                watchtower: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('watchtower') ||
                    feed.content.toLowerCase().includes('monitoring'))
            };

            return systems;
        }

        function calculateSystemPerformance(system, interactions) {
            if (!interactions || interactions.length === 0) {
                return {
                    responseCount: 0,
                    avgResponseLength: 0,
                    lastActive: 'Never',
                    performanceMetrics: {
                        consistency: 0,
                        relevance: 0,
                        taskEffectiveness: 0
                    }
                };
            }

            // Calculate response length statistics
            const responseLengths = interactions.map(i => i.length || i.interaction?.length || 0);
            const avgResponseLength = responseLengths.reduce((a, b) => a + b, 0) / responseLengths.length;

            // Consistency: Standard deviation of response lengths (lower = more consistent)
            const lengthVariance = responseLengths.reduce((sum, len) => sum + Math.pow(len - avgResponseLength, 2), 0) / responseLengths.length;
            const lengthStdDev = Math.sqrt(lengthVariance);
            const consistency = Math.max(0, 100 - (lengthStdDev / Math.max(avgResponseLength, 1)) * 50);

            // Relevance: Based on presence of system-specific keywords and structured analysis
            let relevanceScore = 0;
            interactions.forEach(interaction => {
                const text = (interaction.interaction || '').toLowerCase();

                // Check for system-specific content
                const systemKeywords = {
                    narra: ['pattern', 'recognition', 'correlation', 'trend'],
                    nazar: ['consciousness', 'fractal', 'emotional', 'resonance'],
                    whale: ['deep', 'interrogation', 'memory', 'analysis'],
                    djinn: ['governance', 'strategic', 'authority', 'decision'],
                    watchtower: ['monitoring', 'metrics', 'performance', 'operational']
                };

                const keywords = systemKeywords[system] || [];
                const keywordMatches = keywords.filter(k => text.includes(k)).length;
                relevanceScore += (keywordMatches / keywords.length) * 25;

                // Check for structured analysis (metrics, numbered lists, etc.)
                if (/\[METRICS\]|\[ANALYSIS\]|\d+\.|\‚Ä¢|\-/.test(text)) relevanceScore += 20;
                if (text.length > 200) relevanceScore += 10; // Substantial content
                if (text.includes('**') || text.includes('##')) relevanceScore += 10; // Formatting
            });
            const relevance = Math.min(100, relevanceScore / interactions.length);

            // Task Effectiveness: Based on analysis quality and actionable insights
            let effectivenessScore = 0;
            interactions.forEach(interaction => {
                const text = (interaction.interaction || '').toLowerCase();

                // Check for analytical depth
                if (text.includes('analysis') || text.includes('assessment')) effectivenessScore += 15;
                if (/\d+[%]|\d+\/\d+|\d+\.\d+/.test(text)) effectivenessScore += 15; // Quantitative metrics
                if (text.includes('recommendation') || text.includes('conclusion')) effectivenessScore += 10;
                if (text.includes('trend') || text.includes('pattern')) effectivenessScore += 10;
                if (text.length > 300) effectivenessScore += 5; // Comprehensive response

                // Penalize for generic or repetitive content
                if (text.split(' ').length < 50) effectivenessScore -= 10;
                const repeatedWords = text.split(' ').filter((word, i, arr) => arr.indexOf(word) !== i);
                if (repeatedWords.length > text.split(' ').length * 0.3) effectivenessScore -= 15;
            });
            const taskEffectiveness = Math.max(0, Math.min(100, effectivenessScore / interactions.length));

            return {
                responseCount: interactions.length,
                avgResponseLength: Math.round(avgResponseLength),
                lastActive: interactions[interactions.length - 1]?.timestamp || 'Never',
                performanceMetrics: {
                    consistency: Math.round(consistency),
                    relevance: Math.round(relevance),
                    taskEffectiveness: Math.round(taskEffectiveness)
                }
            };
        }

        function calculateContentComplexity(content) {
            const words = content.split(' ').length;
            const sentences = content.split(/[.!?]+/).length;
            const avgWordLength = content.replace(/[^a-zA-Z]/g, '').length / words || 0;
            return Math.round((words * 0.1) + (sentences * 0.5) + (avgWordLength * 2));
        }


        // Enhanced surveillance between Canvas and Council
        function setupCrossWindowSurveillance() {
            console.log('üîó Setting up cross-window surveillance...');

            // Listen for canvas changes
            window.addEventListener('storage', function(e) {
                console.log(`üì° Storage event detected: ${e.key}`);

                if (e.key === 'sovereign_canvas_content') {
                    const newContent = e.newValue;
                    const timestamp = new Date().toISOString();

                    console.log('üìù Canvas content updated, length:', newContent ? newContent.length : 0);

                    // Track canvas evolution
                    djinnCouncilMemory.canvasEvolution.push({
                        timestamp: timestamp,
                        content: newContent,
                        changeType: 'content_update',
                        complexity: calculateContentComplexity(newContent)
                    });

                    // Trigger real-time analysis if significant change
                    if (isSignificantChange(newContent)) {
                        console.log('üö® Significant change detected, triggering analysis');
                        triggerRealTimeAnalysis();
                    }

                    // Update AI systems tracking
                    trackCanvasAISystems();
                }

                // Monitor AI memory state changes
                if (e.key === 'ai_memory_state') {
                    const newMemory = e.newValue;
                    console.log('üß† AI memory state updated:', newMemory ? Object.keys(JSON.parse(newMemory)).length : 0, 'systems');

                    // Update AI systems tracking immediately
                    trackCanvasAISystems();

                    // Trigger memory analysis
                    queueAnalysis('memory_update', { memory: newMemory, type: 'memory' });
                }

                // Monitor AI feeds
                if (e.key === 'ai_feeds') {
                    const newFeeds = e.newValue;
                    const feedsArray = newFeeds ? JSON.parse(newFeeds) : [];
                    console.log('üì° AI feeds updated:', feedsArray.length, 'feeds');

                    // Update AI systems tracking
                    trackCanvasAISystems();

                    // Trigger feed analysis
                    if (feedsArray.length > 0) {
                        queueAnalysis('new_feeds', { feeds: feedsArray, type: 'feeds' });
                    }
                }
            });
        }

        function testCrossWindowAccess() {
            try {
                // Test if we can access parent window data
                if (window.parent && window.parent !== window) {
                    const parentMemory = window.parent.localStorage.getItem('ai_memory_state');
                    return !!parentMemory;
                }

                // Test if we can access same-origin data
                return !!localStorage.getItem('ai_memory_state');
            } catch (error) {
                console.warn('Cross-window access test failed:', error);
                return false;
            }
        }

        function isSignificantChange(newContent) {
            const lastSnapshot = djinnCouncilMemory.canvasEvolution.slice(-2)[0];
            if (!lastSnapshot) return true;

            const wordCountDiff = Math.abs(
                newContent.split(' ').length - lastSnapshot.content.split(' ').length
            );

            return wordCountDiff > 50; // Significant if 50+ word difference
        }

        function triggerRealTimeAnalysis() {
            // Auto-trigger council analysis for significant canvas changes
            console.log('üö® Significant canvas change detected - triggering council analysis');

            // Update UI indicator
            const indicator = document.getElementById('realtime-indicator');
            if (indicator) {
                indicator.textContent = 'üî¥ Real-time Analysis Triggered';
                indicator.style.color = '#ff6b6b';
            }
        }

        // Robust error handling for AI failures
        function handleAnalysisError(memberName, error) {
            console.error(`Council Member ${memberName} Analysis Failed:`, error);

            // Store error in memory
            const errorReport = {
                timestamp: new Date().toISOString(),
                memberName: memberName,
                error: error.message,
                recovery: 'fallback_analysis_initiated'
            };

            djinnCouncilMemory.errors = djinnCouncilMemory.errors || [];
            djinnCouncilMemory.errors.push(errorReport);

            // No fallback - throw the error to be handled upstream
            throw error;
        }

        // System health monitoring
        function systemHealthMonitor() {
            // Get current AI memory state
            const aiMemoryData = localStorage.getItem('ai_memory_state');
            let parsedMemory = {};
            let aiSystemsActive = 0;

            try {
                parsedMemory = JSON.parse(aiMemoryData || '{}');
                aiSystemsActive = Object.keys(parsedMemory).filter(system => {
                    const systemData = parsedMemory[system];
                    return systemData &&
                           systemData.conversationHistory &&
                           systemData.conversationHistory.length > 0;
                }).length;
            } catch (e) {
                console.warn('Failed to parse AI memory in health monitor:', e);
            }

            const healthCheck = {
                timestamp: new Date().toISOString(),
                canvasConnection: !!localStorage.getItem('sovereign_canvas_content'),
                aiMemoryConnection: !!localStorage.getItem('ai_memory_state'),
                aiSystemsActive: aiSystemsActive,
                totalAISystems: Object.keys(parsedMemory).length,
                councilMemoryIntegrity: true,
                localStorage: isLocalStorageAvailable(),
                crossWindowAccess: testCrossWindowAccess()
            };

            console.log('üè• Health check:', healthCheck);

            djinnCouncilMemory.systemHealth = djinnCouncilMemory.systemHealth || [];
            djinnCouncilMemory.systemHealth.push(healthCheck);

            // Keep only last 10 health checks
            if (djinnCouncilMemory.systemHealth.length > 10) {
                djinnCouncilMemory.systemHealth.shift();
            }

            // Update UI dashboard
            // updateStatusDashboard(healthCheck); // Removed - using compact display
            updateCompactMemoryStatus();

            return healthCheck;
        }


        function isLocalStorageAvailable() {
            try {
                const test = '__localStorage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Clear corrupted memory
        function clearCouncilMemory() {
            // Clear localStorage
            localStorage.removeItem('djinn_council_complete_memory');
            localStorage.removeItem('djinn_intelligence');
            localStorage.removeItem('djinn_intelligence_backup');

            // Reset in-memory objects
            currentAIMemory = '{}';

            // Reset the djinnCouncilMemory object to fresh state
            Object.keys(djinnCouncilMemory.members).forEach(memberKey => {
                djinnCouncilMemory.members[memberKey].reports = [];
            });
            djinnCouncilMemory.canvasEvolution = [];
            djinnCouncilMemory.consensusHistory = [];
            djinnCouncilMemory.systemHealth = [];
            djinnCouncilMemory.errors = [];
            djinnCouncilMemory.sessionId = generateSessionId();
            djinnCouncilMemory.sessionStart = new Date().toISOString();

            // Clear all member displays
            ['pattern-analysis', 'wisdom-analysis', 'paradox-analysis', 'boundaries-analysis', 'memory-analysis'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = 'Awaiting analysis...';
            });

            // Reset status indicators
            ['pattern-status', 'wisdom-status', 'paradox-status', 'boundaries-status', 'memory-status'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = 'STANDBY';
            });

            // Update memory display
            updateCompactMemoryStatus();

            console.log('‚úÖ DJINN Council memory completely reset - fresh session started');
        }

        // Enhanced intelligence reporting
        function generateIntelligencePackage() {
            const intelligence = {
                sessionMetadata: {
                    sessionId: djinnCouncilMemory.sessionId,
                    startTime: djinnCouncilMemory.sessionStart,
                    duration: Date.now() - new Date(djinnCouncilMemory.sessionStart).getTime(),
                    totalReports: Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0)
                },

                memberAnalytics: Object.entries(djinnCouncilMemory.members).map(([name, data]) => ({
                    member: name,
                    specialization: data.specialization,
                    reportCount: data.reports.length,
                    performanceMetrics: calculateMemberPerformance(data.reports),
                    keyInsights: extractKeyInsights(data.reports)
                })),

                systemPerformance: {
                    canvasAISystems: djinnCouncilMemory.canvasAISystems,
                    canvasEvolution: djinnCouncilMemory.canvasEvolution,
                    consensusPatterns: analyzeConsensusPatterns(),
                    emergentThemes: identifyEmergentThemes()
                },

                recommendations: generateStrategicRecommendations(),

                riskAssessment: {
                    systemHealth: djinnCouncilMemory.systemHealth?.slice(-5) || [],
                    errorLog: djinnCouncilMemory.errors || [],
                    stabilityMetrics: calculateStabilityMetrics()
                }
            };

            return intelligence;
        }

        function calculateMemberPerformance(reports) {
            return {
                avgReportLength: reports.reduce((sum, r) => sum + r.analysis.length, 0) / reports.length || 0,
                reportConsistency: calculateReportConsistency(reports),
                insightQuality: calculateInsightQuality(reports)
            };
        }

        function extractKeyInsights(reports) {
            // Extract key insights from reports
            const insights = [];
            reports.forEach(report => {
                const lines = report.analysis.split('\n');
                lines.forEach(line => {
                    if (line.includes('**') || line.includes('Key:') || line.includes('Insight:')) {
                        insights.push(line.trim());
                    }
                });
            });
            return insights.slice(-10); // Last 10 insights
        }

        function analyzeConsensusPatterns() {
            // Analyze patterns across consensus history
            return djinnCouncilMemory.consensusHistory.slice(-5).map(c => ({
                timestamp: c.timestamp,
                commonThemes: c.crossReferences || {},
                memberAgreement: Object.keys(c.memberAnalyses || {}).length
            }));
        }

        function identifyEmergentThemes() {
            // Identify themes that emerge across reports
            const allThemes = [];
            Object.values(djinnCouncilMemory.members).forEach(member => {
                member.reports.forEach(report => {
                    // Simple theme extraction - can be enhanced
                    const words = report.analysis.toLowerCase().split(' ');
                    const themes = words.filter(word => word.length > 6); // Longer words as themes
                    allThemes.push(...themes);
                });
            });

            // Count theme frequency
            const themeCount = {};
            allThemes.forEach(theme => {
                themeCount[theme] = (themeCount[theme] || 0) + 1;
            });

            return Object.entries(themeCount)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
        }

        function generateStrategicRecommendations() {
            const recommendations = [];

            // Based on system health
            const recentHealth = djinnCouncilMemory.systemHealth.slice(-3);
            if (recentHealth.some(h => !h.canvasConnection)) {
                recommendations.push("Improve Canvas connection stability");
            }

            // Based on error patterns
            const recentErrors = djinnCouncilMemory.errors?.slice(-5) || [];
            if (recentErrors.length > 2) {
                recommendations.push("Address recurring analysis errors");
            }

            // Based on performance
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);
            if (totalReports > 20) {
                recommendations.push("Consider memory optimization for long sessions");
            }

            return recommendations;
        }

        function calculateStabilityMetrics() {
            const healthChecks = djinnCouncilMemory.systemHealth.slice(-10);
            const errorCount = djinnCouncilMemory.errors?.length || 0;

            return {
                uptimePercentage: healthChecks.filter(h => h.localStorage).length / healthChecks.length * 100,
                errorRate: errorCount / Math.max(1, healthChecks.length),
                memoryIntegrity: healthChecks.filter(h => h.councilMemoryIntegrity).length / healthChecks.length * 100
            };
        }

        // Helper functions for performance calculations
        function calculateReportConsistency(reports) {
            if (reports.length < 2) return 100;
            const lengths = reports.map(r => r.analysis.length);
            const avgLength = lengths.reduce((a, b) => a + b) / lengths.length;
            const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avgLength, 2), 0) / lengths.length;
            return Math.max(0, 100 - (Math.sqrt(variance) / avgLength * 100));
        }

        function calculateInsightQuality(reports) {
            let qualityScore = 0;
            reports.forEach(report => {
                // Simple quality metrics
                if (report.analysis.includes('**')) qualityScore += 10; // Structured formatting
                if (/\d+[%\/]\d+|\d+\/\d+|\d+%|\d+\.\d+/.test(report.analysis)) qualityScore += 10; // Metrics
                if (report.analysis.length > 500) qualityScore += 5; // Substantial content
            });
            return Math.min(100, qualityScore / reports.length);
        }

        // Initialize complete memory system
        function initializeDjinnCouncilMemory() {
            // Load existing memory or create fresh session
            const existingMemory = localStorage.getItem('djinn_council_complete_memory');

            if (existingMemory) {
                Object.assign(djinnCouncilMemory, JSON.parse(existingMemory));
            } else {
                // Fresh session - save initial state
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(djinnCouncilMemory));
            }

            // Track Canvas AI performance
            trackCanvasAISystems();

            // Update UI
            // displayMemoryBank(); // Removed - using inline elements in canvas panel

            // Setup cross-window surveillance
            setupCrossWindowSurveillance();

            // Update status every 30 seconds
            setInterval(() => systemHealthMonitor(), 30000);
            systemHealthMonitor(); // Initial update

            console.log(`DJINN Council Memory Initialized - Session: ${djinnCouncilMemory.sessionId}`);
        }

        // Add memory visualization to UI
        function displayMemoryBank() {
            const memoryDisplay = document.createElement('div');
            memoryDisplay.id = 'council-memory-bank';
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, member) => sum + member.reports.length, 0);
            memoryDisplay.innerHTML = `
                <h3>üß† Memory</h3>
                <div class="session-info">
                    ${djinnCouncilMemory.sessionId.split('_')[1]}<br>
                    ${totalReports} reports
                </div>
                <div class="member-memories">
                    ${Object.entries(djinnCouncilMemory.members).map(([name, data]) => 
                        `${name.charAt(0).toUpperCase()}:${data.reports.length}`
                    ).join(' ')}
                </div>
            `;

            // Add to header
            const headerElement = document.querySelector('.djinn-header');
            if (headerElement && !document.getElementById('council-memory-bank')) {
                headerElement.appendChild(memoryDisplay);
            }
        }

        // Real-time status dashboard
        // function createStatusDashboard() { // Removed - using inline elements
        //     const dashboard = document.createElement('div');
        //     dashboard.id = 'council-status-dashboard';
        //     dashboard.innerHTML = `
        //         <h4>üß† Memory Status</h4>
        //         <div id="memory-usage">Loading...</div>
        //         <h4>ü§ñ Canvas AI</h4>
        //         <div id="ai-systems-status">Loading...</div>
        //         <h4>‚ö° Performance</h4>
        //         <div id="performance-metrics">Loading...</div>
        //         <h4>üîç System Health</h4>
        //         <div id="system-health">Loading...</div>
        //     `;

        //     // Add to container
        //     const container = document.querySelector('.djinn-container');
        //     if (container && !document.getElementById('council-status-dashboard')) {
        //         container.insertAdjacentElement('afterbegin', dashboard);
        //     }

        //     // Update dashboard every 30 seconds
        //     setInterval(() => systemHealthMonitor(), 30000);
        //     systemHealthMonitor(); // Initial update
        // }

        // Compact memory status toggle
        function toggleMemoryDetails() {
            const details = document.getElementById('memoryDetails');
            if (details) {
                details.style.display = details.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Update compact memory status
        function updateCompactMemoryStatus() {
            const summaryEl = document.getElementById('memorySummary');
            const fullEl = document.getElementById('fullMemoryStatus');

            if (!summaryEl || !fullEl) return;

            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);
            const sessionId = djinnCouncilMemory.sessionId.split('_')[1];
            const sessionDuration = Math.round((Date.now() - new Date(djinnCouncilMemory.sessionStart).getTime()) / 1000 / 60);

            // Summary line
            summaryEl.textContent = `${totalReports} reports, ${sessionDuration}m active`;

            // Full details (hidden by default)
            const memberCounts = Object.entries(djinnCouncilMemory.members).map(([name, data]) =>
                `${name.charAt(0).toUpperCase()}: ${data.reports.length}`
            ).join(' ');

            const aiSystems = Object.entries(djinnCouncilMemory.canvasAISystems).map(([name, data]) =>
                `${name.toUpperCase()}: ${data.interactions.length}`
            ).join(', ');

            // Add AI Memory Status details using same data as council prompts
            let aiMemoryDetails = '';
            try {
                const aiMemoryData = localStorage.getItem('ai_memory_state') || '{}';
                const parsedMemory = JSON.parse(aiMemoryData);
                if (parsedMemory && typeof parsedMemory === 'object') {
                    aiMemoryDetails = '<div style="margin-bottom: 8px;"><strong>üß† Canvas AI Memory Status:</strong><br><small style="color: #888;">Live memory data from canvas AI systems</small><br>';
                    Object.keys(parsedMemory).forEach(system => {
                        const memory = parsedMemory[system];
                        const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                        const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                        const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                        // Use same logic as generateReferentialAnalysis
                        let status, processingLevel;
                        if (hasMemory) {
                            status = '‚úÖ Active';
                            processingLevel = memoryCount > 10 ? 'High' : memoryCount > 5 ? 'Moderate' : 'Low';
                        } else {
                            status = '‚è≥ Monitoring';
                            processingLevel = 'Ready';
                        }

                        aiMemoryDetails += `${system.toUpperCase()}: ${status} (${memoryCount} conversation responses, ${insightCount} key insights)<br>`;
                    });
                    aiMemoryDetails += '</div>';
                }
            } catch (e) {
                aiMemoryDetails = '<div style="margin-bottom: 8px;"><strong>üß† Canvas AI Memory Status:</strong><br><small style="color: #888;">Unable to read canvas AI memory data</small></div>';
            }

            fullEl.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>üìä Session Summary:</strong><br>
                <small style="color: #888;">Total council analysis reports: ${totalReports} | Session active for ${sessionDuration} minutes</small></div>

                <div style="margin-bottom: 8px;"><strong>üë• Council Members:</strong><br>
                <small style="color: #888;">Pattern & Witness: ${djinnCouncilMemory.members.pattern.reports.length} reports | Recursive Wisdom: ${djinnCouncilMemory.members.wisdom.reports.length} reports | Creative Paradox: ${djinnCouncilMemory.members.paradox.reports.length} reports<br>
                Sovereign Boundaries: ${djinnCouncilMemory.members.boundaries.reports.length} reports | Echo & Memory: ${djinnCouncilMemory.members.memory.reports.length} reports</small></div>

                <div style="margin-bottom: 8px;"><strong>ü§ñ Canvas AI Systems:</strong><br>
                <small style="color: #888;">Tracked interactions with canvas AI systems (NARRA, NAZAR, WHALE, DJINN, WATCHTOWER)</small></div>

                ${aiMemoryDetails}

                <div style="margin-bottom: 8px;"><strong>‚è∞ Session Started:</strong><br>
                <small style="color: #888;">${new Date(djinnCouncilMemory.sessionStart).toLocaleString()}</small></div>

                <div><strong>üíö System Health:</strong><br>
                <small style="color: #888;">Memory integrity: OK | Error count: ${djinnCouncilMemory.errors?.length || 0}</small></div>
            `;
        }

        // Add memory controls to UI
        function addMemoryControls() {
            const controlsHtml = `
                <div class="memory-controls">
                    <button onclick="clearCouncilMemory()" class="btn-clear-memory">
                        üóëÔ∏è Start Fresh Session
                    </button>
                    <button onclick="exportMemoryData()" class="btn-export-memory">
                        üíæ Export Memory Bank
                    </button>
                </div>
            `;

            const controlsElement = document.querySelector('.djinn-controls');
            if (controlsElement && !document.querySelector('.memory-controls')) {
                controlsElement.insertAdjacentHTML('beforeend', controlsHtml);
            }
        }

        function exportMemoryData() {
            const dataStr = JSON.stringify(djinnCouncilMemory, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `djinn-council-memory-${djinnCouncilMemory.sessionId}.json`;
            link.click();
        }

        // Auto-save intelligence every 5 reports
        function autoSaveIntelligence() {
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);

            if (totalReports > 0 && totalReports % 5 === 0) {
                const intelligence = generateIntelligencePackage();
                localStorage.setItem('djinn_council_intelligence_backup', JSON.stringify(intelligence));
                console.log(`üìä Intelligence package auto-saved at ${totalReports} reports`);
            }
        }

        function extractMetricsFromAnalysis(analysis) {
            const metrics = {};

            // Extract numeric metrics
            const metricPatterns = {
                complexity: /complexity:?\s*(\d+)/i,
                density: /density:?\s*(\d+)/i,
                index: /index:?\s*(\d+)/i,
                rate: /rate:?\s*(\d+(?:\.\d+)?)/i,
                percentage: /(\d+(?:\.\d+)?)%/g
            };

            Object.entries(metricPatterns).forEach(([key, pattern]) => {
                const matches = analysis.match(pattern);
                if (matches) {
                    metrics[key] = matches.map(m => parseFloat(m.replace('%', '')));
                }
            });

            return metrics;
        }

        // ========================================
        // MAXIMIZE FUNCTIONALITY - EXACTLY LIKE CANVAS
        // ========================================

        function addMaximizeFeature() {
            // Find and add maximize buttons to all panels
            setTimeout(() => {
                // Canvas Surveillance
                const surveillance = document.querySelector('.canvas-surveillance');
                if (surveillance && !surveillance.querySelector('.panel-maximize-btn')) {
                    surveillance.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Surveillance';
                    btn.onclick = function() { toggleMaximize(surveillance, btn, 'Surveillance'); };
                    surveillance.insertBefore(btn, surveillance.firstChild);
                }

                // Council Consensus
                const consensus = document.querySelector('.council-consensus');
                if (consensus && !consensus.querySelector('.panel-maximize-btn')) {
                    consensus.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Consensus';
                    btn.onclick = function() { toggleMaximize(consensus, btn, 'Consensus'); };
                    consensus.insertBefore(btn, consensus.firstChild);
                }

                // Intelligence Report
                const intelligence = document.querySelector('.intelligence-report');
                if (intelligence && !intelligence.querySelector('.panel-maximize-btn')) {
                    intelligence.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Intelligence';
                    btn.onclick = function() { toggleMaximize(intelligence, btn, 'Intelligence'); };
                    intelligence.insertBefore(btn, intelligence.firstChild);
                }

                // Add to each council member
                document.querySelectorAll('.council-member').forEach((member, index) => {
                    if (!member.querySelector('.panel-maximize-btn')) {
                        member.style.position = 'relative';
                        const btn = document.createElement('button');
                        btn.className = 'panel-maximize-btn';
                        btn.innerHTML = '‚õ∂';
                        btn.title = 'Maximize Member';
                        btn.onclick = function() { toggleMaximize(member, btn, 'Member'); };
                        member.insertBefore(btn, member.firstChild);
                    }
                });

                console.log('Maximize buttons added to DJINN panels');
            }, 1000); // Wait for DOM to fully load
        }

        function toggleMaximize(panel, btn, title) {
            if (panel.classList.contains('panel-maximized')) {
                // Restore panel
                panel.classList.remove('panel-maximized');
                document.body.classList.remove('has-maximized-panel');
                btn.innerHTML = '‚õ∂';
                btn.title = `Maximize ${title}`;
                
                // Reset any inline styles that might have been added
                panel.style.display = '';
                panel.style.position = '';
                panel.style.zIndex = '';
                
                // Show all panels
                document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .djinn-header, .djinn-controls').forEach(p => {
                    p.style.display = '';
                    p.style.position = '';
                    p.style.zIndex = '';
                });
                
                // Show and reset council containers
                document.querySelectorAll('.council-left, .council-right').forEach(c => {
                    c.style.display = '';
                    c.style.position = '';
                    c.style.zIndex = '';
                    c.classList.remove('has-maximized-child');
                });
                
                // Show all council members
                document.querySelectorAll('.council-member').forEach(m => {
                    m.style.display = '';
                    m.style.position = '';
                    m.style.zIndex = '';
                });

                // Restore NEW indicators when restored
                const newIndicators = panel.querySelectorAll('.new-indicator');
                newIndicators.forEach(indicator => {
                    indicator.style.display = '';
                });
                
                // Restore scroll position
                if (panel.savedScrollTop !== undefined) {
                    const scrollable = panel.querySelector('.data-feed, .member-content, textarea');
                    if (scrollable) {
                        scrollable.scrollTop = panel.savedScrollTop;
                    }
                }
            } else {
                // Save scroll position
                const scrollable = panel.querySelector('.data-feed, .member-content, textarea');
                if (scrollable) {
                    panel.savedScrollTop = scrollable.scrollTop;
                }
                
                // Maximize panel
                panel.classList.add('panel-maximized');
                document.body.classList.add('has-maximized-panel');
                btn.innerHTML = '‚õ∑';
                btn.title = `Restore ${title}`;

                // Hide NEW indicators when maximized
                const newIndicators = panel.querySelectorAll('.new-indicator');
                newIndicators.forEach(indicator => {
                    indicator.style.display = 'none';
                });
                
                // If maximizing a council member, ensure it's visible
                if (panel.classList.contains('council-member')) {
                    // Ensure the panel itself is displayed properly
                    panel.style.display = 'flex';
                    panel.style.flexDirection = 'column';
                    
                    // Make member content visible and properly sized
                    const memberContent = panel.querySelector('.member-content');
                    if (memberContent) {
                        memberContent.style.display = 'block';
                        memberContent.style.visibility = 'visible';
                        memberContent.style.flex = '1';
                    }
                    
                    // Make header visible
                    const memberHeader = panel.querySelector('.member-header');
                    if (memberHeader) {
                        memberHeader.style.display = 'flex';
                        memberHeader.style.visibility = 'visible';
                    }
                    
                    // Hide other panels but keep parent container
                    document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .djinn-header, .djinn-controls').forEach(p => {
                        p.style.display = 'none';
                    });
                    
                    // Hide other council containers
                    document.querySelectorAll('.council-left, .council-right').forEach(c => {
                        if (!c.contains(panel)) {
                            c.style.display = 'none';
                        } else {
                            // Mark parent as having maximized child
                            c.classList.add('has-maximized-child');
                        }
                    });
                    
                    // Hide other council members
                    document.querySelectorAll('.council-member').forEach(m => {
                        if (m !== panel) {
                            m.style.display = 'none';
                        }
                    });
                } else {
                    // Normal panel maximize behavior
                    document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .djinn-header, .djinn-controls').forEach(p => {
                        if (p !== panel) {
                            p.style.display = 'none';
                        }
                    });
                    
                    // Hide council containers for non-member panels
                    document.querySelectorAll('.council-left, .council-right').forEach(c => {
                        c.style.display = 'none';
                    });
                }
            }
        }

        // ========================================
        // DIFFERENTIAL ANALYSIS ENGINE
        // ========================================

        // Enhanced canvas evolution tracking
        const canvasEvolutionTracker = {
            history: [],
            maxHistorySize: 50,
            lastAnalysis: null,

            // Store canvas state snapshot
            snapshot: function(content, timestamp = Date.now()) {
                const snapshot = {
                    timestamp,
                    content,
                    hash: this.hashContent(content),
                    metrics: this.calculateMetrics(content),
                    changes: this.lastAnalysis ? this.calculateChanges(this.lastAnalysis, content) : null
                };

                this.history.unshift(snapshot);

                // Maintain history size limit
                if (this.history.length > this.maxHistorySize) {
                    this.history = this.history.slice(0, this.maxHistorySize);
                }

                this.lastAnalysis = snapshot;
                return snapshot;
            },

            // Calculate comprehensive content metrics
            calculateMetrics: function(content) {
                const words = content.trim().split(/\s+/).filter(w => w.length > 0);
                const lines = content.split('\n');
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);

                return {
                    characters: content.length,
                    words: words.length,
                    lines: lines.length,
                    sentences: sentences.length,
                    paragraphs: paragraphs.length,
                    avgWordLength: words.length > 0 ? (words.join('').length / words.length).toFixed(1) : 0,
                    avgSentenceLength: sentences.length > 0 ? (words.length / sentences.length).toFixed(1) : 0,
                    complexity: this.calculateComplexity(content)
                };
            },

            // Calculate detailed changes between two content states
            calculateChanges: function(previousSnapshot, currentContent) {
                const prevContent = previousSnapshot.content;
                const changes = {
                    additions: 0,
                    deletions: 0,
                    modifications: 0,
                    netChange: currentContent.length - prevContent.length,
                    timeDelta: Date.now() - previousSnapshot.timestamp
                };

                // Simple diff analysis (can be enhanced with more sophisticated algorithms)
                const prevWords = prevContent.split(/\s+/);
                const currWords = currentContent.split(/\s+/);

                // Calculate word-level changes
                const addedWords = currWords.filter(word => !prevWords.includes(word));
                const removedWords = prevWords.filter(word => !currWords.includes(word));

                changes.additions = addedWords.length;
                changes.deletions = removedWords.length;
                changes.modifications = Math.abs(changes.netChange) - (changes.additions + changes.deletions);

                // Calculate change velocity (characters per minute)
                changes.velocity = changes.timeDelta > 0 ?
                    (Math.abs(changes.netChange) / (changes.timeDelta / 60000)).toFixed(2) : 0;

                return changes;
            },

            // Calculate content complexity score
            calculateComplexity: function(content) {
                if (!content || content.length === 0) return 0;

                const words = content.split(/\s+/).filter(w => w.length > 0);
                const uniqueWords = new Set(words.map(w => w.toLowerCase()));
                const avgWordLength = words.length > 0 ? words.join('').length / words.length : 0;
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);

                // Complexity factors
                const vocabularyRichness = uniqueWords.size / words.length;
                const sentenceVariability = sentences.length > 1 ?
                    this.calculateStandardDeviation(sentences.map(s => s.trim().split(/\s+/).length)) : 0;
                const structuralDensity = (content.match(/[\n\r]/g) || []).length / content.length;

                return ((vocabularyRichness * 0.4) + (sentenceVariability * 0.3) + (structuralDensity * 0.3)).toFixed(3);
            },

            // Calculate standard deviation for sentence variability
            calculateStandardDeviation: function(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const squareDiffs = values.map(value => Math.pow(value - mean, 2));
                const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
                return Math.sqrt(avgSquareDiff);
            },

            // Generate evolution insights
            generateInsights: function() {
                if (this.history.length < 2) return null;

                const recent = this.history.slice(0, 5); // Last 5 snapshots
                const insights = {
                    trend: this.analyzeTrend(recent),
                    patterns: this.identifyPatterns(recent),
                    anomalies: this.detectAnomalies(recent),
                    predictions: this.generatePredictions(recent)
                };

                return insights;
            },

            // Analyze content evolution trends
            analyzeTrend: function(recentSnapshots) {
                if (recentSnapshots.length < 2) return 'insufficient_data';

                const changes = recentSnapshots.slice(0, -1).map((snapshot, i) =>
                    snapshot.changes ? snapshot.changes.netChange : 0
                );

                const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
                const velocities = changes.map(change => Math.abs(change));

                if (avgChange > 50) return 'expanding';
                if (avgChange < -50) return 'contracting';
                if (velocities.every(v => v < 10)) return 'stable';
                return 'evolving';
            },

            // Identify evolution patterns
            identifyPatterns: function(recentSnapshots) {
                const patterns = [];

                // Check for cyclical patterns
                const lengths = recentSnapshots.map(s => s.metrics.characters);
                if (lengths.length >= 4) {
                    const diffs = lengths.slice(1).map((len, i) => len - lengths[i]);
                    if (diffs.every(diff => Math.abs(diff) < 20)) {
                        patterns.push('stable_growth');
                    }
                }

                // Check for burst activity
                const velocities = recentSnapshots
                    .filter(s => s.changes)
                    .map(s => parseFloat(s.changes.velocity));

                if (velocities.some(v => v > 100)) {
                    patterns.push('burst_activity');
                }

                return patterns;
            },

            // Detect anomalous changes
            detectAnomalies: function(recentSnapshots) {
                if (recentSnapshots.length < 3) return [];

                const changes = recentSnapshots
                    .filter(s => s.changes)
                    .map(s => Math.abs(s.changes.netChange));

                if (changes.length === 0) return [];

                const mean = changes.reduce((a, b) => a + b, 0) / changes.length;
                const stdDev = Math.sqrt(
                    changes.map(change => Math.pow(change - mean, 2)).reduce((a, b) => a + b, 0) / changes.length
                );

                return changes
                    .map((change, i) => ({ change, index: i }))
                    .filter(item => Math.abs(item.change - mean) > (2 * stdDev))
                    .map(item => `Anomalous change at snapshot ${item.index}: ${item.change} characters`);
            },

            // Generate evolution predictions
            generatePredictions: function(recentSnapshots) {
                if (recentSnapshots.length < 3) return null;

                const trends = recentSnapshots.slice(0, 3).map(s => ({
                    length: s.metrics.characters,
                    velocity: s.changes ? parseFloat(s.changes.velocity) : 0
                }));

                const avgVelocity = trends.reduce((sum, t) => sum + t.velocity, 0) / trends.length;
                const predictedLength = trends[0].length + (avgVelocity * 5); // 5 minute prediction

                return {
                    predictedLength: Math.max(0, Math.round(predictedLength)),
                    confidence: this.calculatePredictionConfidence(trends),
                    timeHorizon: '5_minutes'
                };
            },

            // Calculate prediction confidence
            calculatePredictionConfidence: function(trends) {
                const velocities = trends.map(t => t.velocity);
                const mean = velocities.reduce((a, b) => a + b, 0) / velocities.length;
                const variance = velocities.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / velocities.length;

                // Lower variance = higher confidence
                return Math.max(0, Math.min(100, 100 - (variance / 10)));
            },

            // Simple content hashing for change detection
            hashContent: function(content) {
                let hash = 0;
                for (let i = 0; i < content.length; i++) {
                    const char = content.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString();
            }
        };

        // ========================================
        // CANVAS SURVEILLANCE FUNCTIONS
        // ========================================

        function updateCanvasMonitor() {
            try {
                // Get ALL data sources for comprehensive monitoring
                let canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';

                if (!canvasContent) canvasContent = '';

                // ========================================
                // INTEGRATE DIFFERENTIAL ANALYSIS
                // ========================================

                // Create evolution snapshot
                const currentSnapshot = canvasEvolutionTracker.snapshot(canvasContent);

                // Generate evolution insights
                const evolutionInsights = canvasEvolutionTracker.generateInsights();

                // Calculate metrics with enhanced analysis
                const words = canvasContent.trim().split(/\s+/).filter(w => w.length > 0);
                const lines = canvasContent.split('\n');

                // Get last modified timestamp
                const lastModified = localStorage.getItem('sovereign_canvas_timestamp');
                const modified = lastModified ? new Date(lastModified).toLocaleTimeString() : 'Never';

                // ========================================
                // ENHANCED METRICS CALCULATION
                // ========================================

                // Calculate evolution metrics
                const evolutionMetrics = {
                    trend: evolutionInsights ? evolutionInsights.trend : 'analyzing',
                    patterns: evolutionInsights ? evolutionInsights.patterns.join(', ') : 'none_detected',
                    anomalyCount: evolutionInsights ? evolutionInsights.anomalies.length : 0,
                    historyDepth: canvasEvolutionTracker.history.length,
                    avgChangeVelocity: canvasEvolutionTracker.history.length > 1 ?
                        canvasEvolutionTracker.history
                            .filter(s => s.changes)
                            .reduce((sum, s) => sum + parseFloat(s.changes.velocity), 0) /
                        canvasEvolutionTracker.history.filter(s => s.changes).length : 0
                };

                // Update UI elements with enhanced metrics
                const monitorElements = {
                    'canvasMonitorLength': canvasContent.length,
                    'canvasMonitorWords': words.length,
                    'canvasMonitorLines': lines.length
                };

                Object.entries(monitorElements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                // Update metrics grid elements with evolution data
                const metricsElements = {
                    'canvasSize': `${canvasContent.length} chars`,
                    'canvasWords': words.length,
                    'canvasLines': lines.length,
                    'canvasModified': modified,
                    'evolutionTrend': evolutionMetrics.trend.toUpperCase(),
                    'changeVelocity': `${evolutionMetrics.avgChangeVelocity.toFixed(1)} chars/min`,
                    'historyDepth': `${evolutionMetrics.historyDepth} snapshots`,
                    'patternsDetected': evolutionMetrics.patterns || 'analyzing'
                };

                Object.entries(metricsElements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                // Update canvas monitor last modified timestamp
                const monitorModifiedElement = document.getElementById('canvasMonitorModified');
                if (monitorModifiedElement) monitorModifiedElement.textContent = modified;

                // ========================================
                // EVOLUTION INSIGHTS DISPLAY
                // ========================================

                // Update evolution insights panel if it exists
                const insightsElement = document.getElementById('evolutionInsights');
                if (insightsElement && evolutionInsights) {
                    let insightsHTML = '<strong>üìä EVOLUTION ANALYSIS</strong>\n\n';

                    // Trend analysis
                    insightsHTML += `**Trend:** ${evolutionInsights.trend.toUpperCase()}\n`;

                    // Pattern detection
                    if (evolutionInsights.patterns.length > 0) {
                        insightsHTML += `**Patterns:** ${evolutionInsights.patterns.join(', ')}\n`;
                    }

                    // Anomalies
                    if (evolutionInsights.anomalies.length > 0) {
                        insightsHTML += `**Anomalies:** ${evolutionInsights.anomalies.length} detected\n`;
                        evolutionInsights.anomalies.slice(0, 2).forEach(anomaly => {
                            insightsHTML += `‚Ä¢ ${anomaly}\n`;
                        });
                    }

                    // Predictions
                    if (evolutionInsights.predictions) {
                        const pred = evolutionInsights.predictions;
                        insightsHTML += `**Prediction:** ${pred.predictedLength} chars in ${pred.timeHorizon.replace('_', ' ')} (${pred.confidence.toFixed(1)}% confidence)\n`;
                    }

                    insightsElement.innerHTML = insightsHTML.replace(/\n/g, '<br>');
                }

                // ========================================
                // UPDATE CORRELATION INSIGHTS
                // ========================================

                // Update correlation insights display
                const correlationInsights = crossSystemCorrelationEngine.getCorrelationInsights();
                const correlationElement = document.getElementById('correlationInsights');
                if (correlationElement && correlationInsights) {
                    let insightsHTML = `**Consensus:** ${correlationInsights.consensusStrength}\n`;
                    insightsHTML += `**Harmony:** ${correlationInsights.systemHarmony}\n`;
                    insightsHTML += `**Patterns:** ${correlationInsights.emergingPatterns} emerging\n`;
                    if (correlationInsights.activeConflicts > 0) {
                        insightsHTML += `**Conflicts:** ${correlationInsights.activeConflicts} detected\n`;
                    }
                    if (correlationInsights.topCorrelations.length > 0) {
                        insightsHTML += `**Top Correlation:** ${correlationInsights.topCorrelations[0].system} ‚Üî ${correlationInsights.topCorrelations[0].member}\n`;
                    }
                    insightsHTML += `**Last Analysis:** ${correlationInsights.lastAnalysis}\n`;
                    correlationElement.innerHTML = insightsHTML.replace(/\n/g, '<br>');
                }

                // ========================================
                // UPDATE MEMORY OPTIMIZATION METRICS
                // ========================================

                // Update memory optimization display
                const memoryMetrics = advancedMemoryOrchestrator.getOptimizationMetrics();
                const memoryMetricsElement = document.getElementById('memoryOptimizationMetrics');
                if (memoryMetricsElement) {
                    let metricsHTML = `**Efficiency:** ${memoryMetrics.memoryEfficiency}\n`;
                    metricsHTML += `**Fingerprints:** ${memoryMetrics.totalFingerprints}\n`;
                    metricsHTML += `**Deduplication Savings:** ${memoryMetrics.deduplicationSavings} bytes\n`;
                    if (memoryMetrics.optimizationOpportunities > 0) {
                        metricsHTML += `**Opportunities:** ${memoryMetrics.optimizationOpportunities} available\n`;
                    }
                    memoryMetricsElement.innerHTML = metricsHTML.replace(/\n/g, '<br>');
                }

                // ========================================
                // CONTENT PREVIEW WITH EVOLUTION MARKERS
                // ========================================

                // Update content preview with actual canvas content - NO TRUNCATION
                let preview = '';
                if (canvasContent.length > 0) {
                    preview = canvasContent; // Show complete content always
                } else {
                    preview = 'No canvas content detected yet...';
                }

                const previewElement = document.getElementById('canvasContentPreview');
                if (previewElement) {
                    previewElement.textContent = preview;
                }

                // Update global currentAIMemory for status displays
                currentAIMemory = aiMemory;

                // Update compact memory status with new AI memory data
                updateCompactMemoryStatus();

                // Update synthesis monitoring with actual synthesis content
                updateSynthesisMonitor(synthesisContent);

                if (canvasContent.length > 0) {
                    console.log(`üìä Canvas monitor updated: ${canvasContent.length} chars, ${words.length} words, ${lines.length} lines`);
                    console.log(`üîç Full canvas content received and displayed - no truncation`);
                }
            } catch (error) {
                console.error('Error updating canvas monitor:', error);
            }
        }

        // Update synthesis monitor with actual synthesis content data
        function updateSynthesisMonitor(synthesisContent) {
            try {
                // Update existing synthesis UI elements with content data
                const synthesisRoundEl = document.getElementById('synthesisRound');
                const autoSynthesisEl = document.getElementById('autoSynthesisStatus');
                const agentsCompleteEl = document.getElementById('agentsComplete');
                const roundsCompletedEl = document.getElementById('roundsCompleted');
                const extendedAnalysisEl = document.getElementById('extendedAnalysisContent');

                if (synthesisContent && synthesisContent.length > 0) {
                    // Update synthesis status to show content is available
                    if (autoSynthesisEl) {
                        autoSynthesisEl.textContent = 'Content Available';
                        autoSynthesisEl.style.color = '#00ff88';
                        autoSynthesisEl.title = `Synthesis content: ${synthesisContent.length} characters`;
                    }

                    // Update synthesis round to show content status
                    if (synthesisRoundEl) {
                        synthesisRoundEl.textContent = 'Content Ready';
                        synthesisRoundEl.style.color = '#00ff88';
                    }

                    // Update extended analysis content with synthesis insights
                    if (extendedAnalysisEl) {
                        const timestamp = new Date().toLocaleTimeString();
                        extendedAnalysisEl.innerHTML = `<strong>üìä Latest Synthesis Analysis (${timestamp})</strong>\n\n${synthesisContent.substring(0, 500)}${synthesisContent.length > 500 ? '...' : ''}\n\n<strong>üîó Cross-System Correlations:</strong>\n‚Ä¢ AI agent responses integrated\n‚Ä¢ Memory patterns analyzed\n‚Ä¢ Evolution trends detected\n‚Ä¢ Pattern recognition active`;
                    }

                    console.log(`üîç Synthesis monitor updated: ${synthesisContent.length} characters of synthesis content available`);
                } else {
                    // No synthesis content - show waiting status
                    if (autoSynthesisEl) {
                        autoSynthesisEl.textContent = 'Waiting for Content';
                        autoSynthesisEl.style.color = '#ffaa00';
                        autoSynthesisEl.title = 'No synthesis content available yet';
                    }

                    if (synthesisRoundEl) {
                        synthesisRoundEl.textContent = 'Ready';
                        synthesisRoundEl.style.color = '#4ecdc4';
                    }

                    // Update extended analysis content with waiting message
                    if (extendedAnalysisEl) {
                        extendedAnalysisEl.innerHTML = 'Advanced correlation analysis and system insights will appear here as synthesis reports are generated and processed by the DJINN council.\n\nWaiting for AI agents to complete their analysis rounds...';
                    }

                    console.log(`üîç Synthesis monitor: No synthesis content available`);
                }

                // Update rounds completed from evolution history
                const evolutionHistory = JSON.parse(localStorage.getItem('ai_evolution_history') || '[]');
                if (roundsCompletedEl) {
                    roundsCompletedEl.textContent = evolutionHistory.length;
                }

            } catch (error) {
                console.error('Error updating synthesis monitor:', error);
            }
        }

        function updateAIFeedsMonitor(aiFeeds, aiMemory) {
            try {
                // Monitor AI observer feeds
                const feedCount = aiFeeds.length;
                const feedElement = document.getElementById('activeFeedCount');
                if (feedElement) feedElement.textContent = feedCount;

                // Parse and display AI memory status
                let totalMemoryItems = 0;
                let memoryStatusHTML = '<div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">';
                memoryStatusHTML += '<strong>üß† AI Memory Status:</strong><br>';

                try {
                    const parsedMemory = JSON.parse(aiMemory);
                    if (parsedMemory && typeof parsedMemory === 'object') {
                        Object.keys(parsedMemory).forEach(system => {
                            const memory = parsedMemory[system];
                            const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                            const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                            const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                            totalMemoryItems += memoryCount + insightCount;
                            memoryStatusHTML += `${system.toUpperCase()}: ${hasMemory ? '‚úÖ' : '‚è≥'} (${memoryCount} responses, ${insightCount} insights)<br>`;
                        });
                    }
                    // Store for compact display
                    currentAIMemory = aiMemory;
                } catch (e) {
                    console.log('Error parsing AI memory:', e);
                    memoryStatusHTML += 'Error parsing memory data<br>';
                }
                memoryStatusHTML += '</div>';

                const memoryElement = document.getElementById('memoryCount');
                if (memoryElement) memoryElement.textContent = `${totalMemoryItems} items`;

                // AI Memory Status moved to compact display - no longer in Echo & Memory panel

            } catch (error) {
                console.error('Error updating AI feeds monitor:', error);
            }
        }

        function updateCorrelativeAnalysisDisplay(report) {
            try {
                // Update correlative analysis insights panel
                const insightsElement = document.getElementById('correlativeAnalysisInsights');
                if (insightsElement) {
                    let insightsHTML = '<strong>üî¨ DJINN COUNCIL CORRELATIVE ANALYSIS</strong>\n\n';

                    // Analysis summary
                    insightsHTML += `**Analysis Cycle:** ${report.analysisCycle}\n`;
                    insightsHTML += `**Trigger:** ${report.synthesisTrigger}\n`;
                    insightsHTML += `**Correlation Depth:** ${report.correlationDepth.toFixed(2)}\n\n`;

                    // Deep insights
                    if (report.deepInsights && report.deepInsights.keyFindings) {
                        insightsHTML += '**Key Findings:**\n';
                        report.deepInsights.keyFindings.slice(0, 3).forEach(finding => {
                            insightsHTML += `‚Ä¢ ${finding}\n`;
                        });
                        insightsHTML += '\n';
                    }

                    // Recommendations
                    if (report.recommendations && report.recommendations.length > 0) {
                        insightsHTML += '**Recommendations:**\n';
                        report.recommendations.slice(0, 2).forEach(rec => {
                            insightsHTML += `‚Ä¢ ${rec}\n`;
                        });
                    }

                    insightsElement.innerHTML = insightsHTML.replace(/\n/g, '<br>');
                }

                // Update analysis status
                const statusElement = document.getElementById('analysisStatus');
                if (statusElement) {
                    statusElement.textContent = `Last Analysis: ${new Date(report.timestamp).toLocaleTimeString()}`;
                }

                // Update report count
                const reportCountElement = document.getElementById('reportCount');
                if (reportCountElement) {
                    reportCountElement.textContent = surveillanceState.reportCount;
                }

                console.log('üìä Correlative analysis display updated');

            } catch (error) {
                console.error('Error updating correlative analysis display:', error);
            }
        }

        function initializeSurveillance() {
            console.log('üßû‚Äç‚ôÇÔ∏è DJINN Council Shadow Governance initializing...');
            
            // Start monitoring canvas
            startCanvasMonitoring();
            
            // Initialize UI
            updateTimestamp();
            
            // Start polling
            startPolling();

            // Listen for localStorage changes from canvas page for instant sync
            window.addEventListener('storage', function(event) {
                if (event.key === 'sovereign_canvas_content' || event.key === 'ai_memory_state' || event.key === 'synthesis_canvas_content') {
                    console.log(`üîÑ ${event.key} changed - updating surveillance immediately`);
                    setTimeout(() => {
                        checkCanvasState();
                    }, 100);
                }

                // Add listener for canvas synthesis status updates
                if (event.key === 'canvas_synthesis_status') {
                    console.log(`üìä Canvas synthesis status updated - refreshing metrics immediately`);
                    setTimeout(() => {
                        updateSynthesisStatusFromLocalStorage();
                    }, 50);
                }

                // Add listener for synthesis progress updates
                if (event.key === 'synthesis_progress') {
                    console.log(`üîÑ Synthesis progress updated`);
                    setTimeout(() => {
                        updateSynthesisProgressStatus();
                    }, 50);
                }
            });

            console.log('‚úÖ DJINN Council operational with real-time cross-window sync');
        }

        // Function to update synthesis status from localStorage immediately
        function updateSynthesisStatusFromLocalStorage() {
            try {
                // Read canvas synthesis status communication
                const synthesisStatus = JSON.parse(localStorage.getItem('canvas_synthesis_status') || '{}');

                // Update synthesis metrics
                const roundsCompleted = JSON.parse(localStorage.getItem('ai_evolution_history') || '[]').length;
                document.getElementById('roundsCompleted').textContent = roundsCompleted;

                // Update current round status from canvas communication
                const synthesisRoundEl = document.getElementById('synthesisRound');
                const agentsCompleteEl = document.getElementById('agentsComplete');
                const autoSynthesisEl = document.getElementById('autoSynthesisStatus');

                if (synthesisStatus.currentRound) {
                    const roundNum = synthesisStatus.currentRound.split('_')[1];
                    if (synthesisRoundEl) synthesisRoundEl.textContent = `Round ${roundNum}`;
                    if (agentsCompleteEl) agentsCompleteEl.textContent = `${synthesisStatus.completedSystems || 0}/5`;
                    if (autoSynthesisEl) {
                        if (synthesisStatus.allComplete && synthesisStatus.synthesisTriggered) {
                            autoSynthesisEl.textContent = 'Complete';
                            autoSynthesisEl.style.color = '#00ff88';
                        } else if (synthesisStatus.allComplete) {
                            autoSynthesisEl.textContent = 'Triggered';
                            autoSynthesisEl.style.color = '#ffaa00';
                        } else {
                            autoSynthesisEl.textContent = 'Waiting';
                            autoSynthesisEl.style.color = '#4ecdc4';
                        }
                    }
                } else {
                    if (synthesisRoundEl) synthesisRoundEl.textContent = 'Ready';
                    if (agentsCompleteEl) agentsCompleteEl.textContent = '0/5';
                    if (autoSynthesisEl) autoSynthesisEl.textContent = 'Waiting';
                }

                console.log(`üìä Synthesis status updated: ${synthesisStatus.completedSystems || 0}/5 systems complete`);

            } catch (error) {
                console.error('Error updating synthesis status from localStorage:', error);
            }
        }

        // Function to update synthesis progress status
        function updateSynthesisProgressStatus() {
            try {
                const progressStatus = localStorage.getItem('synthesis_progress') || 'Ready';
                const progressEl = document.getElementById('synthesisProgress');

                if (progressEl) {
                    progressEl.textContent = progressStatus;

                    // Add visual styling based on status
                    if (progressStatus === 'SYNTHESIZING...') {
                        progressEl.style.color = '#ffd93d';
                        progressEl.style.animation = 'pulse 1s infinite';
                    } else if (progressStatus === 'COMPLETE') {
                        progressEl.style.color = '#00ff88';
                        progressEl.style.animation = 'none';
                    } else if (progressStatus === 'ERROR') {
                        progressEl.style.color = '#ff6b6b';
                        progressEl.style.animation = 'none';
                    } else {
                        progressEl.style.color = '#cc88cc';
                        progressEl.style.animation = 'none';
                    }
                }

            } catch (error) {
                console.error('Error updating synthesis progress status:', error);
            }
        }

        function startCanvasMonitoring() {
            // Initial check
            checkCanvasState();
            
            // Set up periodic monitoring
            surveillanceState.pollingTimer = setInterval(() => {
                checkCanvasState();
            }, DJINN_CONFIG.POLLING_INTERVAL);
        }

        function checkCanvasState() {
            try {
                // Read ALL data sources for comprehensive monitoring
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';

                // Update canvas monitor with ALL data sources
                updateCanvasMonitor();

                // Calculate hashes for change detection
                const canvasHash = hashContent(canvasContent);
                const memoryHash = hashContent(aiMemory);
                const synthesisHash = hashContent(synthesisContent);
                const feedCount = aiFeeds.length;

                // ========================================
                // SYNTHESIS COMPLETION DETECTION & CORRELATIVE ANALYSIS TRIGGER
                // ========================================

                // Detect new synthesis report generation
                if (synthesisHash !== surveillanceState.lastSynthesisHash && synthesisContent.length > 0) {
                    console.log('üéØ SYNTHESIS REPORT GENERATED - Triggering DJINN Council Correlative Analysis');

                    // Reset synthesis analysis trigger flag
                    surveillanceState.synthesisAnalysisTriggered = false;

                    // Trigger comprehensive correlative analysis
                    triggerCorrelativeAnalysis(canvasContent, aiMemory, synthesisContent, aiFeeds);

                    // Update synthesis hash
                    surveillanceState.lastSynthesisHash = synthesisHash;
                }

                // Update UI metrics with null checks
                const canvasSizeEl = document.getElementById('canvasSize');
                if (canvasSizeEl) canvasSizeEl.textContent = `${canvasContent.length} chars`;

                // Calculate actual memory count from conversation history and insights
                let totalMemoryItems = 0;
                let memoryStatusHTML = '<div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">';
                memoryStatusHTML += '<strong>üß† AI Memory Status:</strong><br>';

                try {
                    const parsedMemory = JSON.parse(aiMemory);
                    if (parsedMemory && typeof parsedMemory === 'object') {
                        Object.keys(parsedMemory).forEach(system => {
                            const memory = parsedMemory[system];
                            const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                            const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                            const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                            totalMemoryItems += memoryCount + insightCount;

                            memoryStatusHTML += `${system.toUpperCase()}: ${hasMemory ? '‚úÖ' : '‚è≥'} (${memoryCount} responses, ${insightCount} insights)<br>`;
                        });
                    }
                } catch (e) {
                    console.log('Error parsing AI memory:', e);
                    memoryStatusHTML += 'Error parsing memory data<br>';
                }
                memoryStatusHTML += '</div>';

                const memoryCountEl = document.getElementById('memoryCount');
                if (memoryCountEl) memoryCountEl.textContent = `${totalMemoryItems} items`;

                const feedCountEl = document.getElementById('feedCount');
                if (feedCountEl) feedCountEl.textContent = feedCount;

                // Calculate and update additional metrics
                const words = canvasContent.split(/\s+/).filter(w => w.length > 0).length;
                const lines = canvasContent.split('\n').length;
                const modified = canvasContent.length > 0 ? new Date().toLocaleTimeString() : 'Never';

                const canvasWordsEl = document.getElementById('canvasWords');
                if (canvasWordsEl) canvasWordsEl.textContent = words;

                const canvasLinesEl = document.getElementById('canvasLines');
                if (canvasLinesEl) canvasLinesEl.textContent = lines;

                const canvasModifiedEl = document.getElementById('canvasModified');
                if (canvasModifiedEl) canvasModifiedEl.textContent = modified;

                // Calculate activity level based on recent changes
                const activityLevel = calculateActivityLevel(canvasContent, feedCount, words);
                const activityLevelEl = document.getElementById('activityLevel');
                if (activityLevelEl) activityLevelEl.textContent = activityLevel;

                // Calculate data density (words per line ratio)
                const dataDensity = lines > 0 ? (words / lines).toFixed(1) : '0.0';
                const dataDensityEl = document.getElementById('dataDensity');
                if (dataDensityEl) dataDensityEl.textContent = dataDensity;

                // Update canvas monitor status
                const monitorStatusEl = document.getElementById('canvasMonitorStatus');
                if (monitorStatusEl) {
                    if (canvasContent.length > 0) {
                        monitorStatusEl.textContent = 'ACTIVE';
                        monitorStatusEl.style.background = 'rgba(0, 255, 136, 0.2)';
                        monitorStatusEl.style.color = '#00ff88';
                    } else {
                        monitorStatusEl.textContent = 'INACTIVE';
                        monitorStatusEl.style.background = 'rgba(102, 102, 102, 0.2)';
                        monitorStatusEl.style.color = '#666';
                    }
                }

                // Calculate average confidence
                if (aiFeeds.length > 0) {
                    const latestFeed = aiFeeds[0];
                    const confidences = Object.values(latestFeed)
                        .filter(v => v && typeof v === 'object' && v.confidence)
                        .map(v => v.confidence);
                    const avgConfidence = confidences.length > 0
                        ? (confidences.reduce((a, b) => a + b, 0) / confidences.length * 100).toFixed(1)
                        : '--';
                    document.getElementById('confidenceAvg').textContent = `${avgConfidence}%`;
                }

                // Update synthesis round status from localStorage
                const evolutionHistory = JSON.parse(localStorage.getItem('ai_evolution_history') || '[]');
                const roundsCompleted = evolutionHistory.length;

                // Update synthesis status using the dedicated function
                updateSynthesisStatusFromLocalStorage();
                updateSynthesisProgressStatus();

                // Detect changes
                let changesDetected = false;
                
                if (canvasHash !== surveillanceState.lastCanvasHash && canvasContent.length > 0) {
                    const sizeDiff = Math.abs(canvasContent.length - (surveillanceState.lastCanvasContent?.length || 0));
                    if (sizeDiff > DJINN_CONFIG.ANALYSIS_THRESHOLD) {
                        changesDetected = true;
                        logSurveillance('üìù Canvas content changed significantly', 'change');
                        queueAnalysis('canvas_change', { content: canvasContent, type: 'content' });
                    }
                    surveillanceState.lastCanvasHash = canvasHash;
                    surveillanceState.lastCanvasContent = canvasContent;
                }
                
                if (memoryHash !== surveillanceState.lastMemoryHash) {
                    changesDetected = true;
                    logSurveillance('üß† AI memory updated', 'memory');
                    queueAnalysis('memory_update', { memory: aiMemory, type: 'memory' });
                    surveillanceState.lastMemoryHash = memoryHash;
                }
                
                if (feedCount > surveillanceState.lastFeedCount) {
                    changesDetected = true;
                    const newFeeds = aiFeeds.slice(0, feedCount - surveillanceState.lastFeedCount);
                    logSurveillance(`üì° ${newFeeds.length} new AI feeds detected`, 'feed');
                    queueAnalysis('new_feeds', { feeds: newFeeds, type: 'feeds' });
                    surveillanceState.lastFeedCount = feedCount;
                }
                
                if (changesDetected) {
                    surveillanceState.changeCount++;
                    document.getElementById('changeCount').textContent = surveillanceState.changeCount;
                    document.getElementById('canvasStatus').textContent = 'CHANGES DETECTED';
                    
                    // Process analysis queue
                    processAnalysisQueue();
                }
                
            } catch (error) {
                console.error('Surveillance error:', error);
                logSurveillance(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Update miniature canvas monitor with live canvas data

        // Create miniature HTML representation of canvas content
        // Calculate activity level based on canvas metrics
        function calculateActivityLevel(canvasContent, feedCount, wordCount) {
            const contentLength = canvasContent.length;
            const recencyScore = feedCount > 0 ? Math.min(feedCount * 10, 100) : 0;
            const volumeScore = Math.min(contentLength / 100, 100);
            const densityScore = wordCount > 0 ? Math.min(wordCount / 10, 100) : 0;

            const totalScore = (recencyScore + volumeScore + densityScore) / 3;

            if (totalScore >= 70) return 'HIGH';
            if (totalScore >= 40) return 'MEDIUM';
            if (totalScore >= 10) return 'LOW';
            return 'IDLE';
        }

        // ========================================
        // COUNCIL ANALYSIS SYSTEM
        // ========================================

        function queueAnalysis(eventType, data) {
            surveillanceState.analysisQueue.push({
                id: Date.now(),
                type: eventType,
                data: data,
                timestamp: new Date().toISOString()
            });
            
            updateQueueStatus();
        }

        async function processAnalysisQueue() {
            if (surveillanceState.isAnalyzing || surveillanceState.analysisQueue.length === 0) {
                return;
            }
            
            surveillanceState.isAnalyzing = true;
            updateCouncilStatus('ANALYZING');
            
            while (surveillanceState.analysisQueue.length > 0) {
                const analysis = surveillanceState.analysisQueue.shift();
                await performCouncilAnalysis(analysis);
                updateQueueStatus();
            }
            
            surveillanceState.isAnalyzing = false;
            updateCouncilStatus('READY');
        }

        async function performCouncilAnalysis(analysis) {
            console.log(`üîç Council analyzing: ${analysis.type}`);
            
            // Update UI
            document.getElementById('councilIndicator').className = 'indicator indicator-processing';
            
            try {
                // === COLLABORATIVE ITERATIVE ANALYSIS ===
                // Each stage builds on insights from previous stages

                // Stage 1: Initial reconnaissance - Pattern & Wisdom establish foundation
                console.log('üîç Stage 1: Foundation Analysis (Pattern & Wisdom)');
                const stage1 = await Promise.all([
                    queryCouncilMember('pattern', generateCouncilPrompts(analysis).pattern, analysis),
                    queryCouncilMember('wisdom', generateCouncilPrompts(analysis).wisdom, analysis)
                ]);

                await new Promise(resolve => setTimeout(resolve, 800));

                // Stage 2: Cross-pollinated analysis - Paradox & Boundaries build on Stage 1
                console.log('üîÑ Stage 2: Cross-Pollinated Analysis (incorporating Stage 1 insights)');
                const stage1Insights = extractKeyInsights(stage1);
                const enhancedParadoxPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).paradox,
                    stage1Insights,
                    'paradox'
                );
                const enhancedBoundariesPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).boundaries,
                    stage1Insights,
                    'boundaries'
                );

                const stage2 = await Promise.all([
                    queryCouncilMember('paradox', enhancedParadoxPrompt, analysis),
                    queryCouncilMember('boundaries', enhancedBoundariesPrompt, analysis)
                ]);

                await new Promise(resolve => setTimeout(resolve, 800));

                // Stage 3: Synthesis with full council context - Memory incorporates all insights
                console.log('üß† Stage 3: Comprehensive Memory Synthesis');
                const allPriorInsights = extractKeyInsights([...stage1, ...stage2]);
                const enhancedMemoryPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).memory,
                    allPriorInsights,
                    'memory'
                );

                const stage3 = await queryCouncilMember('memory', enhancedMemoryPrompt, analysis);

                // Collect all responses for consensus generation
                const responses = [...stage1, ...stage2, stage3];

                // Generate collaborative consensus using new memory system
                console.log('‚öñÔ∏è Generating Collaborative Consensus with Memory Context');
                const consensus = synthesizeConsensus(responses, analysis);

                // Store consensus in memory
                djinnCouncilMemory.consensusHistory.push({
                    timestamp: new Date().toISOString(),
                    sessionReport: djinnCouncilMemory.members.pattern.reports.length,
                    memberAnalyses: responses.reduce((acc, r) => {
                        acc[r.member] = r.response;
                        return acc;
                    }, {}),
                    crossReferences: analyzeConsensusPatterns(),
                    emergentPatterns: identifyEmergentThemes(),
                    systemRecommendations: generateStrategicRecommendations()
                });

                // Auto-save intelligence
                autoSaveIntelligence();

                // Generate AI-powered intelligence report using council consensus
                console.log('üìä Generating AI-Powered Intelligence Report');
                const intelligenceEntry = await generateIntelligenceEntry(analysis, consensus);

                // Store and display the AI-generated intelligence report
                storeIntelligence(intelligenceEntry);
                displayIntelligence(intelligenceEntry);
                
            } catch (error) {
                console.error('Council analysis error:', error);
                logSurveillance(`‚ùå Analysis failed: ${error.message}`, 'error');
            }
            
            // Update UI
            document.getElementById('councilIndicator').className = 'indicator indicator-idle';
            updateTimestamp();
        }

        function generateEmptyStatePrompts(timestamp) {
            const emptyContext = `EVENT: empty_canvas_state\nTIMESTAMP: ${timestamp}\nSTATUS: No canvas content detected\n\nINSTRUCTION: Report IDLE status and wait for actual user content before analysis.`;

            return {
                pattern: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                wisdom: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                paradox: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                boundaries: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                memory: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`
            };
        }

        function generateCouncilPrompts(analysis) {
            // Extract canvas content for analysis
            const canvasContent = analysis.data?.content || '';

            // Use the new referential memory system
            return {
                pattern: generateReferentialAnalysis('pattern', canvasContent),
                wisdom: generateReferentialAnalysis('wisdom', canvasContent),
                paradox: generateReferentialAnalysis('paradox', canvasContent),
                boundaries: generateReferentialAnalysis('boundaries', canvasContent),
                memory: generateReferentialAnalysis('memory', canvasContent)
            };
        }

        // Format council response with proper structure and line breaks
        function formatCouncilResponse(response) {
            if (!response) return 'No response generated';

            // Add timestamp header
            const timestamp = new Date().toLocaleTimeString();
            const timestampHeader = `<div class="intel-timestamp" style="color: #888; font-size: 11px; margin-bottom: 8px;">${timestamp} <span class="new-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">NEW</span></div>`;

            // If response already has proper structure, ensure line breaks are preserved
            if (response.includes('[METRICS]') && response.includes('[ANALYSIS]')) {
                // Extract sections
                const metricsMatch = response.match(/\[METRICS\](.*?)(?=\[ANALYSIS\]|$)/s);
                const analysisMatch = response.match(/\[ANALYSIS\](.*)$/s);

                let formatted = timestampHeader;

                if (metricsMatch) {
                    const metricsContent = metricsMatch[1].trim();
                    // Apply color coding to individual metrics
                    const colorCodedMetrics = applyMetricColorCoding(metricsContent);
                    formatted += `<div class="metrics-section">[METRICS]\n${colorCodedMetrics}</div>\n\n`;
                }

                if (analysisMatch) {
                    const analysisContent = analysisMatch[1].trim();
                    formatted += `<div class="analysis-section">[ANALYSIS]\n${analysisContent}</div>`;
                }

                return formatted.trim();
            }
            
            // Try to detect and format common patterns
            let formatted = response;
            
            // Look for metrics-like patterns and structure them
            const metricPatterns = [
                /knowledge depth:?\s*(\d+)/gi,
                /learning rate:?\s*([\d.]+)/gi,
                /recursive loops:?\s*(\d+)/gi,
                /information density:?\s*([\d.]+)/gi,
                /accumulation rate:?\s*(\d+)%/gi,
                /paradoxes detected:?\s*(\d+)/gi,
                /contradiction severity:?\s*(\w+)/gi,
                /logic conflicts:?\s*(\d+)/gi,
                /resolution probability:?\s*(\d+)%/gi,
                /creative tension:?\s*(\d+)/gi,
                /autonomy score:?\s*(\d+)%/gi,
                /system overrides:?\s*(\d+)/gi,
                /choice restrictions:?\s*(\d+)/gi,
                /boundary violations:?\s*(\d+)/gi,
                /freedom index:?\s*(\w+)/gi,
                /memory allocation:?\s*([\d.]+(?:\s*\w+)?)/gi,
                /retention rate:?\s*(\d+)%/gi,
                /fragmentation index:?\s*([\d.]+)/gi,
                /echo patterns:?\s*(\d+)/gi,
                /temporal continuity:?\s*(\d+)%/gi
            ];
            
            let metricsFound = [];
            metricPatterns.forEach(pattern => {
                const matches = formatted.match(pattern);
                if (matches) {
                    metricsFound.push(...matches);
                }
            });
            
            // If we found metrics, structure them properly
            if (metricsFound.length > 0) {
                let metricsSection = '[METRICS]\n';
                metricsFound.forEach(metric => {
                    // Capitalize first letter and ensure proper format
                    const formattedMetric = metric.charAt(0).toUpperCase() + metric.slice(1);
                    metricsSection += formattedMetric + '\n';
                });
                
                // Extract analysis part (everything after metrics)
                const analysisStart = formatted.toLowerCase().indexOf('analysis');
                let analysisSection = '[ANALYSIS]\n';
                if (analysisStart !== -1) {
                    analysisSection += formatted.substring(analysisStart + 8).trim();
                } else {
                    // If no analysis section found, put remaining content there
                    const metricsText = metricsFound.join(' ');
                    analysisSection += formatted.replace(new RegExp(metricsText, 'gi'), '').trim();
                }
                
                formatted = metricsSection + '\n' + analysisSection;
            } else {
                // No metrics found, just add basic structure
                formatted = '[ANALYSIS]\n' + formatted;
            }
            
            // Clean up excessive whitespace
            formatted = formatted.replace(/\n{3,}/g, '\n\n');
            formatted = formatted.trim();

            // Add timestamp for non-structured responses
            return timestampHeader + formatted;
        }

        // Apply color coding to individual metrics
        function applyMetricColorCoding(metricsText) {
            let colorCodedText = metricsText;

            // Process each line to apply color coding
            const lines = colorCodedText.split('\n');
            const colorCodedLines = lines.map(line => {
                const lowerLine = line.toLowerCase();

                // Find matching metric and apply color class
                for (const [metricName, colorClass] of Object.entries(metricColorMap)) {
                    if (lowerLine.includes(metricName)) {
                        // Wrap the metric line with color styling
                        return `<span class="${colorClass}" style="display: block; margin: 2px 0; padding: 2px 4px; border-radius: 2px; background: rgba(255,255,255,0.05);">${line}</span>`;
                    }
                }

                // Return line unchanged if no metric match
                return line;
            });

            return colorCodedLines.join('\n');
        }

        async function queryCouncilMember(memberKey, prompt, analysisContext = null) {
            const member = councilMembers[memberKey];
            
            // Update status
            document.getElementById(member.status).textContent = 'ANALYZING';
            document.getElementById(member.element).innerHTML = '<span class="thinking">Processing data...</span>';
            
            try {
                // Check cache first - updated for template format
                const cacheKey = `${memberKey}_template_${hashContent(prompt)}`;
                if (responseCache.has(cacheKey)) {
                    const cached = responseCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < DJINN_CONFIG.CACHE_DURATION) {
                        document.getElementById(member.element).textContent = cached.response;
                        document.getElementById(member.status).textContent = 'COMPLETE';
                        return { member: memberKey, response: cached.response };
                    }
                }
                
                // Query Ollama for AI analysis
                console.log(`üîç Querying ${member.model} for ${memberKey} analysis...`);
                const response = await queryOllama(member.model, prompt);
                if (response && typeof response === 'string') {
                    console.log(`‚úÖ ${memberKey} response received:`, response.substring(0, 200) + '...');
                } else {
                    console.error(`‚ùå ${memberKey} received invalid response:`, response);
                    return;
                }
                
                // Cache response
                responseCache.set(cacheKey, {
                    response: response,
                    timestamp: Date.now()
                });
                
                // Display the actual AI response instead of generic [METRICS] template
                const memberElement = document.getElementById(member.element);

                // Always display the full AI response with proper formatting
                if (response && response.length > 50) {
                    // Process markdown-style formatting for better display
                    const formattedResponse = formatMarkdownResponse(response, memberKey);
                    const timestamp = new Date().toLocaleTimeString();
                    const timestampHeader = `<div class="intel-timestamp" style="color: #888; font-size: 11px; margin-bottom: 8px;">${timestamp} <span class="new-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">NEW</span></div>`;
                    memberElement.innerHTML = timestampHeader + formattedResponse;
                } else {
                    // Fall back to formatted response only if AI response is empty/invalid
                    const formattedResponse = formatCouncilResponse(response);
                    memberElement.innerHTML = formattedResponse;
                }
                
                // Color is now handled in formatMarkdownResponse function
                // if (memberKey === 'pattern') memberElement.style.color = '#00ff88';
                // else if (memberKey === 'wisdom') memberElement.style.color = '#ffaa00';
                // else if (memberKey === 'paradox') memberElement.style.color = '#ff6666';
                // else if (memberKey === 'boundaries') memberElement.style.color = '#00ccff';
                // else if (memberKey === 'memory') memberElement.style.color = '#ff88ff';
                
                document.getElementById(member.status).textContent = 'COMPLETE';

                // Store in council memory system with optimization
                storeCouncilMemberReportOptimized(memberKey, {
                    analysis: response,
                    metrics: extractMetricsFromAnalysis(response),
                    canvasData: analysisContext?.data?.content || ''
                });

                return { member: memberKey, response: response };
                
            } catch (error) {
                // No fallback - show the actual error
                console.error(`‚ùå ${memberKey} AI query failed:`, error.message);
                document.getElementById(member.element).innerHTML = `<div style="color: #ff6666; font-size: 12px;">
                    ‚ö†Ô∏è AI Analysis Unavailable<br>
                    Error: ${error.message}<br>
                    Check Ollama service status
                </div>`;
                document.getElementById(member.status).textContent = 'ERROR';
                return { member: memberKey, response: null, error: error.message };
            }
        }

        // Enforce proper report structure formatting
        function enforceReportStructure(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Check if response already has proper structure
            const hasSummary = response.includes('**SUMMARY**');
            const hasAnalysis = response.includes('**ANALYSIS**');
            const hasFindings = response.includes('**FINDINGS**');
            const hasMetrics = response.includes('**METRICS**');
            const hasConclusions = response.includes('**CONCLUSIONS**');
            const hasActions = response.includes('**ACTIONS**');

            // If all sections are present, return as-is
            if (hasSummary && hasAnalysis && hasFindings && hasMetrics && hasConclusions && hasActions) {
                return response;
            }

            // If structure is missing, try to parse and restructure the content
            return restructureUnformattedResponse(response);
        }


        function restructureUnformattedResponse(response) {
            // Try to extract meaningful content and structure it properly
            const lines = response.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            // Look for section-like content
            const sections = {
                summary: [],
                analysis: [],
                findings: [],
                metrics: [],
                conclusions: [],
                actions: []
            };

            let currentSection = 'summary';
            let inMetrics = false;
            let inActions = false;

            for (const line of lines) {
                const lowerLine = line.toLowerCase();
                
                // Detect section headers
                if (lowerLine.includes('summary') && !lowerLine.includes('findings')) {
                    currentSection = 'summary';
                    continue;
                } else if (lowerLine.includes('analysis') || lowerLine.includes('method')) {
                    currentSection = 'analysis';
                    continue;
                } else if (lowerLine.includes('finding') || lowerLine.includes('discovery') || lowerLine.includes('observation')) {
                    currentSection = 'findings';
                    continue;
                } else if (lowerLine.includes('metric') || lowerLine.includes('measurement') || lowerLine.includes('statistic')) {
                    currentSection = 'metrics';
                    inMetrics = true;
                    continue;
                } else if (lowerLine.includes('conclusion') || lowerLine.includes('result')) {
                    currentSection = 'conclusions';
                    inMetrics = false;
                    continue;
                } else if (lowerLine.includes('action') || lowerLine.includes('recommendation')) {
                    currentSection = 'actions';
                    inActions = true;
                    inMetrics = false;
                    continue;
                }

                // Add content to current section
                if (currentSection === 'metrics' && (line.includes(':') || line.includes('%') || /\d/.test(line))) {
                    sections.metrics.push(line.replace(/^[\-\*]\s*/, '- '));
                } else if (currentSection === 'actions' && (line.includes('recommend') || line.match(/^\d+\./))) {
                    sections.actions.push(line.replace(/^[\-\*]\s*/, '').replace(/^\d+\.\s*/, ''));
                } else if (!inMetrics && !inActions) {
                    sections[currentSection].push(line);
                }
            }

            // Build properly formatted response
            let structured = '';

            if (sections.summary.length > 0) {
                structured += '**SUMMARY**\n' + sections.summary.join(' ') + '\n\n';
            }

            if (sections.analysis.length > 0) {
                structured += '**ANALYSIS**\n' + sections.analysis.join(' ') + '\n\n';
            }

            if (sections.findings.length > 0) {
                structured += '**FINDINGS**\n';
                // Try to categorize findings
                const categorizedFindings = categorizeFindings(sections.findings);
                Object.entries(categorizedFindings).forEach(([category, findings]) => {
                    if (findings.length > 0) {
                        structured += `- **${category}:** ${findings.join(' ')}\n`;
                    }
                });
                structured += '\n';
            }

            if (sections.metrics.length > 0) {
                structured += '**METRICS**\n';
                sections.metrics.forEach(metric => {
                    structured += (metric.startsWith('-') ? metric : '- ' + metric) + '\n';
                });
                structured += '\n';
            }

            if (sections.conclusions.length > 0) {
                structured += '**CONCLUSIONS**\n' + sections.conclusions.join(' ') + '\n\n';
            }

            if (sections.actions.length > 0) {
                structured += '**ACTIONS**\n';
                sections.actions.forEach((action, index) => {
                    structured += `${index + 1}. ${action}\n`;
                });
            }

            return structured.trim() || response; // Return restructured or original if restructuring failed
        }

        function categorizeFindings(findings) {
            const categories = {
                'System Performance': [],
                'Content Evolution': [],
                'Pattern Recognition': [],
                'Risk Assessment': []
            };

            findings.forEach(finding => {
                const lowerFinding = finding.toLowerCase();
                if (lowerFinding.includes('system') || lowerFinding.includes('performance') || lowerFinding.includes('ai')) {
                    categories['System Performance'].push(finding);
                } else if (lowerFinding.includes('content') || lowerFinding.includes('evolution') || lowerFinding.includes('change')) {
                    categories['Content Evolution'].push(finding);
                } else if (lowerFinding.includes('pattern') || lowerFinding.includes('recognition') || lowerFinding.includes('anomaly')) {
                    categories['Pattern Recognition'].push(finding);
                } else if (lowerFinding.includes('risk') || lowerFinding.includes('stability') || lowerFinding.includes('concern')) {
                    categories['Risk Assessment'].push(finding);
                } else {
                    categories['System Performance'].push(finding); // Default category
                }
            });

            return categories;
        }

        // Format markdown-style response for better HTML display
        function formatMarkdownResponse(response, memberKey) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Get member-specific colors
            const memberColors = {
                pattern: '#00ff88',
                wisdom: '#ffaa00', 
                paradox: '#ff6666',
                boundaries: '#00ccff',
                memory: '#ff88ff'
            };

            const memberColor = memberColors[memberKey] || '#ffffff';

            let formatted = response;

            // Convert **bold** to <strong> with member color
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, `<strong style="color: ${memberColor} !important;">$1</strong>`);

            // Convert section headers to styled divs with member color
            const headerStyle = `color: ${memberColor} !important; border-bottom: 1px solid ${memberColor}; padding-bottom: 2px; margin-bottom: 8px; font-weight: bold;`;
            
            // Ensure proper spacing before headers (both with and without ** formatting)
            formatted = formatted.replace(/([^\n])\*\*SUMMARY\*\*/g, '$1\n\n**SUMMARY**');
            formatted = formatted.replace(/([^\n])\*\*ANALYSIS\*\*/g, '$1\n\n**ANALYSIS**');
            formatted = formatted.replace(/([^\n])\*\*FINDINGS\*\*/g, '$1\n\n**FINDINGS**');
            formatted = formatted.replace(/([^\n])\*\*METRICS\*\*/g, '$1\n\n**METRICS**');
            formatted = formatted.replace(/([^\n])\*\*CONCLUSIONS\*\*/g, '$1\n\n**CONCLUSIONS**');
            formatted = formatted.replace(/([^\n])\*\*ACTIONS\*\*/g, '$1\n\n**ACTIONS**');
            
            // Handle headers without ** formatting (AI sometimes generates plain text headers)
            formatted = formatted.replace(/([^\n])(SUMMARY)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(ANALYSIS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(FINDINGS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(METRICS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(CONCLUSIONS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(ACTIONS)(?!\*)/g, '$1\n\n$2');
            
            formatted = formatted.replace(/^(\*\*SUMMARY\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">SUMMARY</div>`);
            formatted = formatted.replace(/^(\*\*ANALYSIS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">ANALYSIS</div>`);
            formatted = formatted.replace(/^(\*\*FINDINGS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">FINDINGS</div>`);
            formatted = formatted.replace(/^(\*\*METRICS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">METRICS</div>`);
            formatted = formatted.replace(/^(\*\*CONCLUSIONS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">CONCLUSIONS</div>`);
            formatted = formatted.replace(/^(\*\*ACTIONS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">ACTIONS</div>`);
            
            // Handle plain text headers (without ** formatting)
            formatted = formatted.replace(/^(SUMMARY)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">SUMMARY</div>`);
            formatted = formatted.replace(/^(ANALYSIS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">ANALYSIS</div>`);
            formatted = formatted.replace(/^(FINDINGS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">FINDINGS</div>`);
            formatted = formatted.replace(/^(METRICS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">METRICS</div>`);
            formatted = formatted.replace(/^(CONCLUSIONS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">CONCLUSIONS</div>`);
            formatted = formatted.replace(/^(ACTIONS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">ACTIONS</div>`);

            // Clean up actions section - remove extra headers and ensure proper numbering
            formatted = formatted.replace(/\*\*SECOND RECOMMENDATION\*\*[\s\S]*?\n/g, '');
            formatted = formatted.replace(/\*\*THIRD RECOMMENDATION\*\*[\s\S]*?\n/g, '');

            // Convert bullet points to proper HTML lists with member color
            // First, identify sections and wrap their content appropriately
            const sections = formatted.split(/(<div class="analysis-section">.*?<\/div>)/);
            let currentSection = '';

            formatted = sections.map(section => {
                if (section.includes('analysis-section')) {
                    // Update current section based on header
                    if (section.includes('METRICS')) currentSection = 'metrics';
                    else if (section.includes('ACTIONS')) currentSection = 'actions';
                    else if (section.includes('FINDINGS')) currentSection = 'findings';
                    else currentSection = '';
                    return section; // Keep headers as-is
                }

                // Process content sections
                let content = section;

                // Handle metrics section (uses - bullets)
                if (currentSection === 'metrics') {
                    content = content.replace(/^- (.*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;">$1</li>`);
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ul style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ul>`);
                }

                // Handle actions section (uses numbered bullets)
                if (currentSection === 'actions') {
                    // Clean up any malformed numbering - remove all leading numbers and unwanted headers
                    content = content.replace(/SECOND RECOMMENDATION/gi, ''); // Remove unwanted headers
                    content = content.replace(/THIRD RECOMMENDATION/gi, ''); // Remove unwanted headers
                    
                    // Clean up malformed numbering patterns like "1. 1." by removing all leading numbers
                    content = content.replace(/^[\d\.\s]+(.*?)(?=\n|$)/gm, (match, text) => {
                        // Remove all leading numbers and dots/spaces to get clean action text
                        const cleanText = text.trim().replace(/^[\d\.\s]+/, '').trim();
                        return `<li style="color: ${memberColor} !important;">${cleanText}</li>`;
                    });
                    
                    // Handle any remaining lines that might not have been caught
                    content = content.replace(/^([^-<\d].*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;">$1</li>`);
                    
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ol style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ol>`);
                }

                // Handle findings section (may have sub-bullets)
                if (currentSection === 'findings') {
                    content = content.replace(/^- \*\*(.*?):\*\* (.*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;"><strong style="color: ${memberColor} !important;">$1:</strong> $2</li>`);
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ul style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ul>`);
                }

                return content;
            }).join('');

            // Preserve line breaks but clean up excessive whitespace
            formatted = formatted.replace(/\n{3,}/g, '\n\n');
            formatted = formatted.replace(/\n/g, '<br>');

            // Clean up list formatting
            formatted = formatted.replace(/<\/li><br>/g, '</li>');
            formatted = formatted.replace(/<br><li>/g, '<li>');
            formatted = formatted.replace(/<br><ul>/g, '<ul>');
            formatted = formatted.replace(/<\/ul><br>/g, '</ul>');

            // Wrap in a container with proper styling
            formatted = `<div style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; white-space: normal; color: ${memberColor} !important;">${formatted}</div>`;

            return formatted;
        }

        async function queryOllama(model, prompt) {
            console.log(`üöÄ Starting Ollama query for model: ${model}`);
            console.log(`üìù Prompt length: ${prompt.length} characters`);
            
            try {
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        system: "You are an expert AI analyst. Analyze the provided data and write a structured report. Start directly with **SUMMARY** and follow the exact format specified in the prompt. Do not include any introductory text or copy the prompt structure - generate your own analysis content. In the ACTIONS section, provide exactly 3 numbered recommendations without any sub-headers like 'SECOND RECOMMENDATION'.",
                        prompt: prompt,
                        stream: false,
                        options: {
                            temperature: 0.7,  // Natural creativity for fluid AI responses
                            top_p: 0.5,
                            num_predict: 8192,  // Maximum token output for complete analysis
                            seed: Date.now()  // Add randomness to avoid cached responses
                        }
                    })
                });
                
                console.log(`üì° Ollama HTTP response status: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`Ollama HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                let rawResponse = data.response || '';

                // Log the raw response for debugging
                console.log('Raw Ollama response:', rawResponse);

                // Evaluate template literals in the response
                let evaluatedResponse = evaluateTemplateLiterals(rawResponse);
                
                // Strip any conversational text before the report structure
                const summaryIndex = evaluatedResponse.indexOf('**SUMMARY**');
                if (summaryIndex > 0) {
                    evaluatedResponse = evaluatedResponse.substring(summaryIndex);
                }
                
                // Enforce proper report structure formatting
                evaluatedResponse = enforceReportStructure(evaluatedResponse);
                
                console.log('Template evaluation result:', evaluatedResponse.substring(0, 200) + '...');
                
                return evaluatedResponse;
            } catch (error) {
                // No fallback - re-throw the error to be handled upstream
                console.error('Ollama query failed:', error.message);
                throw error;
            }
        }

        // ========================================
        // ENHANCED RESPONSE PARSING PIPELINE
        // ========================================

        // Advanced response processor with content preservation
        const enhancedResponseProcessor = {
            processingStats: {
                totalResponses: 0,
                contentPreserved: 0,
                structureImproved: 0,
                avgProcessingTime: 0
            },

            // Main processing pipeline
            process: function(rawResponse, memberKey = 'unknown') {
                const startTime = Date.now();
                this.processingStats.totalResponses++;

                try {
                    console.log(`üî¨ Enhanced processing for ${memberKey} response (${rawResponse.length} chars)`);

                    // Stage 1: Content preservation and analysis
                    const contentAnalysis = this.analyzeContent(rawResponse);

                    // Stage 2: Intelligent structure detection
                    const structureMap = this.detectStructure(rawResponse);

                    // Stage 3: Content-aware restructuring
                    const restructured = this.smartRestructure(rawResponse, structureMap, contentAnalysis);

                    // Stage 4: Quality enhancement
                    const enhanced = this.enhanceQuality(restructured, contentAnalysis);

                    // Stage 5: Validation and metrics
                    const validated = this.validateAndMeasure(enhanced, rawResponse);

                    const processingTime = Date.now() - startTime;
                    this.processingStats.avgProcessingTime =
                        (this.processingStats.avgProcessingTime + processingTime) / 2;

                    console.log(`‚úÖ Enhanced processing complete: ${validated.length}/${rawResponse.length} chars preserved (${processingTime}ms)`);

                    return validated;

                } catch (error) {
                    console.error('‚ùå Enhanced processing failed:', error);
                    // Fallback to original response
                    return rawResponse;
                }
            },

            // Analyze content characteristics
            analyzeContent: function(response) {
                return {
                    length: response.length,
                    lines: response.split('\n').length,
                    words: response.split(/\s+/).filter(w => w.length > 0).length,
                    sections: this.countSections(response),
                    formatting: this.detectFormatting(response),
                    quality: this.assessQuality(response),
                    structure: this.analyzeStructure(response)
                };
            },

            // Count existing sections
            countSections: function(response) {
                const sections = ['SUMMARY', 'ANALYSIS', 'FINDINGS', 'METRICS', 'CONCLUSIONS', 'ACTIONS'];
                const counts = {};

                sections.forEach(section => {
                    const regex = new RegExp(`\\*\\*${section}\\*\\*`, 'gi');
                    counts[section.toLowerCase()] = (response.match(regex) || []).length;
                });

                return counts;
            },

            // Detect formatting patterns
            detectFormatting: function(response) {
                return {
                    hasBold: response.includes('**') || response.includes('__'),
                    hasLists: response.includes('- ') || response.includes('* ') || /^\d+\./.test(response),
                    hasHeaders: /^\*+.*$/m.test(response),
                    hasTables: response.includes('|'),
                    hasCode: response.includes('```') || response.includes('`'),
                    hasLinks: response.includes('[') && response.includes('](')
                };
            },

            // Assess content quality
            assessQuality: function(response) {
                let score = 0;
                const words = response.split(/\s+/).filter(w => w.length > 0);

                // Length appropriateness
                if (response.length > 100) score += 20;
                if (response.length > 500) score += 20;

                // Vocabulary richness
                const uniqueWords = new Set(words.map(w => w.toLowerCase()));
                const richness = uniqueWords.size / words.length;
                score += Math.min(20, richness * 100);

                // Structure presence
                const sections = this.countSections(response);
                const sectionCount = Object.values(sections).reduce((a, b) => a + b, 0);
                score += Math.min(20, sectionCount * 5);

                // Formatting quality
                const formatting = this.detectFormatting(response);
                const formatScore = Object.values(formatting).filter(Boolean).length;
                score += Math.min(20, formatScore * 5);

                return Math.min(100, score);
            },

            // Analyze structural patterns
            analyzeStructure: function(response) {
                const lines = response.split('\n');
                const structure = {
                    headers: [],
                    paragraphs: [],
                    lists: [],
                    tables: [],
                    codeBlocks: []
                };

                let inCodeBlock = false;
                let currentParagraph = [];

                lines.forEach((line, index) => {
                    const trimmed = line.trim();

                    // Code blocks
                    if (trimmed.startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        if (inCodeBlock) structure.codeBlocks.push(index);
                        return;
                    }

                    if (inCodeBlock) return;

                    // Headers
                    if (/^#{1,6}\s/.test(trimmed) || /^\*+.*\*+$/.test(trimmed)) {
                        structure.headers.push({ line: index, content: trimmed });
                        if (currentParagraph.length > 0) {
                            structure.paragraphs.push(currentParagraph);
                            currentParagraph = [];
                        }
                    }
                    // Lists
                    else if (/^[\-\*]\s/.test(trimmed) || /^\d+\./.test(trimmed)) {
                        structure.lists.push({ line: index, content: trimmed });
                        if (currentParagraph.length > 0) {
                            structure.paragraphs.push(currentParagraph);
                            currentParagraph = [];
                        }
                    }
                    // Tables
                    else if (trimmed.includes('|') && trimmed.split('|').length > 2) {
                        structure.tables.push({ line: index, content: trimmed });
                    }
                    // Paragraph content
                    else if (trimmed.length > 0) {
                        currentParagraph.push(trimmed);
                    }
                    // Empty lines (paragraph breaks)
                    else if (currentParagraph.length > 0) {
                        structure.paragraphs.push(currentParagraph);
                        currentParagraph = [];
                    }
                });

                if (currentParagraph.length > 0) {
                    structure.paragraphs.push(currentParagraph);
                }

                return structure;
            },

            // Intelligent structure detection
            detectStructure: function(response) {
                const structureMap = {
                    sections: {},
                    boundaries: [],
                    confidence: 0
                };

                // Look for explicit section markers
                const sectionPatterns = [
                    { name: 'summary', patterns: ['**SUMMARY**', '## SUMMARY', 'SUMMARY:', 'Summary:'] },
                    { name: 'analysis', patterns: ['**ANALYSIS**', '## ANALYSIS', 'ANALYSIS:', 'Analysis:'] },
                    { name: 'findings', patterns: ['**FINDINGS**', '## FINDINGS', 'FINDINGS:', 'Findings:'] },
                    { name: 'metrics', patterns: ['**METRICS**', '## METRICS', 'METRICS:', 'Metrics:'] },
                    { name: 'conclusions', patterns: ['**CONCLUSIONS**', '## CONCLUSIONS', 'CONCLUSIONS:', 'Conclusions:'] },
                    { name: 'actions', patterns: ['**ACTIONS**', '## ACTIONS', 'ACTIONS:', 'Actions:', 'Recommendations:'] }
                ];

                sectionPatterns.forEach(section => {
                    section.patterns.forEach(pattern => {
                        const index = response.indexOf(pattern);
                        if (index !== -1) {
                            structureMap.sections[section.name] = structureMap.sections[section.name] || [];
                            structureMap.sections[section.name].push({
                                start: index,
                                marker: pattern,
                                confidence: 1.0
                            });
                        }
                    });
                });

                // Look for implicit section boundaries
                const lines = response.split('\n');
                lines.forEach((line, index) => {
                    const trimmed = line.trim().toLowerCase();

                    // Look for section-like headers
                    if (trimmed.length > 0 && trimmed.length < 50 &&
                        !trimmed.includes('.') && !trimmed.includes('?') &&
                        (trimmed.includes('analysis') || trimmed.includes('finding') ||
                         trimmed.includes('metric') || trimmed.includes('conclusion'))) {
                        structureMap.boundaries.push({
                            line: index,
                            content: line.trim(),
                            confidence: 0.7
                        });
                    }
                });

                // Calculate overall structure confidence
                const explicitSections = Object.keys(structureMap.sections).length;
                const implicitBoundaries = structureMap.boundaries.length;
                structureMap.confidence = Math.min(1.0, (explicitSections * 0.3) + (implicitBoundaries * 0.1));

                return structureMap;
            },

            // Smart restructuring with content preservation
            smartRestructure: function(response, structureMap, contentAnalysis) {
                // If structure is already good, preserve it
                if (structureMap.confidence > 0.8) {
                    return this.preserveExistingStructure(response, structureMap);
                }

                // If structure needs work but content is good, enhance it
                if (contentAnalysis.quality > 70) {
                    return this.enhanceStructure(response, structureMap, contentAnalysis);
                }

                // If both need work, reconstruct carefully
                return this.reconstructStructure(response, contentAnalysis);
            },

            // Preserve existing good structure
            preserveExistingStructure: function(response, structureMap) {
                // Find the best instance of each section
                const sections = {};
                Object.entries(structureMap.sections).forEach(([sectionName, markers]) => {
                    if (markers.length > 0) {
                        // Use the first (highest confidence) marker
                        const marker = markers[0];
                        const nextSectionStart = this.findNextSectionStart(response, marker.start, structureMap);

                        sections[sectionName] = {
                            content: response.substring(marker.start, nextSectionStart),
                            originalStart: marker.start
                        };
                    }
                });

                // Rebuild with preserved content
                return this.rebuildWithSections(sections, response);
            },

            // Enhance existing structure
            enhanceStructure: function(response, structureMap, contentAnalysis) {
                let enhanced = response;

                // Add missing section headers
                const missingSections = this.identifyMissingSections(structureMap);
                missingSections.forEach(section => {
                    enhanced = this.addSectionHeader(enhanced, section, contentAnalysis);
                });

                // Improve formatting
                enhanced = this.improveFormatting(enhanced, contentAnalysis);

                return enhanced;
            },

            // Reconstruct structure for poorly formatted content
            reconstructStructure: function(response, contentAnalysis) {
                const lines = response.split('\n');
                const reconstructed = {
                    summary: [],
                    analysis: [],
                    findings: [],
                    metrics: [],
                    conclusions: [],
                    actions: []
                };

                let currentSection = 'summary';
                let inList = false;

                lines.forEach((line, index) => {
                    const trimmed = line.trim();
                    if (!trimmed) return;

                    // Detect section changes based on content patterns
                    const lowerLine = trimmed.toLowerCase();

                    if (lowerLine.includes('analysis') && !lowerLine.includes('findings')) {
                        currentSection = 'analysis';
                    } else if (lowerLine.includes('finding') || lowerLine.includes('observation')) {
                        currentSection = 'findings';
                    } else if (lowerLine.includes('metric') || (trimmed.includes(':') && /\d/.test(trimmed))) {
                        currentSection = 'metrics';
                    } else if (lowerLine.includes('conclusion') || lowerLine.includes('result')) {
                        currentSection = 'conclusions';
                    } else if (lowerLine.includes('action') || lowerLine.includes('recommend')) {
                        currentSection = 'actions';
                    } else {
                        // Add content to current section
                        reconstructed[currentSection].push(trimmed);
                    }
                });

                // Build structured output
                let result = '';
                Object.entries(reconstructed).forEach(([section, content]) => {
                    if (content.length > 0) {
                        result += `**${section.toUpperCase()}**\n${content.join('\n')}\n\n`;
                    }
                });

                return result.trim();
            },

            // Quality enhancement
            enhanceQuality: function(response, contentAnalysis) {
                let enhanced = response;

                // Improve formatting consistency
                enhanced = this.consistentFormatting(enhanced);

                // Enhance readability
                enhanced = this.improveReadability(enhanced);

                // Add missing context where helpful
                enhanced = this.addContextualEnhancements(enhanced, contentAnalysis);

                return enhanced;
            },

            // Validation and measurement
            validateAndMeasure: function(processed, original) {
                const preservationRate = (processed.length / original.length) * 100;
                this.processingStats.contentPreserved =
                    (this.processingStats.contentPreserved + preservationRate) / 2;

                // Ensure minimum quality standards
                if (processed.length < 100) {
                    console.warn('‚ö†Ô∏è Processed response too short, may have lost content');
                }

                // Validate structure
                const hasBasicStructure = /\*\*.*\*\*/.test(processed);
                if (!hasBasicStructure && original.length > 200) {
                    console.warn('‚ö†Ô∏è Processed response lacks expected structure');
                }

                return processed;
            },

            // Helper methods
            findNextSectionStart: function(response, currentPos, structureMap) {
                let nextPos = response.length;

                Object.values(structureMap.sections).forEach(markers => {
                    markers.forEach(marker => {
                        if (marker.start > currentPos && marker.start < nextPos) {
                            nextPos = marker.start;
                        }
                    });
                });

                return nextPos;
            },

            rebuildWithSections: function(sections, original) {
                const orderedSections = ['summary', 'analysis', 'findings', 'metrics', 'conclusions', 'actions'];
                let result = '';

                orderedSections.forEach(section => {
                    if (sections[section]) {
                        result += sections[section].content + '\n\n';
                    }
                });

                return result.trim() || original;
            },

            identifyMissingSections: function(structureMap) {
                const expectedSections = ['summary', 'analysis', 'findings', 'metrics', 'conclusions'];
                const presentSections = Object.keys(structureMap.sections);

                return expectedSections.filter(section => !presentSections.includes(section));
            },

            addSectionHeader: function(response, section, contentAnalysis) {
                // Intelligent header insertion based on content analysis
                const header = `**${section.toUpperCase()}**`;

                // Find appropriate insertion point
                const lines = response.split('\n');
                let insertIndex = Math.floor(lines.length / 2); // Default to middle

                // Look for contextual clues
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].toLowerCase();
                    if (section === 'metrics' && (line.includes('number') || line.includes('percent'))) {
                        insertIndex = i;
                        break;
                    }
                    if (section === 'findings' && (line.includes('found') || line.includes('observed'))) {
                        insertIndex = i;
                        break;
                    }
                }

                lines.splice(insertIndex, 0, '', header, '');
                return lines.join('\n');
            },

            improveFormatting: function(response, contentAnalysis) {
                let improved = response;

                // Ensure consistent bullet points
                improved = improved.replace(/^[\-\*]\s*/gm, '- ');

                // Fix spacing around headers
                improved = improved.replace(/(\*\*.*?\*\*)\n([^\n])/g, '$1\n\n$2');

                // Clean up excessive whitespace
                improved = improved.replace(/\n{3,}/g, '\n\n');

                return improved;
            },

            consistentFormatting: function(response) {
                // Ensure consistent header formatting
                let consistent = response.replace(/\*{1,2}(.*?)\*{1,2}/g, '**$1**');

                // Consistent list formatting
                consistent = consistent.replace(/^[\-\*]\s*/gm, '- ');

                // Consistent spacing
                consistent = consistent.replace(/\n{3,}/g, '\n\n');

                return consistent;
            },

            improveReadability: function(response) {
                // Break up long paragraphs
                const sentences = response.split(/[.!?]+/);
                let readable = '';

                let paragraph = '';
                sentences.forEach(sentence => {
                    paragraph += sentence.trim() + '. ';
                    if (paragraph.length > 200) {
                        readable += paragraph.trim() + '\n\n';
                        paragraph = '';
                    }
                });

                if (paragraph) {
                    readable += paragraph.trim();
                }

                return readable || response;
            },

            addContextualEnhancements: function(response, contentAnalysis) {
                // Add subtle enhancements based on content analysis
                let enhanced = response;

                // Add quality indicators
                if (contentAnalysis.quality > 80) {
                    enhanced = 'üü¢ High Quality Analysis\n\n' + enhanced;
                } else if (contentAnalysis.quality < 50) {
                    enhanced = 'üü° Processing Enhanced\n\n' + enhanced;
                }

                return enhanced;
            }
        };

        // ========================================
        // UPDATED RESPONSE PROCESSING
        // ========================================

        // Replace the old enforceReportStructure with enhanced processing
        function enforceReportStructure(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Use enhanced processor for better content preservation
            return enhancedResponseProcessor.process(response, 'council_member');
        }

        function evaluateTemplateLiterals(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            console.log('üîß Evaluating template literals in response...');
            
            // Get current context data for template substitution
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const changeCount = surveillanceState.changeCount || 0;
            const timestamp = new Date().toLocaleTimeString();
            const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
            const feedCount = aiFeeds.length;
            const memoryData = localStorage.getItem('ai_memory_state') || '{}';
            const memoryItems = Object.keys(JSON.parse(memoryData)).length;

            console.log(`üìä Context data - changeCount: ${changeCount}, canvasLength: ${canvasContent.length}, feedCount: ${feedCount}`);

            // Create evaluation context with all available data
            const context = {
                changeCount: changeCount,
                canvasContent: canvasContent,
                canvasLength: canvasContent.length,
                timestamp: timestamp,
                feedCount: feedCount,
                memoryItems: memoryItems,
                wordCount: canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length,
                lineCount: canvasContent.split('\n').length,
                activityLevel: calculateActivityLevel(canvasContent, feedCount, canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length),
                dataDensity: (canvasContent.split('\n').length > 0) ? (canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length / canvasContent.split('\n').length).toFixed(1) : '0.0'
            };

            try {
                // Replace template literals with actual values
                let evaluatedResponse = response;

                // Check if response contains template literals
                const hasTemplates = /\$\{[^}]+\}/.test(evaluatedResponse);
                console.log(`üîç Response contains template literals: ${hasTemplates}`);

                // Handle common template patterns
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount\}/g, context.changeCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{canvasContent\.length\}/g, context.canvasLength);
                evaluatedResponse = evaluatedResponse.replace(/\$\{timestamp\}/g, context.timestamp);
                evaluatedResponse = evaluatedResponse.replace(/\$\{feedCount\}/g, context.feedCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{memoryItems\}/g, context.memoryItems);
                evaluatedResponse = evaluatedResponse.replace(/\$\{wordCount\}/g, context.wordCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{lineCount\}/g, context.lineCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{activityLevel\}/g, context.activityLevel);
                evaluatedResponse = evaluatedResponse.replace(/\$\{dataDensity\}/g, context.dataDensity);

                // Handle conditional template expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount > 5 \? 'high' : 'moderate'\}/g, context.changeCount > 5 ? 'high' : 'moderate');
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount > 10 \? 'mature' : changeCount > 5 \? 'growing' : 'initial'\}/g, context.changeCount > 10 ? 'mature' : context.changeCount > 5 ? 'growing' : 'initial');
                evaluatedResponse = evaluatedResponse.replace(/\$\{canvasLength > 1000 \? 'complex' : 'emerging'\}/g, context.canvasLength > 1000 ? 'complex' : 'emerging');
                evaluatedResponse = evaluatedResponse.replace(/\$\{text\.includes\('governance'\) \? 'specific rules' : 'overall strategy'\}/g, canvasContent.toLowerCase().includes('governance') ? 'specific rules' : 'overall strategy');
                evaluatedResponse = evaluatedResponse.replace(/\$\{feedCount > 0 \? 'ACTIVE' : 'IDLE'\}/g, context.feedCount > 0 ? 'ACTIVE' : 'IDLE');
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(changeCount \* 15, 100\)\}/g, Math.min(context.changeCount * 15, 100));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(changeCount, 10\)\}/g, Math.min(context.changeCount, 10));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(canvasLength \/ 100, 100\)\}/g, Math.min(context.canvasLength / 100, 100));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(wordCount \/ 10, 100\)\}/g, Math.min(context.wordCount / 10, 100));

                // Handle more complex expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount \* 10 \% 100\}/g, (context.changeCount * 10) % 100);
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.abs\(canvasLength - \d+\)\}/g, (match) => {
                    const targetLength = parseInt(match.match(/\d+/)[0]);
                    return Math.abs(context.canvasLength - targetLength);
                });

                // Handle array length expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{aiFeeds\.length\}/g, context.feedCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{Array\.isArray\(analysis\.data\) \? analysis\.data\.length : 'N\/A'\}/g, 'N/A'); // Default to N/A for unknown data

                return evaluatedResponse;
            } catch (error) {
                console.warn('Template literal evaluation failed:', error);
                return response; // Return original response if evaluation fails
            }
        }

        // ========================================
        // COUNCIL MEMORY SYSTEM
        // ========================================

        const councilMemories = {
            pattern: [],
            wisdom: [],
            paradox: [],
            boundaries: [],
            memory: []
        };

        function initializeCouncilMemories() {
            // Initialize fresh memories each session for optimal analysis
            updateCouncilStatusDisplay();
        }

        function storeCouncilMemory(memberKey, analysis, context) {
            const memory = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                analysis: analysis,
                context: context,
                eventType: context.type || 'unknown',
                canvasLength: context.canvasLength || 0,
                insights: extractInsightsFromAnalysis(analysis)
            };

            councilMemories[memberKey].push(memory);

            // Keep last 50 memories per member
            if (councilMemories[memberKey].length > 50) {
                councilMemories[memberKey] = councilMemories[memberKey].slice(-50);
            }

            // Session-only memories - no persistence for fresh analysis each session
            updateCouncilStatusDisplay();
        }

        function extractInsightsFromAnalysis(analysis) {
            const insights = [];

            // Extract key patterns from analysis
            const patterns = analysis.match(/(?:pattern|trend|behavior|issue|concern|opportunity|risk)[\w\s]{10,50}/gi) || [];
            insights.push(...patterns.slice(0, 3));

            // Extract metrics
            const metrics = analysis.match(/\d+[%]?|\b(?:high|low|critical|normal)\b/gi) || [];
            insights.push(...metrics.slice(0, 3));

            return insights;
        }

        function getRelevantMemories(memberKey, currentContext) {
            const memories = councilMemories[memberKey] || [];
            if (memories.length < 3) return []; // Don't use memories until we have some history

            // Only find memories if there's a strong contextual match
            const relevantMemories = memories.filter(memory => {
                // Same event type
                if (currentContext.type && memory.eventType === currentContext.type) return true;

                // Similar content size (major changes only)
                if (currentContext.canvasLength && memory.canvasLength > 0) {
                    const sizeDiff = Math.abs(memory.canvasLength - currentContext.canvasLength);
                    if (sizeDiff < 500 && currentContext.canvasLength > 2000) return true; // Similar substantial content
                }

                // Look for recurring insights/patterns
                if (memory.insights && memory.insights.length > 0) {
                    const currentAnalysis = currentContext.analysis || '';
                    const hasMatchingInsight = memory.insights.some(insight =>
                        currentAnalysis.toLowerCase().includes(insight.toLowerCase().substring(0, 20))
                    );
                    if (hasMatchingInsight) return true;
                }

                return false;
            });

            // Only return memories if we found genuinely relevant ones
            if (relevantMemories.length === 0) return [];

            return relevantMemories
                .slice(-5) // Maximum 5 relevant memories
                .map(memory => ({
                    timestamp: new Date(memory.timestamp).toLocaleTimeString(),
                    analysis: memory.analysis.substring(0, 150),
                    insights: memory.insights.slice(0, 2),
                    relevance: memory.eventType === currentContext.type ? 'high' : 'medium'
                }));
        }

        function shouldUseMemories(memberKey, currentContext) {
            const relevantMemories = getRelevantMemories(memberKey, currentContext);
            return relevantMemories.length > 0;
        }

        function updateCouncilStatusDisplay() {
            const statusElement = document.getElementById('councilMemberStatus');
            if (!statusElement) return;

            const statusHTML = [
                `PATTERN: ‚úÖ (${councilMemories.pattern.length} memories)`,
                `WISDOM: ‚úÖ (${councilMemories.wisdom.length} memories)`,
                `PARADOX: ‚úÖ (${councilMemories.paradox.length} memories)`,
                `BOUNDARIES: ‚úÖ (${councilMemories.boundaries.length} memories)`,
                `MEMORY: ‚úÖ (${councilMemories.memory.length} memories)`
            ].join('<br>');

            statusElement.innerHTML = statusHTML;
        }

        // ========================================
        // COLLABORATIVE ANALYSIS HELPERS
        // ========================================

        function extractKeyInsights(responses) {
            const insights = {
                patterns: [],
                metrics: [],
                concerns: [],
                recommendations: [],
                crossReferences: []
            };

            responses.forEach(response => {
                if (!response || response.error) return;

                const text = response.response || '';
                const memberType = response.member || 'unknown';

                // Extract metrics (numbers, percentages, specific measurements)
                const metricMatches = text.match(/\d+[%]?|\b(?:high|low|critical|normal|optimal|severe)\b/gi) || [];
                insights.metrics.push(...metricMatches.map(m => `${memberType}: ${m}`));

                // Extract pattern keywords
                const patternMatches = text.match(/(?:pattern|trend|behavior|cycle|routine|structure|framework|system|model|approach|method)\s+[a-z\s]{5,30}/gi) || [];
                insights.patterns.push(...patternMatches.map(m => `${memberType}: ${m.trim()}`));

                // Extract concerns and issues
                const concernMatches = text.match(/(?:concern|issue|problem|risk|threat|vulnerability|challenge|limitation|gap|error|failure)\s+[a-z\s]{5,40}/gi) || [];
                insights.concerns.push(...concernMatches.map(m => `${memberType}: ${m.trim()}`));

                // Extract recommendations and actions
                const actionMatches = text.match(/(?:recommend|suggest|propose|should|must|need to|implement|consider|improve|optimize|enhance|address)\s+[a-z\s]{5,50}/gi) || [];
                insights.recommendations.push(...actionMatches.map(m => `${memberType}: ${m.trim()}`));

                // Look for cross-references to other systems or concepts
                const crossRefMatches = text.match(/(?:connects to|relates to|correlates with|links to|impacts|influences|depends on|affects)\s+[a-z\s]{5,30}/gi) || [];
                insights.crossReferences.push(...crossRefMatches.map(m => `${memberType}: ${m.trim()}`));
            });

            // Remove duplicates and limit size
            Object.keys(insights).forEach(key => {
                insights[key] = [...new Set(insights[key])].slice(0, 5);
            });

            return insights;
        }

        function enhancePromptWithInsights(basePrompt, priorInsights, memberType) {
            const relevantInsights = filterInsightsForMember(priorInsights, memberType);

            if (relevantInsights.length === 0) {
                return basePrompt;
            }

            const insightContext = `\n\n=== COUNCIL COLLABORATION CONTEXT ===\nPrior analysis from other council members revealed:\n${relevantInsights.join('\n')}\n\nBuild upon these insights in your analysis. Look for correlations, contradictions, or complementary perspectives. Your unique ${memberType} perspective should enhance and connect with these findings.\n========================\n\n`;

            return basePrompt + insightContext;
        }

        function filterInsightsForMember(insights, memberType) {
            const relevantInsights = [];

            // Each member type gets different types of insights to build upon
            switch(memberType) {
                case 'paradox':
                    // Paradox looks for contradictions and tensions
                    relevantInsights.push(...insights.patterns);
                    relevantInsights.push(...insights.concerns);
                    break;

                case 'boundaries':
                    // Boundaries examines limits and constraints
                    relevantInsights.push(...insights.metrics);
                    relevantInsights.push(...insights.recommendations);
                    break;

                case 'memory':
                    // Memory synthesizes all insights
                    relevantInsights.push(...insights.patterns);
                    relevantInsights.push(...insights.crossReferences);
                    relevantInsights.push(...insights.concerns);
                    break;

                default:
                    // Default gets a mix
                    relevantInsights.push(...insights.patterns.slice(0, 2));
                    relevantInsights.push(...insights.metrics.slice(0, 2));
                    break;
            }

            return relevantInsights.slice(0, 6); // Limit to prevent prompt bloat
        }

        function synthesizeCollaborativeConsensus(responses, analysis, insightHistory) {
            // First get standard consensus
            const baseConsensus = synthesizeConsensus(responses, analysis);

            // Enhance with cross-pollination analysis
            const collaborationMetrics = analyzeCollaboration(insightHistory);

            // Add collaboration insights to consensus
            baseConsensus.collaborationScore = collaborationMetrics.score;
            baseConsensus.crossPollination = collaborationMetrics.connections;
            baseConsensus.emergentInsights = collaborationMetrics.emergentPatterns;

            return baseConsensus;
        }

        function analyzeCollaboration(insightHistory) {
            const connections = [];
            let score = 0;
            const emergentPatterns = [];

            // Analyze how insights evolved across stages
            if (insightHistory.stage1Insights && insightHistory.stage2Insights) {
                // Look for build-up patterns
                const stage1Patterns = new Set(insightHistory.stage1Insights.patterns);
                const stage2Patterns = new Set(insightHistory.stage2Insights.patterns);

                // Find connections
                stage1Patterns.forEach(pattern => {
                    if ([...stage2Patterns].some(p2 => p2.includes(pattern.split(':')[1]?.trim()))) {
                        connections.push(`Pattern evolution: ${pattern}`);
                        score += 10;
                    }
                });

                // Look for emergent insights (unique to later stages)
                const stage2Unique = [...stage2Patterns].filter(p =>
                    ![...stage1Patterns].some(p1 => p.includes(p1.split(':')[1]?.trim()))
                );
                emergentPatterns.push(...stage2Unique.slice(0, 3));
            }

            // Calculate collaboration effectiveness
            score += connections.length * 5;
            score += emergentPatterns.length * 8;
            score = Math.min(score, 100); // Cap at 100

            return {
                score,
                connections,
                emergentPatterns
            };
        }

        async function synthesizeConsensus(responses, analysis) {
            const validResponses = responses.filter(r => !r.error);

            if (validResponses.length === 0) {
                return {
                    status: 'FAILED',
                    summary: 'Council analysis failed - no valid responses',
                    confidence: 0
                };
            }

            // Create AI-powered consensus synthesis prompt
            const consensusPrompt = `DJINN COUNCIL CONSENSUS SYNTHESIS
SESSION: ${djinnCouncilMemory.sessionId}

COUNCIL ANALYSES (${validResponses.length} members):
${validResponses.map(r => `
[${councilMembers[r.member].name.toUpperCase()}]
${r.response.substring(0, 500)}${r.response.length > 500 ? '...' : ''}
`).join('\n')}

CRITICAL REQUIREMENTS:
- SYNTHESIZE new insights from member analyses (do not repeat member content)
- Identify PATTERNS ACROSS all members (not individual findings)
- Create COLLABORATIVE conclusions that emerge from cross-pollination
- Focus on SYSTEMIC themes, not individual member observations

Output concise synthesis (max 600 words):

**SYNTHESIS OVERVIEW**
[2-3 sentences synthesizing collective insights - what emerges when all members' perspectives are combined?]

**CROSS-MEMBER PATTERNS**
‚Ä¢ [Pattern that appears across multiple members]
‚Ä¢ [Systemic theme identified in the collective analysis]
‚Ä¢ [Collaborative insight that emerges from cross-pollination]

**EMERGENT INSIGHTS**
‚Ä¢ [New insight that emerges from combining member perspectives]
‚Ä¢ [Collaborative conclusion not present in individual analyses]
‚Ä¢ [Systemic pattern revealed through council integration]

**RISK ASSESSMENT**
[Synthesized risk evaluation considering all member perspectives together]

**STRATEGIC RECOMMENDATIONS**
1. [Recommendation based on collective council wisdom]
2. [Cross-member optimization strategy]
3. [Systemic improvement derived from council synthesis]

**CONFIDENCE LEVEL**
[High/Medium/Low with justification based on consensus strength]

Keep under 600 words. Focus on SYNTHESIS, not repetition. Create NEW insights from COLLABORATION.`;

            try {
                // Use gemma3:1b for consensus synthesis
                const consensusResponse = await queryOllama('gemma3:1b', consensusPrompt);

                // Parse the AI-generated consensus
                const synthesisMatch = consensusResponse.match(/\*\*SYNTHESIS OVERVIEW\*\*(.*?)(?=\*\*CROSS-MEMBER PATTERNS\*\*|$)/s);
                const patternsMatch = consensusResponse.match(/\*\*CROSS-MEMBER PATTERNS\*\*(.*?)(?=\*\*EMERGENT INSIGHTS\*\*|$)/s);
                const insightsMatch = consensusResponse.match(/\*\*EMERGENT INSIGHTS\*\*(.*?)(?=\*\*RISK ASSESSMENT\*\*|$)/s);
                const riskMatch = consensusResponse.match(/\*\*RISK ASSESSMENT\*\*(.*?)(?=\*\*STRATEGIC RECOMMENDATIONS\*\*|$)/s);
                const recommendationsMatch = consensusResponse.match(/\*\*STRATEGIC RECOMMENDATIONS\*\*(.*?)(?=\*\*CONFIDENCE LEVEL\*\*|$)/s);
                const confidenceMatch = consensusResponse.match(/\*\*CONFIDENCE LEVEL\*\*(.*)$/s);

                const synthesis = synthesisMatch ? synthesisMatch[1].trim() : 'Consensus synthesis completed';
                const patterns = patternsMatch ? patternsMatch[1].trim() : 'Cross-member analysis completed';
                const insights = insightsMatch ? insightsMatch[1].trim() : 'Emergent insights identified';
                const riskAssessment = riskMatch ? riskMatch[1].trim() : 'Risk assessment completed';
                const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : 'Strategic recommendations provided';
                const confidence = confidenceMatch ? confidenceMatch[1].trim() : 'High';

                // Calculate confidence score from AI response
                let confidenceScore = 0.7; // Default medium confidence
                if (confidence.toLowerCase().includes('high')) confidenceScore = 0.9;
                else if (confidence.toLowerCase().includes('low')) confidenceScore = 0.4;

                // Extract key insights from each member response for display
                const memberInsights = validResponses.map(r => {
                    const memberName = councilMembers[r.member].name;
                    const response = r.response;

                    // Parse metrics more intelligently
                    let formattedMetrics = 'No metrics available';
                    let formattedAnalysis = 'No analysis available';

                    // Extract metrics section
                    const metricsMatch = response.match(/\*\*METRICS\*\*(.*?)(?=\*\*ANALYSIS\*\*|\*\*CONCLUSIONS\*\*|\*\*ACTIONS\*\*|$)/s);
                    if (metricsMatch) {
                        const metricsText = metricsMatch[1].trim();
                        const metricLines = metricsText.split('\n').filter(line => line.trim() && !line.includes('**') && !line.includes('['));

                        // Parse each metric line into structured format
                        const parsedMetrics = metricLines.map(line => {
                            // Handle metric lines with values and justifications
                            const valueMatch = line.match(/^([^:]+):\s*([^,]+)(?:,\s*Justification:\s*(.+))?$/);
                            if (valueMatch) {
                                const metricName = valueMatch[1].trim();
                                const metricValue = valueMatch[2].trim();
                                const justification = valueMatch[3] ? valueMatch[3].trim() : null;

                                if (justification) {
                                    return `<div style="margin: 2px 0;"><strong>${metricName}:</strong> <span style="color: #ffff00;">${metricValue}</span><br><small style="color: #cccccc;">${justification}</small></div>`;
                                } else {
                                    return `<strong>${metricName}:</strong> <span style="color: #ffff00;">${metricValue}</span>`;
                                }
                            }

                            // Fallback for other formats
                            const colonMatch = line.match(/^([^:]+):\s*(.+)$/);
                            if (colonMatch) {
                                const key = colonMatch[1].trim();
                                const value = colonMatch[2].trim();
                                return `<strong>${key}:</strong> ${value}`;
                            }
                            return line.trim();
                        }).filter(metric => metric.length > 0);

                        formattedMetrics = parsedMetrics.join('') || 'No metrics available';
                    }

                    // Extract analysis section (clean version without frameworks)
                    const analysisMatch = response.match(/\*\*ANALYSIS\*\*(.*?)(?=\*\*FINDINGS\*\*|\*\*CONCLUSIONS\*\*|\*\*ACTIONS\*\*|$)/s);
                    if (analysisMatch) {
                        let analysisText = analysisMatch[1].trim();
                        // Clean up the analysis text more thoroughly
                        analysisText = analysisText
                            .replace(/\*\*CONCLUSIONS\*\*.*/s, '') // Remove conclusions section
                            .replace(/\*\*ACTIONS\*\*.*/s, '') // Remove actions section
                            .replace(/^\s*[-‚Ä¢*]\s*/gm, '') // Remove bullet points
                            .replace(/\s+/g, ' ') // Normalize whitespace
                            .replace(/\*\*.*?\*\*/g, '') // Remove any remaining bold markers
                            .trim();

                        formattedAnalysis = analysisText || 'Analysis not available';
                    }

                    return `<div style="margin: 6px 0; padding: 6px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                        <strong>${memberName}:</strong><br>
                        <div style="margin: 4px 0; color: #00ff88; font-size: 10px;">${formattedMetrics}</div>
                        <div style="margin: 4px 0; color: #ffffff; font-size: 11px; line-height: 1.3;">${formattedAnalysis}</div>
                    </div>`;
                }).join('');

                // Build AI-powered consensus object
                const consensusResult = {
                    status: 'APPROVED',
                    summary: synthesis,
                    confidence: confidenceScore,
                    theme: 'ai_synthesized_consensus',
                    responses: validResponses,
                    crossMemberPatterns: patterns,
                    emergentInsights: insights,
                    riskAssessment: { overall: riskAssessment },
                    recommendations: recommendations.split('\n').filter(line => line.trim().startsWith('1.') || line.trim().startsWith('2.') || line.trim().startsWith('3.')).map(line => line.trim().substring(3).trim()),
                    collaborationScore: Math.round(confidenceScore * 100),
                    crossPollination: patterns.split('‚Ä¢').filter(item => item.trim()).slice(0, 3).map(item => item.trim()),
                    emergentInsights: insights.split('‚Ä¢').filter(item => item.trim()).slice(0, 2).map(item => item.trim())
                };

                // Add collaboration metrics
                const collaborationSection = `
                    <strong>üîÑ AI-POWERED COLLABORATIVE SYNTHESIS</strong><br>
                    <div style="margin: 8px 0; padding: 8px; background: rgba(0, 170, 255, 0.1); border-left: 3px solid #00aaff; border-radius: 4px;">
                        <div style="color: #00ff88; font-weight: bold;">AI Synthesis Confidence: ${Math.round(confidenceScore * 100)}%</div>
                        <div style="margin-top: 4px; font-size: 10px;">Cross-Member Patterns: ${consensusResult.crossPollination?.length || 0} identified</div>
                        <div style="margin-top: 4px; font-size: 10px; color: #ff88ff;">Emergent Insights: ${consensusResult.emergentInsights?.length || 0} synthesized</div>
                    </div>`;

                // Update consensus display with AI-synthesized insights
                const consensusHTML = `
                    <div class="intel-entry intel-insight">
                        <div class="intel-timestamp">${new Date().toLocaleTimeString()}</div>
                        <strong>üß† AI-SYNTHESIZED COUNCIL CONSENSUS</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(204, 136, 204, 0.1); border-left: 3px solid #cc88cc; border-radius: 4px;">
                            ${synthesis}
                        </div>
                        <strong>üîç MEMBER ANALYSES</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(0, 255, 136, 0.1); border-left: 3px solid #00ff88; border-radius: 4px;">
                            ${memberInsights}
                        </div>
                        ${collaborationSection}
                        <strong>üéØ AI RISK ASSESSMENT</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255, 170, 0, 0.1); border-left: 3px solid #ffaa00; border-radius: 4px;">
                            ${riskAssessment}
                        </div>
                        <strong>üìã AI STRATEGIC RECOMMENDATIONS</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255, 136, 255, 0.1); border-left: 3px solid #ff88ff; border-radius: 4px;">
                            ${recommendations}
                        </div>
                    </div>
                `;

                document.getElementById('consensusFeed').innerHTML = consensusHTML + document.getElementById('consensusFeed').innerHTML;

                return consensusResult;

            } catch (error) {
                console.error('AI consensus synthesis failed:', error);

                // Fallback to basic consensus if AI fails
                const themes = {
                    governance_gap: 0,
                    performance_issue: 0,
                    innovation_opportunity: 0,
                    sovereignty_concern: 0,
                    memory_anomaly: 0
                };

                validResponses.forEach(r => {
                    const text = r.response.toLowerCase();
                    if (text.includes('governance') || text.includes('authority')) themes.governance_gap++;
                    if (text.includes('performance') || text.includes('efficiency')) themes.performance_issue++;
                    if (text.includes('innovation') || text.includes('opportunity')) themes.innovation_opportunity++;
                    if (text.includes('autonomy') || text.includes('sovereignty')) themes.sovereignty_concern++;
                    if (text.includes('memory') || text.includes('retention')) themes.memory_anomaly++;
                });

                const primaryTheme = Object.entries(themes).sort((a, b) => b[1] - a[1])[0][0];
                const confidence = validResponses.length / 5;

                const summary = `AI synthesis failed - using basic consensus. Primary concern: ${primaryTheme.replace('_', ' ')}. Confidence: ${(confidence * 100).toFixed(0)}%.`;

                return {
                    status: 'DEGRADED',
                    summary: summary,
                    confidence: confidence,
                    theme: primaryTheme,
                    responses: validResponses,
                    error: 'AI synthesis unavailable'
                };
            }
        }

        // ========================================
        // INTELLIGENCE MANAGEMENT
        // ========================================

        async function generateIntelligenceEntry(analysis, consensus) {
            const severity = consensus.confidence > 0.8 ? 'critical' :
                           consensus.confidence > 0.6 ? 'warning' : 'insight';

            // Generate unified AI-powered intelligence report
            let intelligenceReport;
            try {
                intelligenceReport = await generateUnifiedIntelligence(analysis, consensus);
            } catch (error) {
                console.error('Intelligence generation failed:', error);
                intelligenceReport = {
                    actionable: ['Intelligence synthesis failed', 'Manual analysis required', 'Check system logs'],
                    correlations: 'Analysis failed due to AI synthesis error',
                    recommendations: 'Manual intelligence assessment needed',
                    risk_assessment: 'Unable to assess risks automatically',
                    strategic_implications: 'Strategic analysis unavailable'
                };
            }

            return {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                type: analysis.type || 'intelligence_report',
                severity: severity,
                theme: consensus.theme || 'intelligence_synthesis',
                summary: consensus.summary || 'AI-powered intelligence analysis completed',
                data: analysis.data,
                consensus: consensus,
                actionable: intelligenceReport.actionable,
                correlations: intelligenceReport.correlations,
                recommendations: intelligenceReport.recommendations,
                risk_assessment: intelligenceReport.risk_assessment,
                strategic_implications: intelligenceReport.strategic_implications
            };
        }

        async function generateUnifiedIntelligence(analysis, consensus) {
            // Determine if we have council consensus data or need standalone analysis
            const hasConsensus = consensus && consensus.responses && consensus.responses.length > 0;

            if (hasConsensus) {
                try {
                    // Use council-based intelligence synthesis
                    const allResponses = consensus.responses || [];
                    const responseTexts = allResponses.map(r => `${councilMembers[r.member].name}: ${r.response}`).join('\n\n');

                    const intelPrompt = `COMPREHENSIVE CANVAS INTELLIGENCE SYNTHESIS

You are analyzing the complete ecosystem: document evolution, dashboard state, memory banks, and insights.

DJINN COUNCIL COMPREHENSIVE ANALYSIS:
${responseTexts.substring(0, 2000)}

COMPLETE SYSTEM STATE:
Summary: ${consensus.summary || 'Comprehensive analysis completed'}
Confidence Level: ${(consensus.confidence * 100).toFixed(1)}%
Primary Theme: ${consensus.theme || 'Ecosystem analysis'}

MEMORY BANK STATUS:
- Council Memory Reports: ${Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0)} total reports across all members
- AI System Memory: ${Object.keys(JSON.parse(localStorage.getItem('ai_memory_state') || '{}')).length} systems with stored memories
- Canvas Content: ${JSON.stringify(analysis.data).length} characters
- Dashboard Metrics: Active surveillance and monitoring

ANALYSIS SCOPE: Document evolution + Complete memory analysis + Dashboard monitoring + All insights synthesis

[INTELLIGENCE ASSESSMENT]
What patterns emerge from the complete ecosystem analysis? Consider: canvas content evolution, memory bank trends across all 25 reports per agent, dashboard metrics, stored insights, and cross-system correlations. What does the comprehensive data reveal?

[RISK EVALUATION]
What risks exist across the entire ecosystem? Analyze: content development trajectory, memory fragmentation across agents, insight accumulation patterns, dashboard anomalies, and system coherence issues.

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [Document/content development action based on comprehensive analysis]
‚Ä¢ [Memory management or insight synthesis improvement]
‚Ä¢ [Dashboard monitoring or metric optimization strategy]

[STRATEGIC IMPLICATIONS]
How should the complete canvas ecosystem evolve? What does the analysis of all memories, insights, dashboard state, and content patterns suggest for strategic development?

REQUIREMENTS: Synthesize insights from ALL data sources - document content, memory banks, dashboard metrics, and stored insights. Focus on comprehensive ecosystem intelligence.`;
                    const intelligenceResponse = await queryOllama('gemma3:1b', intelPrompt);

                    // Parse the structured response
                    const correlations = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s)?.[1]?.trim() || 'No correlations identified';
                    const riskAssessment = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s)?.[1]?.trim() || 'Risk assessment unavailable';
                    const recommendations = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s)?.[1]?.trim() || 'No recommendations available';
                    const strategic = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s)?.[1]?.trim() || 'Strategic analysis pending';

                    // Format recommendations as array
                    const actionableItems = recommendations.split('\n')
                        .filter(line => line.trim().startsWith('‚Ä¢'))
                        .map(line => line.trim().substring(1).trim())
                        .filter(item => item.length > 0);

                    return {
                        actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review council consensus'],
                        correlations: correlations,
                        recommendations: recommendations,
                        risk_assessment: riskAssessment,
                        strategic_implications: strategic
                    };

                } catch (error) {
                    console.error('Council-based intelligence synthesis failed:', error);
                    // Fall back to standalone analysis
                }
            }

            // Standalone intelligence analysis (fallback or when no consensus available)
            const canvasContent = analysis.data?.content || localStorage.getItem('sovereign_canvas_content') || '';

            const standalonePrompt = `INTELLIGENCE ANALYSIS

REAL AI SYSTEMS STATUS (ONLY THESE SYSTEMS EXIST):
${Object.entries(djinnCouncilMemory.canvasAISystems).map(([systemName, systemData]) => {
    const interactionCount = systemData.interactions ? systemData.interactions.length : 0;
    return `${systemName.toUpperCase()}: ${interactionCount} tracked interactions`;
}).join('\n')}

CANVAS CONTENT:
${canvasContent.substring(0, 1500)}${canvasContent.length > 1500 ? '\n[Content truncated]' : ''}

THREE-LAYER FRAMEWORK:
- LAYER 1: AI SYSTEMS (ONLY narra, nazar, whale, djinn, watchtower systems)
- LAYER 2: CANVAS CONTENT (data being analyzed)
- LAYER 3: EVOLUTION (content changes over time)

CRITICAL: Only analyze the 5 real AI systems listed above. Do NOT invent or reference any other systems.

Provide concise intelligence analysis (max 500 words):

[INTELLIGENCE ASSESSMENT]
[Analysis of the 5 real AI systems and their interaction with canvas content]

[RISK EVALUATION]
[Risks in the 5 AI systems operations vs. content processes]

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [Recommendation for the real AI systems]
‚Ä¢ [Content evolution recommendation]
‚Ä¢ [Interaction optimization for real systems]

[STRATEGIC IMPLICATIONS]
[Broader implications for all layers]`;

            try {
                const intelligenceResponse = await queryOllama('gemma3:1b', standalonePrompt);

                // Parse the structured response
                const assessmentMatch = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s);
                const riskMatch = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s);
                const recommendationsMatch = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s);
                const strategicMatch = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s);

                const assessment = assessmentMatch ? assessmentMatch[1].trim() : 'Intelligence assessment completed';
                const riskAssessment = riskMatch ? riskMatch[1].trim() : 'Risk evaluation completed';
                const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : 'Recommendations provided';
                const strategic = strategicMatch ? strategicMatch[1].trim() : 'Strategic analysis completed';

                // Format recommendations as array
                const actionableItems = recommendations.split('\n')
                    .filter(line => line.trim().startsWith('‚Ä¢'))
                    .map(line => line.trim().substring(1).trim())
                    .filter(item => item.length > 0);

                return {
                    actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review AI system performance'],
                    correlations: assessment,
                    recommendations: recommendations,
                    risk_assessment: riskAssessment,
                    strategic_implications: strategic
                };

            } catch (error) {
                console.error('Standalone intelligence generation failed:', error);
                // Fallback analysis
                return {
                    actionable: [
                        'AI intelligence synthesis failed - using basic analysis',
                        'Manual review of AI systems recommended',
                        'Monitor canvas content for emerging patterns'
                    ],
                    correlations: 'Basic intelligence assessment due to synthesis failure',
                    recommendations: 'Manual intelligence analysis required',
                    risk_assessment: 'Unable to assess risks automatically - manual review needed',
                    strategic_implications: 'Strategic intelligence analysis unavailable'
                };
            }
        }

        async function generateStandaloneIntelligence(analysis) {
            // Get current AI memory and canvas data for standalone analysis
            const canvasContent = analysis.data?.content || localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemoryData = analysis.data?.memory || localStorage.getItem('ai_memory_state') || '{}';

            let parsedMemory = {};
            try {
                parsedMemory = JSON.parse(aiMemoryData);
            } catch (e) {
                console.warn('Failed to parse AI memory for intelligence:', e);
            }

            const standalonePrompt = `INTELLIGENCE ANALYSIS

AI SYSTEMS STATUS:
${Object.entries(parsedMemory).map(([systemName, systemData]) => {
    const memoryCount = systemData?.conversationHistory?.length || 0;
    const insightCount = systemData?.keyInsights?.length || 0;
    return `${systemName.toUpperCase()}: ${memoryCount} interactions, ${insightCount} insights`;
}).join('\n')}

CANVAS CONTENT:
${canvasContent.substring(0, 1500)}${canvasContent.length > 1500 ? '\n[Content truncated]' : ''}

THREE-LAYER FRAMEWORK:
- LAYER 1: AI SYSTEMS (performance, memory)
- LAYER 2: CANVAS CONTENT (data being analyzed)
- LAYER 3: EVOLUTION (content changes over time)

Provide concise intelligence analysis (max 500 words):

[INTELLIGENCE ASSESSMENT]
[Analysis differentiating AI systems from content evolution]

[RISK EVALUATION] 
[Risks in AI operations vs. content processes]

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [AI system recommendation]
‚Ä¢ [Content evolution recommendation]
‚Ä¢ [Interaction optimization]

[STRATEGIC IMPLICATIONS]
[Broader implications for all layers]

Keep under 500 words.`;

            try {
                // Use gemma3:1b for standalone intelligence analysis
                const intelligenceResponse = await queryOllama('gemma3:1b', standalonePrompt);

                // Parse the structured response
                const assessmentMatch = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s);
                const riskMatch = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s);
                const recommendationsMatch = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s);
                const strategicMatch = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s);

                const assessment = assessmentMatch ? assessmentMatch[1].trim() : 'Intelligence assessment completed';
                const riskAssessment = riskMatch ? riskMatch[1].trim() : 'Risk evaluation completed';
                const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : 'Recommendations provided';
                const strategic = strategicMatch ? strategicMatch[1].trim() : 'Strategic analysis completed';

                // Format recommendations as array
                const actionableItems = recommendations.split('\n')
                    .filter(line => line.trim().startsWith('‚Ä¢'))
                    .map(line => line.trim().substring(1).trim())
                    .filter(item => item.length > 0);

                return {
                    actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review AI system performance'],
                    correlations: assessment,
                    recommendations: recommendations,
                    risk_assessment: riskAssessment,
                    strategic_implications: strategic
                };

            } catch (error) {
                console.error('Standalone intelligence generation failed:', error);
                // Fallback analysis
                return {
                    actionable: [
                        'AI intelligence synthesis failed - using basic analysis',
                        'Manual review of AI systems recommended',
                        'Monitor canvas content for emerging patterns'
                    ],
                    correlations: 'Basic intelligence assessment due to synthesis failure',
                    recommendations: 'Manual intelligence analysis required',
                    risk_assessment: 'Unable to assess risks automatically - manual review needed',
                    strategic_implications: 'Strategic intelligence analysis unavailable'
                };
            }
        }

        async function generateAIPoweredIntel(analysis, consensus) {
            // Compile all council member responses and analysis data
            const allResponses = consensus.responses || [];
            const responseTexts = allResponses.map(r => `${councilMembers[r.member].name}: ${r.response}`).join('\n\n');

            const intelPrompt = `INTELLIGENCE SYNTHESIS

COUNCIL ANALYSES:
${responseTexts.substring(0, 2000)}${responseTexts.length > 2000 ? '\n[Analyses truncated]' : ''}

SYSTEM DATA:
Content: ${JSON.stringify(analysis.data).length} chars
Confidence: ${(consensus.confidence * 100).toFixed(1)}%

Synthesize intelligence (max 400 words):

[INTELLIGENCE ASSESSMENT]
[Key correlations and patterns]

[RISK EVALUATION]
[Risk assessment]

[ACTIONABLE RECOMMENDATIONS]
‚Ä¢ [Specific actionable item 1]
‚Ä¢ [Specific actionable item 2]
‚Ä¢ [Specific actionable item 3]

[STRATEGIC IMPLICATIONS]
[Strategic analysis]`;

            try {
                // Use gemma3:1b for intelligence synthesis
                const intelligenceResponse = await queryOllama('gemma3:1b', intelPrompt);

                // Parse the structured response
                const correlations = intelligenceResponse.match(/\[INTELLIGENCE ASSESSMENT\](.*?)(?=\[RISK EVALUATION\]|$)/s)?.[1]?.trim() || 'No correlations identified';
                const riskAssessment = intelligenceResponse.match(/\[RISK EVALUATION\](.*?)(?=\[ACTIONABLE RECOMMENDATIONS\]|$)/s)?.[1]?.trim() || 'Risk assessment unavailable';
                const recommendations = intelligenceResponse.match(/\[ACTIONABLE RECOMMENDATIONS\](.*?)(?=\[STRATEGIC IMPLICATIONS\]|$)/s)?.[1]?.trim() || 'No recommendations available';
                const strategic = intelligenceResponse.match(/\[STRATEGIC IMPLICATIONS\](.*)$/s)?.[1]?.trim() || 'Strategic analysis pending';

                // Format recommendations as array
                const actionableItems = recommendations.split('\n')
                    .filter(line => line.trim().startsWith('‚Ä¢'))
                    .map(line => line.trim().substring(1).trim())
                    .filter(item => item.length > 0);

                return {
                    actionable: actionableItems.length > 0 ? actionableItems : ['Conduct further analysis', 'Monitor system behavior', 'Review council consensus'],
                    correlations: correlations,
                    recommendations: recommendations,
                    risk_assessment: riskAssessment,
                    strategic_implications: strategic
                };

            } catch (error) {
                console.error('Intelligence synthesis failed:', error);
                // Fallback to basic analysis
                return {
                    actionable: [
                        'System analysis completed with limited AI synthesis',
                        'Manual review of council responses recommended',
                        'Monitor for recurring patterns in future analyses'
                    ],
                    correlations: 'Basic correlation analysis due to synthesis failure',
                    recommendations: 'Manual intelligence assessment required',
                    risk_assessment: 'Unable to assess risks automatically'
                };
            }
        }

        function storeIntelligence(report) {
            surveillanceState.intelligenceReports.unshift(report);
            
            // Limit storage
            if (surveillanceState.intelligenceReports.length > DJINN_CONFIG.MEMORY_LIMIT) {
                surveillanceState.intelligenceReports.pop();
            }
            
            surveillanceState.reportCount++;
            document.getElementById('reportCount').textContent = surveillanceState.reportCount;
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('djinn_intelligence', JSON.stringify(surveillanceState.intelligenceReports));
            } catch (error) {
                console.error('Failed to store intelligence:', error);
            }
        }

        function displayIntelligence(report) {
            // Handle legacy reports that might not have all properties
            const severity = report.severity || 'insight';
            const reportType = report.type || 'unknown';
            const summary = report.summary || 'No summary available';
            const timestamp = report.timestamp || new Date().toISOString();
            
            const severityClass = `intel-${severity}`;
            const html = `
                <div class="intel-entry ${severityClass}">
                    <div class="intel-timestamp">${new Date(timestamp).toLocaleTimeString()}</div>
                    <div style="margin-bottom: 12px; font-weight: bold; font-size: 12px;">
                        [${severity.toUpperCase()}] ${reportType}
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Consensus</div>
                        <div class="intel-content">${summary}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Intelligence Assessment</div>
                        <div class="intel-content">${report.correlations || 'Analysis in progress'}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Risk Evaluation</div>
                        <div class="intel-content">${report.risk_assessment || 'Risk assessment pending'}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Actionable Recommendations</div>
                        <div class="intel-content">
                            ${Array.isArray(report.actionable) ?
                                `<ul class="intel-recommendations">${report.actionable.map(a => `<li>${a}</li>`).join('')}</ul>` :
                                (report.actionable || 'No recommendations available')
                            }
                        </div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Strategic Implications</div>
                        <div class="intel-content">${report.strategic_implications || 'Strategic analysis pending'}</div>
                    </div>
                </div>
            `;

            const feed = document.getElementById('intelligenceFeed');
            feed.innerHTML = html + feed.innerHTML;

            // Limit display
            const entries = feed.querySelectorAll('.intel-entry');
            if (entries.length > 20) {
                entries[entries.length - 1].remove();
            }
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================

        function updateCanvasPreview(canvasContent) {
            // Update statistics
            const length = canvasContent.length;
            const words = canvasContent.split(/\s+/).filter(w => w.length > 0).length;
            const lines = canvasContent.split('\n').length;
            const modified = length > 0 ? new Date().toLocaleTimeString() : 'Never';
            
            document.getElementById('canvasLength').textContent = length.toLocaleString();
            document.getElementById('canvasWords').textContent = words.toLocaleString();
            document.getElementById('canvasLines').textContent = lines.toLocaleString();
            document.getElementById('canvasModified').textContent = modified;
            
            // Update content preview - show full canvas content
            let preview = '';
            if (canvasContent.length > 0) {
                // Try to extract meaningful content, avoiding HTML/script tags
                let cleanContent = canvasContent;
                
                // Remove script tags and their content
                cleanContent = cleanContent.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
                
                // Remove HTML tags but keep text
                cleanContent = cleanContent.replace(/<[^>]*>/g, ' ');
                
                // Remove multiple spaces and clean up
                cleanContent = cleanContent.replace(/\s+/g, ' ').trim();
                
                // Show full cleaned content
                preview = cleanContent;
                
                // If we still have no meaningful content, show raw content
                if (preview.trim().length === 0) {
                    preview = canvasContent;
                }
            } else {
                preview = 'No canvas content detected yet. Start typing in the Canvas to see content here.';
            }
            
            document.getElementById('canvasContentPreview').textContent = preview;
            
            // Update monitor status based on content
            const statusEl = document.getElementById('canvasMonitorStatus');
            if (length > 0) {
                statusEl.textContent = 'ACTIVE';
                statusEl.style.background = 'rgba(0, 255, 136, 0.2)';
                statusEl.style.color = '#00ff88';
            } else {
                statusEl.textContent = 'WAITING';
                statusEl.style.background = 'rgba(255, 170, 0, 0.2)';
                statusEl.style.color = '#ffaa00';
            }
        }

        function generateLocalAnalysis(model, prompt) {
            // This function should never be called - all analysis must come from Ollama
            throw new Error('Local analysis disabled. Only real Ollama AI responses are allowed.');
        }

        function hashContent(content) {
            let hash = 0;
            if (!content || content.length === 0) return hash;
            for (let i = 0; i < content.length; i++) {
                const char = content.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        function logSurveillance(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const feed = document.getElementById('surveillanceFeed');
            
            const color = type === 'error' ? '#ff6666' : 
                         type === 'change' ? '#00ff88' :
                         type === 'memory' ? '#ffaa00' : '#9999ff';
            
            const html = `<div style="margin-bottom: 4px; color: ${color};">[${timestamp}] ${message}</div>`;
            feed.innerHTML = html + feed.innerHTML;
            
            // Limit log entries
            const logs = feed.children;
            if (logs.length > 50) {
                feed.removeChild(logs[logs.length - 1]);
            }
        }

        function updateTimestamp() {
            document.getElementById('lastAnalysis').textContent = new Date().toLocaleTimeString();
        }

        function updateCouncilStatus(status) {
            document.getElementById('councilStatus').textContent = status;
            if (status === 'ANALYZING') {
                document.getElementById('canvasStatus').textContent = 'ANALYZING';
            } else {
                document.getElementById('canvasStatus').textContent = 'ACTIVE';
            }
        }

        function updateQueueStatus() {
            document.getElementById('queueStatus').textContent = surveillanceState.analysisQueue.length;
        }

        function startPolling() {
            document.getElementById('pollingStatus').textContent = `${DJINN_CONFIG.POLLING_INTERVAL / 1000}s`;
        }

        // ========================================
        // USER CONTROLS
        // ========================================

        async function triggerCouncilAnalysis() {
            console.log('Manual analysis triggered');
            
            // Force a fresh analysis
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
            
            queueAnalysis('manual_analysis', {
                content: canvasContent,
                memory: aiMemory,
                type: 'manual',
                timestamp: new Date().toISOString()
            });
            
            await processAnalysisQueue();
        }

        async function generateIntelReport() {
            console.log('Generating AI-powered intelligence report...');

            // Get current canvas data and AI memory
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
            const currentAnalysis = {
                type: 'intelligence_report_generation',
                data: {
                    content: canvasContent,
                    memory: aiMemory,
                    timestamp: new Date().toISOString()
                }
            };

            try {
                // Generate AI-powered intelligence report using current data
                const intelligenceEntry = await generateIntelligenceEntry(currentAnalysis, {
                    responses: [], // Will be populated by AI analysis
                    theme: 'intelligence_synthesis',
                    confidence: 0.8,
                    summary: 'AI-powered intelligence synthesis in progress'
                });

                // Display the AI-generated intelligence report
                displayIntelligence(intelligenceEntry);

                // Show success message
                alert(`AI-Powered Intelligence Report Generated!\n\n` +
                      `Report ID: ${intelligenceEntry.id}\n` +
                      `Severity: ${intelligenceEntry.severity}\n` +
                      `Theme: ${intelligenceEntry.theme}\n\n` +
                      `Check the Intelligence Report panel for the AI-synthesized analysis.`);

            } catch (error) {
                console.error('AI intelligence report generation failed:', error);
                alert('AI intelligence report generation failed. Check console for details.');
            }
        }

        function clearIntelligence() {
            if (confirm('Clear all intelligence data and response cache? This cannot be undone.')) {
                surveillanceState.intelligenceReports = [];
                surveillanceState.reportCount = 0;
                document.getElementById('reportCount').textContent = '0';
                document.getElementById('intelligenceFeed').innerHTML = '<div style="color: #666; font-style: italic;">Intelligence cleared</div>';
                document.getElementById('consensusFeed').innerHTML = '<div style="color: #666; font-style: italic;">Consensus cleared</div>';
                localStorage.removeItem('djinn_intelligence');
                
                // Also clear response cache to force fresh AI responses
                responseCache.clear();
                console.log('Response cache cleared for fresh AI responses');
            }
        }


        function exportIntelligence() {
            const intelligence = generateIntelligencePackage();
            const data = {
                timestamp: new Date().toISOString(),
                system: 'DJINN_COUNCIL_SHADOW_GOVERNANCE',
                intelligence: intelligence,
                rawMemory: djinnCouncilMemory
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `djinn_intelligence_${new Date().toISOString().replace(/:/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function emergencyAnalysis() {
            try {
                console.log('üö® Emergency analysis initiated');
                
                // Clear queue and force immediate analysis
                surveillanceState.analysisQueue = [];
                
                // Get all current data
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                
                queueAnalysis('emergency_analysis', {
                    content: canvasContent,
                    memory: aiMemory,
                    feeds: aiFeeds,
                    type: 'emergency',
                    timestamp: new Date().toISOString()
                });
                
                // Process immediately
                await processAnalysisQueue();
                
                // Generate report
                generateIntelReport();
            } catch (error) {
                console.error('Emergency analysis failed:', error);
                alert('Emergency analysis encountered an error. Check console for details.');
            }
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        // Load stored intelligence on startup
        function loadStoredIntelligence() {
            try {
                const stored = localStorage.getItem('djinn_intelligence');
                if (stored) {
                    const parsedReports = JSON.parse(stored);
                    
                    // Filter out any corrupted or incomplete reports
                    surveillanceState.intelligenceReports = parsedReports.filter(report => {
                        return report && typeof report === 'object' && report.timestamp;
                    });
                    
                    surveillanceState.reportCount = surveillanceState.intelligenceReports.length;
                    document.getElementById('reportCount').textContent = surveillanceState.reportCount;
                    
                    // Save cleaned data back to localStorage
                    localStorage.setItem('djinn_intelligence', JSON.stringify(surveillanceState.intelligenceReports));
                    
                    // Display recent reports
                    surveillanceState.intelligenceReports.slice(0, 5).forEach(report => {
                        displayIntelligence(report);
                    });
                }
            } catch (error) {
                console.error('Failed to load stored intelligence:', error);
                // Clear corrupted data
                localStorage.removeItem('djinn_intelligence');
                surveillanceState.intelligenceReports = [];
                surveillanceState.reportCount = 0;
                document.getElementById('reportCount').textContent = '0';
            }
        }

        // Start surveillance when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üßû‚Äç‚ôÇÔ∏è DJINN Council Shadow Governance System v1.0');
            console.log('Accessing shared localStorage at:', window.location.origin);
            
            // Clear old cached responses to force fresh analysis with improved prompts
            responseCache.clear();
            console.log('Cache cleared - improved analysis prompts enabled');

            // Force immediate fresh analysis of current canvas content
            setTimeout(() => {
                triggerCouncilAnalysis();
            }, 2000);
            
            loadStoredIntelligence();
            initializeSurveillance();
            
            // Add maximize functionality
            addMaximizeFeature();
            
            // Reset member statuses
            Object.values(councilMembers).forEach(member => {
                document.getElementById(member.status).textContent = 'READY';
            });

            // Initialize fixed header tooltip system
            initializeHeaderTooltips();

            // Initialize council memory system
            initializeDjinnCouncilMemory();
            addMemoryControls();
        });

        // ========================================
        // FIXED HEADER TOOLTIP SYSTEM
        // ========================================

        function initializeHeaderTooltips() {
            const tooltipDisplay = document.getElementById('tooltip-display');
            const tooltipElements = document.querySelectorAll('[data-tooltip]');

            tooltipElements.forEach(element => {
                element.addEventListener('mouseenter', function() {
                    const tooltipText = this.getAttribute('data-tooltip');
                    if (tooltipText) {
                        showTooltip(tooltipText);
                    }
                });

                element.addEventListener('mouseleave', function() {
                    hideTooltip();
                });
            });
        }

        function showTooltip(text) {
            const tooltipDisplay = document.getElementById('tooltip-display');
            tooltipDisplay.textContent = text;
            tooltipDisplay.classList.add('visible');
        }

        function hideTooltip() {
            const tooltipDisplay = document.getElementById('tooltip-display');
            tooltipDisplay.classList.remove('visible');
        }

        // ========================================
        // PREDICTIVE ANALYTICS FRAMEWORK
        // ========================================

        // Advanced predictive analytics for canvas and AI system behavior
        const predictiveAnalyticsFramework = {
            // Prediction models
            models: {
                canvasEvolution: null,
                aiPerformance: null,
                systemHarmony: null,
                memoryUsage: null
            },

            // Prediction history and accuracy tracking
            predictions: {
                made: [],
                accuracy: [],
                confidence: []
            },

            // Forecasting data
            forecastData: {
                canvas: [],
                aiSystems: [],
                correlations: [],
                memory: []
            },

            // Initialize predictive analytics
            initialize: function() {
                console.log('üîÆ Initializing Predictive Analytics Framework');
                this.buildPredictionModels();
                this.schedulePredictions();
                this.loadHistoricalData();
            },

            // Build prediction models from historical data
            buildPredictionModels: function() {
                // Canvas evolution model
                this.models.canvasEvolution = {
                    trend: 'analyzing',
                    velocity: 0,
                    confidence: 0,
                    nextPrediction: null
                };

                // AI performance model
                this.models.aiPerformance = {
                    systems: new Map(),
                    overallTrend: 'stable',
                    confidence: 0
                };

                // System harmony model
                this.models.systemHarmony = {
                    currentLevel: 0,
                    trend: 'stable',
                    predictions: []
                };

                // Memory usage model
                this.models.memoryUsage = {
                    currentUsage: 0,
                    growthRate: 0,
                    predictions: []
                };

                console.log('üîÆ Prediction models initialized');
            },

            // Load historical data for model training
            loadHistoricalData: function() {
                // Load canvas evolution history
                if (canvasEvolutionTracker && canvasEvolutionTracker.history) {
                    this.forecastData.canvas = canvasEvolutionTracker.history.slice(-50); // Last 50 snapshots
                }

                // Load correlation history
                if (crossSystemCorrelationEngine && crossSystemCorrelationEngine.correlationHistory) {
                    this.forecastData.correlations = crossSystemCorrelationEngine.correlationHistory.slice(-20); // Last 20 analyses
                }

                // Load memory analytics
                if (advancedMemoryOrchestrator && advancedMemoryOrchestrator.analytics) {
                    this.forecastData.memory = [{
                        timestamp: Date.now(),
                        efficiency: advancedMemoryOrchestrator.analytics.compressionRatio,
                        savings: advancedMemoryOrchestrator.analytics.deduplicationSavings
                    }];
                }

                console.log('üîÆ Loaded historical data:', {
                    canvas: this.forecastData.canvas.length,
                    correlations: this.forecastData.correlations.length,
                    memory: this.forecastData.memory.length
                });
            },

            // Generate canvas evolution predictions
            predictCanvasEvolution: function() {
                if (this.forecastData.canvas.length < 3) {
                    return {
                        prediction: 'insufficient_data',
                        confidence: 0,
                        timeHorizon: 'unknown'
                    };
                }

                const recent = this.forecastData.canvas.slice(-5);
                const changes = recent.filter(s => s.changes).map(s => ({
                    netChange: s.changes.netChange,
                    velocity: parseFloat(s.changes.velocity),
                    timeDelta: s.changes.timeDelta
                }));

                if (changes.length === 0) {
                    return {
                        prediction: 'no_recent_changes',
                        confidence: 0.5,
                        timeHorizon: '5_minutes'
                    };
                }

                // Calculate trend
                const avgChange = changes.reduce((sum, c) => sum + c.netChange, 0) / changes.length;
                const avgVelocity = changes.reduce((sum, c) => sum + c.velocity, 0) / changes.length;

                // Predict next change
                const trend = avgChange > 10 ? 'expanding' :
                             avgChange < -10 ? 'contracting' : 'stable';

                // Calculate confidence based on trend consistency
                const velocities = changes.map(c => c.velocity);
                const velocityVariance = this.calculateVariance(velocities);
                const confidence = Math.max(0.1, Math.min(1.0, 1 - (velocityVariance / 1000)));

                // Predict future state
                const currentLength = recent[recent.length - 1].metrics.characters;
                const predictedLength = Math.max(0, currentLength + (avgChange * 3)); // 3-step prediction
                const changePercentage = ((predictedLength - currentLength) / Math.max(currentLength, 1)) * 100;

                return {
                    prediction: trend,
                    confidence: confidence,
                    timeHorizon: '15_minutes',
                    predictedLength: Math.round(predictedLength),
                    expectedChange: Math.round(avgChange * 3),
                    changePercentage: changePercentage.toFixed(1) + '%',
                    velocity: avgVelocity.toFixed(1) + ' chars/min'
                };
            },

            // Predict AI system performance
            predictAISystemPerformance: function() {
                if (this.forecastData.correlations.length < 2) {
                    return {
                        prediction: 'analyzing',
                        confidence: 0,
                        systems: {}
                    };
                }

                const recent = this.forecastData.correlations.slice(-3);
                const systemTrends = {};

                // Analyze each AI system's performance trend
                ['narra', 'nazar', 'whale', 'djinn', 'watchtower'].forEach(system => {
                    const systemData = recent.map(c => {
                        const sysData = c.crossCorrelations.find(corr => corr.system === system);
                        return sysData ? sysData.correlation : 0;
                    }).filter(val => val > 0);

                    if (systemData.length > 0) {
                        const avgCorrelation = systemData.reduce((a, b) => a + b, 0) / systemData.length;
                        const trend = avgCorrelation > 0.6 ? 'improving' :
                                     avgCorrelation > 0.4 ? 'stable' : 'declining';

                        systemTrends[system] = {
                            trend: trend,
                            correlation: avgCorrelation.toFixed(3),
                            confidence: Math.min(1.0, systemData.length / 3)
                        };
                    }
                });

                // Overall AI performance prediction
                const avgCorrelations = Object.values(systemTrends)
                    .map(s => parseFloat(s.correlation))
                    .filter(c => !isNaN(c));

                const overallTrend = avgCorrelations.length > 0 ?
                    (avgCorrelations.reduce((a, b) => a + b, 0) / avgCorrelations.length > 0.5 ? 'improving' : 'stable') :
                    'analyzing';

                return {
                    prediction: overallTrend,
                    confidence: avgCorrelations.length > 0 ? 0.7 : 0.3,
                    systems: systemTrends,
                    averageCorrelation: avgCorrelations.length > 0 ?
                        (avgCorrelations.reduce((a, b) => a + b, 0) / avgCorrelations.length).toFixed(3) : '0.000'
                };
            },

            // Predict system harmony evolution
            predictSystemHarmony: function() {
                if (this.forecastData.correlations.length < 3) {
                    return {
                        prediction: 'analyzing',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                const recent = this.forecastData.correlations.slice(-5);
                const harmonyScores = recent.map(c => crossSystemCorrelationEngine.calculateSystemHarmony(c));

                if (harmonyScores.length === 0) {
                    return {
                        prediction: 'no_data',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                // Calculate harmony trend
                const avgHarmony = harmonyScores.reduce((a, b) => a + b, 0) / harmonyScores.length;
                const trend = avgHarmony > 70 ? 'harmonious' :
                             avgHarmony > 50 ? 'balanced' :
                             avgHarmony > 30 ? 'challenging' : 'conflicted';

                // Predict future harmony
                const slope = this.calculateSlope(harmonyScores);
                const predictedHarmony = Math.max(0, Math.min(100, avgHarmony + (slope * 3)));

                return {
                    prediction: trend,
                    confidence: Math.min(1.0, harmonyScores.length / 5),
                    currentHarmony: avgHarmony.toFixed(1) + '%',
                    predictedHarmony: predictedHarmony.toFixed(1) + '%',
                    trend: slope > 2 ? 'improving' : slope < -2 ? 'declining' : 'stable',
                    slope: slope.toFixed(2)
                };
            },

            // Predict memory usage patterns
            predictMemoryUsage: function() {
                if (this.forecastData.memory.length < 2) {
                    return {
                        prediction: 'analyzing',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                const recent = this.forecastData.memory.slice(-5);
                const efficiencies = recent.map(m => m.efficiency || 0);
                const savings = recent.map(m => m.savings || 0);

                if (efficiencies.length === 0) {
                    return {
                        prediction: 'no_data',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                // Calculate memory efficiency trend
                const avgEfficiency = efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length;
                const avgSavings = savings.reduce((a, b) => a + b, 0) / savings.length;

                const efficiencySlope = this.calculateSlope(efficiencies);
                const trend = efficiencySlope > 0.01 ? 'improving' :
                             efficiencySlope < -0.01 ? 'declining' : 'stable';

                // Predict future efficiency
                const predictedEfficiency = Math.max(0, Math.min(1, avgEfficiency + (efficiencySlope * 5)));

                return {
                    prediction: trend,
                    confidence: Math.min(1.0, efficiencies.length / 5),
                    currentEfficiency: (avgEfficiency * 100).toFixed(1) + '%',
                    predictedEfficiency: (predictedEfficiency * 100).toFixed(1) + '%',
                    averageSavings: Math.round(avgSavings) + ' bytes',
                    trend: trend,
                    slope: efficiencySlope.toFixed(4)
                };
            },

            // Calculate variance for confidence metrics
            calculateVariance: function(values) {
                if (values.length < 2) return 0;

                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const squareDiffs = values.map(value => Math.pow(value - mean, 2));
                return squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
            },

            // Calculate slope for trend analysis
            calculateSlope: function(values) {
                if (values.length < 2) return 0;

                const n = values.length;
                const sumX = (n * (n - 1)) / 2;
                const sumY = values.reduce((a, b) => a + b, 0);
                const sumXY = values.reduce((sum, y, x) => sum + (x * y), 0);
                const sumXX = (n * (n - 1) * (2 * n - 1)) / 6;

                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                return isNaN(slope) ? 0 : slope;
            },

            // Generate comprehensive predictions
            generatePredictions: function() {
                const predictions = {
                    timestamp: Date.now(),
                    canvas: this.predictCanvasEvolution(),
                    aiSystems: this.predictAISystemPerformance(),
                    harmony: this.predictSystemHarmony(),
                    memory: this.predictMemoryUsage(),
                    overall: this.generateOverallAssessment()
                };

                // Store prediction for accuracy tracking
                this.predictions.made.push(predictions);

                // Keep only last 50 predictions
                if (this.predictions.made.length > 50) {
                    this.predictions.made.shift();
                }

                return predictions;
            },

            // Generate overall system assessment
            generateOverallAssessment: function() {
                const canvas = this.predictCanvasEvolution();
                const ai = this.predictAISystemPerformance();
                const harmony = this.predictSystemHarmony();
                const memory = this.predictMemoryUsage();

                // Calculate overall system health
                const confidences = [canvas.confidence, ai.confidence, harmony.confidence, memory.confidence];
                const avgConfidence = confidences.reduce((a, b) => a + b, 0) / confidences.length;

                // Determine overall status
                let status = 'analyzing';
                let concerns = [];
                let opportunities = [];

                // Canvas evolution assessment
                if (canvas.prediction === 'expanding') {
                    opportunities.push('Canvas content is growing - good for analysis depth');
                } else if (canvas.prediction === 'contracting') {
                    concerns.push('Canvas content is shrinking - monitor for data loss');
                }

                // AI performance assessment
                if (ai.prediction === 'improving') {
                    opportunities.push('AI system performance is improving');
                } else if (ai.prediction === 'stable') {
                    status = 'stable';
                }

                // Harmony assessment
                if (harmony.prediction === 'harmonious') {
                    opportunities.push('High system harmony detected');
                } else if (harmony.prediction === 'conflicted') {
                    concerns.push('System conflicts detected - review correlations');
                }

                // Memory assessment
                if (memory.prediction === 'improving') {
                    opportunities.push('Memory efficiency is improving');
                } else if (memory.prediction === 'declining') {
                    concerns.push('Memory efficiency declining - consider optimization');
                }

                // Overall status determination
                if (concerns.length === 0 && opportunities.length > 0) {
                    status = 'excellent';
                } else if (concerns.length <= opportunities.length) {
                    status = 'good';
                } else if (concerns.length > 0) {
                    status = 'needs_attention';
                }

                return {
                    status: status,
                    confidence: avgConfidence,
                    concerns: concerns,
                    opportunities: opportunities,
                    recommendations: this.generateRecommendations(concerns, opportunities)
                };
            },

            // Generate recommendations based on assessment
            generateRecommendations: function(concerns, opportunities) {
                const recommendations = [];

                if (concerns.includes('Canvas content is shrinking - monitor for data loss')) {
                    recommendations.push('Consider increasing canvas content generation or review AI system prompts');
                }

                if (concerns.includes('System conflicts detected - review correlations')) {
                    recommendations.push('Review AI system correlations and consider adjusting analysis parameters');
                }

                if (concerns.includes('Memory efficiency declining - consider optimization')) {
                    recommendations.push('Run memory defragmentation and review storage policies');
                }

                if (opportunities.includes('Canvas content is growing - good for analysis depth')) {
                    recommendations.push('Leverage increased content for deeper analysis and pattern recognition');
                }

                if (opportunities.includes('AI system performance is improving')) {
                    recommendations.push('Consider increasing analysis complexity or expanding system capabilities');
                }

                if (opportunities.includes('High system harmony detected')) {
                    recommendations.push('System is well-balanced - maintain current operational parameters');
                }

                return recommendations;
            },

            // Schedule prediction generation
            schedulePredictions: function() {
                // Generate predictions every 10 minutes
                setInterval(() => {
                    this.generatePredictions();
                }, 10 * 60 * 1000);

                // Update forecast data every 2 minutes
                setInterval(() => {
                    this.loadHistoricalData();
                }, 2 * 60 * 1000);
            },

            // Get current predictions
            getCurrentPredictions: function() {
                const latest = this.predictions.made[this.predictions.made.length - 1];
                if (!latest) return null;

                return {
                    canvas: {
                        trend: latest.canvas.prediction,
                        confidence: (latest.canvas.confidence * 100).toFixed(1) + '%',
                        nextChange: latest.canvas.expectedChange || 'unknown'
                    },
                    aiSystems: {
                        trend: latest.aiSystems.prediction,
                        confidence: (latest.aiSystems.confidence * 100).toFixed(1) + '%',
                        avgCorrelation: latest.aiSystems.averageCorrelation
                    },
                    harmony: {
                        status: latest.harmony.prediction,
                        confidence: (latest.harmony.confidence * 100).toFixed(1) + '%',
                        level: latest.harmony.currentHarmony
                    },
                    memory: {
                        trend: latest.memory.prediction,
                        confidence: (latest.memory.confidence * 100).toFixed(1) + '%',
                        efficiency: latest.memory.currentEfficiency
                    },
                    overall: {
                        status: latest.overall.status,
                        confidence: (latest.overall.confidence * 100).toFixed(1) + '%',
                        concerns: latest.overall.concerns.length,
                        opportunities: latest.overall.opportunities.length
                    },
                    lastUpdate: new Date(latest.timestamp).toLocaleTimeString()
                };
            }
        };

        // Initialize predictive analytics framework
        predictiveAnalyticsFramework.initialize();

        // Update predictive analytics display
        function updatePredictiveAnalytics() {
            const predictions = predictiveAnalyticsFramework.getCurrentPredictions();
            if (!predictions) {
                document.getElementById('predictiveFeed').innerHTML = `
                    <div style="color: #666; font-style: italic;">Generating initial predictions...</div>
                `;
                return;
            }

            const statusColor = predictions.overall.status === 'excellent' ? '#00ff88' :
                               predictions.overall.status === 'good' ? '#ffaa00' :
                               predictions.overall.status === 'needs_attention' ? '#ff6666' : '#666';

            document.getElementById('predictiveFeed').innerHTML = `
                <div style="margin-bottom: 12px;">
                    <strong style="color: #ffaa00;">üìä Overall Status:</strong>
                    <span style="color: ${statusColor}; margin-left: 8px; font-weight: bold;">
                        ${predictions.overall.status.toUpperCase()}
                    </span>
                    <span style="color: #666; margin-left: 8px;">
                        (${predictions.overall.confidence}% confidence)
                    </span>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #6666ff;">üìú Canvas Evolution:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Trend: <span style="color: #cc88cc;">${predictions.canvas.trend}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.canvas.confidence}</span></div>
                        <div>Next Change: <span style="color: #cc88cc;">${predictions.canvas.nextChange} chars</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #00ff88;">ü§ñ AI Systems:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Trend: <span style="color: #cc88cc;">${predictions.aiSystems.trend}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.aiSystems.confidence}</span></div>
                        <div>Avg Correlation: <span style="color: #cc88cc;">${predictions.aiSystems.avgCorrelation}</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #cc88cc;">‚öñÔ∏è System Harmony:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Status: <span style="color: #cc88cc;">${predictions.harmony.status}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.harmony.confidence}</span></div>
                        <div>Level: <span style="color: #cc88cc;">${predictions.harmony.level}</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #ff88ff;">üß† Memory Usage:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Trend: <span style="color: #cc88cc;">${predictions.memory.trend}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.memory.confidence}</span></div>
                        <div>Efficiency: <span style="color: #cc88cc;">${predictions.memory.efficiency}</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #ffaa00;">üí° Key Insights:</strong>
                    <div style="margin-left: 12px; margin-top: 4px; font-size: 10px; line-height: 1.4;">
                        <div>‚Ä¢ ${predictions.overall.opportunities} opportunities identified</div>
                        <div>‚Ä¢ ${predictions.overall.concerns} concerns detected</div>
                        <div>‚Ä¢ Last updated: ${predictions.lastUpdate}</div>
                    </div>
                </div>
            `;
        }

        // Auto-update predictive analytics every 30 seconds
        setInterval(updatePredictiveAnalytics, 30000);

        // Initialize correlative analysis framework
        if (typeof correlativeAnalysisFramework !== 'undefined') {
            correlativeAnalysisFramework.initialize();
            console.log('üîç Correlative Analysis Framework initialized and ready for synthesis report integration');
        }

        window.addEventListener('beforeunload', function() {
            if (surveillanceState.pollingTimer) {
                clearInterval(surveillanceState.pollingTimer);
            }
        });
    </script>
</body>
</html>