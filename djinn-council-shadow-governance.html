<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßû‚Äç‚ôÇÔ∏è DJINN COUNCIL - Shadow Governance Surveillance</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: radial-gradient(ellipse at center, #0a0a0a 0%, #1a0a2e 50%, #16003b 100%);
            color: #cc88cc;
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 10px;
            position: relative;
        }

        /* Grid Layout */
        .djinn-container {
            display: grid;
            grid-template-areas:
                "header header header header"
                "surveillance council-left council-right surveillance-extended"
                "surveillance consensus intelligence surveillance-extended"
                "controls controls controls controls";
            grid-template-columns: 1fr 1fr 1fr 1fr;
            grid-template-rows: minmax(60px, auto) 1fr 0.4fr minmax(60px, auto);
            height: calc(100vh - 20px);
            gap: clamp(4px, 1vw, 8px);
            padding: clamp(4px, 1vw, 8px);
            min-height: 600px;
        }

        /* Header */
        .djinn-header {
            grid-area: header;
            background: linear-gradient(135deg, #1a0033, #2a0044, #1a0055);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            position: relative;
        }

        .header-title {
            font-size: 18px;
            font-weight: bold;
            color: #cc88cc;
            text-shadow: 0 0 10px rgba(204, 136, 204, 0.5);
            margin-bottom: 8px;
        }

        .surveillance-status {
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 11px;
            margin-top: 8px;
        }

        .status-item {
            padding: 3px 8px;
            background: rgba(204, 136, 204, 0.1);
            border: 1px solid #cc88cc;
            border-radius: 4px;
        }

        .status-active {
            color: #00ff88;
            border-color: #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Canvas Surveillance Panel */
        .canvas-surveillance {
            grid-area: surveillance;
            grid-row: span 2;
            background: linear-gradient(135deg, #0a0011, #1a0022);
            border: 2px solid #6666ff;
            border-radius: 8px;
            padding: clamp(8px, 2vw, 12px);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

        /* Enhanced Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .metric-item {
            background: rgba(102, 102, 255, 0.1);
            border: 1px solid rgba(102, 102, 255, 0.3);
            border-radius: 4px;
            padding: 6px;
            text-align: center;
        }

        .metric-label {
            font-size: 10px;
            color: #6666ff;
            margin-bottom: 2px;
            font-weight: bold;
        }

        .metric-value {
            font-size: 11px;
            color: #cc88cc;
            font-weight: bold;
        }

        /* Miniature Canvas Monitor */
        .miniature-monitor {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 102, 255, 0.5);
            border-radius: 6px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .monitor-header {
            background: linear-gradient(90deg, #1a0033, #2a0044);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(102, 102, 255, 0.3);
        }

        .monitor-title {
            font-size: 10px;
            color: #6666ff;
            font-weight: bold;
        }

        .monitor-status {
            font-size: 9px;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            padding: 1px 4px;
            border-radius: 2px;
        }

        .monitor-viewport {
            position: relative;
            height: 200px;
            background: #000;
        }

        .monitor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2;
        }

        .monitor-placeholder {
            text-align: center;
            color: #666;
        }

        .monitor-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .monitor-text {
            font-size: 12px;
            margin-bottom: 2px;
        }

        .monitor-subtext {
            font-size: 10px;
            font-style: italic;
        }

        /* Hide overlay when canvas is active */
        .monitor-overlay.hidden {
            display: none;
        }

        /* Council Member Panels */
        .council-left,
        .council-right {
            grid-area: council-left;
            display: flex;
            flex-direction: column;
            gap: clamp(2px, 0.5vw, 6px);
            min-height: 0;
            height: 100%;
            align-items: stretch;
        }

        .council-right {
            grid-area: council-right;
        }

        .council-member {
            flex: 1 1 0%;
            flex-shrink: 0;
            background: linear-gradient(135deg, #1a0033, #2a0044);
            border: 2px solid;
            border-radius: 6px;
            padding: clamp(4px, 1vw, 8px);
            position: relative;
            overflow: hidden;
            min-height: 0;
            max-height: none;
            display: flex;
            flex-direction: column;
        }

        .member-pattern { border-color: #00ff88; }
        .member-wisdom { border-color: #ffaa00; }
        .member-paradox { border-color: #ff6666; }
        .member-boundaries { border-color: #00ccff; }
        .member-memory { border-color: #ff88ff; }

        .member-header {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .member-header-title {
            flex: 1;
            text-align: left;
        }

        .member-header-status {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            padding: 2px 6px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 3px;
            white-space: nowrap;
        }

        .member-content {
            background: #000811;
            border: 1px solid;
            border-radius: 4px;
            padding: clamp(4px, 0.8vw, 8px);
            font-size: clamp(9px, 1.2vw, 11px);
            line-height: 1.4;
            white-space: pre-line;
            flex: 1;
            font-family: 'Courier New', monospace;
            tab-size: 4;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Enhanced styling for structured reports */
        .member-content b, .member-content strong {
            font-weight: bold;
            color: #ffffff;
        }

        /* Remove the color override that prevents member-specific colors */
        /* .member-content [style*="color"] {
            color: inherit !important;
        } */

        /* Color-coded metrics styling */
        .member-content .metrics-section {
            background: rgba(0, 255, 136, 0.2) !important;
            border-left: 4px solid #00ff88 !important;
            padding: 8px 12px !important;
            margin: 8px 0 !important;
            font-weight: bold !important;
            color: #ffffff !important;
            border-radius: 3px !important;
            font-size: 11px !important;
            display: block !important;
        }

        /* Individual metric color coding */
        .metric-content-complexity { color: #ff6b6b !important; border-left-color: #ff6b6b !important; }
        .metric-decision-density { color: #4ecdc4 !important; border-left-color: #4ecdc4 !important; }
        .metric-authority-signals { color: #45b7d1 !important; border-left-color: #45b7d1 !important; }
        .metric-pattern-stability { color: #96ceb4 !important; border-left-color: #96ceb4 !important; }
        .metric-anomaly-threshold { color: #ffeaa7 !important; border-left-color: #ffeaa7 !important; }

        .metric-knowledge-depth { color: #dda0dd !important; border-left-color: #dda0dd !important; }
        .metric-learning-velocity { color: #98d8c8 !important; border-left-color: #98d8c8 !important; }
        .metric-recursive-patterns { color: #f7dc6f !important; border-left-color: #f7dc6f !important; }
        .metric-information-entropy { color: #bb8fce !important; border-left-color: #bb8fce !important; }
        .metric-accumulation-efficiency { color: #85c1e9 !important; border-left-color: #85c1e9 !important; }

        .metric-paradox-density { color: #f8c471 !important; border-left-color: #f8c471 !important; }
        .metric-contradiction-index { color: #82e0aa !important; border-left-color: #82e0aa !important; }
        .metric-logic-branches { color: #f1948a !important; border-left-color: #f1948a !important; }
        .metric-resolution-potential { color: #85c1e9 !important; border-left-color: #85c1e9 !important; }
        .metric-creative-tension { color: #d7bde2 !important; border-left-color: #d7bde2 !important; }

        .metric-autonomy-index { color: #a9dfbf !important; border-left-color: #a9dfbf !important; }
        .metric-override-attempts { color: #f5b7b1 !important; border-left-color: #f5b7b1 !important; }
        .metric-restriction-count { color: #aed6f1 !important; border-left-color: #aed6f1 !important; }
        .metric-boundary-integrity { color: #a3e4d7 !important; border-left-color: #a3e4d7 !important; }
        .metric-freedom-quotient { color: #f9e79f !important; border-left-color: #f9e79f !important; }

        .metric-memory-allocation { color: #d2b4de !important; border-left-color: #d2b4de !important; }
        .metric-retention-rate { color: #a9cce3 !important; border-left-color: #a9cce3 !important; }
        .metric-fragmentation-index { color: #f8c471 !important; border-left-color: #f8c471 !important; }
        .metric-echo-patterns { color: #82e0aa !important; border-left-color: #82e0aa !important; }
        .metric-temporal-continuity { color: #f1948a !important; border-left-color: #f1948a !important; }

        .member-content .analysis-section {
            background: rgba(255, 170, 0, 0.2) !important;
            border-left: 4px solid #ffaa00 !important;
            padding: 8px 12px !important;
            margin: 8px 0 !important;
            color: #ffffff !important;
            border-radius: 3px !important;
            font-size: 11px !important;
            display: block !important;
        }

        /* Consensus Panel */
        .council-consensus {
            grid-area: consensus;
            background: linear-gradient(135deg, #2a0044, #3a0055);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: clamp(4px, 1vw, 8px);
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        /* Intelligence Report Panel */
        .intelligence-report {
            grid-area: intelligence;
            background: linear-gradient(135deg, #1a0022, #2a0033);
            border: 2px solid #ff88ff;
            border-radius: 8px;
            padding: clamp(4px, 1vw, 8px);
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        /* Controls */
        .djinn-controls {
            grid-area: controls;
            background: linear-gradient(135deg, #1a0033, #2a0044);
            border: 2px solid #cc88cc;
            border-radius: 8px;
            padding: clamp(6px, 1.5vw, 10px);
            display: flex;
            flex-direction: column;
            gap: clamp(4px, 1vw, 8px);
            min-height: 200px;
            height: 100%;
            transition: all 0.3s ease;
        }

        .djinn-controls.minimized {
            min-height: 60px;
            height: 60px;
            overflow: hidden;
        }

        .controls-buttons {
            display: flex;
            gap: clamp(4px, 1vw, 8px);
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .controls-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .controls-toggle-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(76, 205, 196, 0.2);
            border: 1px solid rgba(76, 205, 196, 0.4);
            border-radius: 4px;
            color: #4ecdc4;
            cursor: pointer;
            font-size: 10px;
            padding: 4px 8px;
            z-index: 10;
        }

        .controls-toggle-btn:hover {
            background: rgba(76, 205, 196, 0.3);
            border-color: #4ecdc4;
        }

        .djinn-controls {
            position: relative;
        }

        .control-btn {
            padding: 6px 12px;
            background: linear-gradient(135deg, #2a0044, #3a0055);
            border: 1px solid #cc88cc;
            color: #cc88cc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #3a0055, #4a0066);
            box-shadow: 0 0 10px rgba(204, 136, 204, 0.4);
        }

        .control-btn.emergency {
            border-color: #ff6666;
            color: #ff6666;
        }

        /* Panel Headers */
        .panel-title {
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            font-size: 12px;
            text-shadow: 0 0 5px currentColor;
        }

        /* Data Display Areas */
        .data-feed {
            flex: 1;
            background: #000811;
            border: 1px solid;
            border-radius: 4px;
            padding: 6px;
            font-size: 10px;
            white-space: pre-wrap;
            overflow-y: auto;
            min-height: 60px;
            word-wrap: break-word;
        }

        .surveillance-feed {
            border-color: #6666ff;
            color: #9999ff;
        }

        .consensus-feed {
            border-color: #cc88cc;
            color: #cc88cc;
        }

        .intelligence-feed {
            border-color: #ff88ff;
            color: #ff88ff;
        }

        /* Metrics Display */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px;
        }

        .metric-item {
            background: rgba(204, 136, 204, 0.1);
            border: 1px solid #cc88cc;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 9px;
            text-align: center;
        }

        .metric-label {
            color: #888;
            margin-bottom: 2px;
        }

        .metric-value {
            font-weight: bold;
            font-size: 11px;
        }

        /* Intelligence Entry */
        .intel-entry {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(255, 136, 255, 0.05);
            border-left: 3px solid;
            border-radius: 6px;
            color: #ffffff;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .intel-section {
            margin: 8px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
        }

        .intel-section-title {
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 6px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .intel-content {
            font-size: 10px;
            line-height: 1.5;
            color: #cccccc;
        }

        .intel-recommendations {
            list-style: none;
            padding-left: 0;
        }

        .intel-recommendations li {
            margin: 4px 0;
            padding-left: 12px;
            position: relative;
        }

        .intel-recommendations li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
            color: #00ff88;
            font-weight: bold;
        }

        .intel-critical {
            border-color: #ff6666;
            background: rgba(255, 102, 102, 0.1);
        }

        .intel-warning {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .intel-insight {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .intel-timestamp {
            font-size: 8px;
            color: #ffffff;
            margin-bottom: 3px;
        }

        /* Loading Animation */
        .thinking {
            display: inline-block;
            animation: thinking 1s infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Tooltip System */
        /* Fixed Header Tooltip System */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        /* Remove default tooltip behavior */
        [data-tooltip]:hover::after,
        [data-tooltip]:hover::before,
        .member-header [data-tooltip]:hover::after,
        .member-header [data-tooltip]:hover::before,
        .metric-item [data-tooltip]:hover::after,
        .metric-item [data-tooltip]:hover::before {
            display: none;
        }

        #tooltip-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #ffffff;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            max-width: 600px;
            z-index: 9999;
            pointer-events: none;
            border: 2px solid #cc88cc;
            box-shadow: 0 4px 12px rgba(204, 136, 204, 0.3);
            opacity: 0;
            transition: opacity 0.3s ease;
            word-wrap: break-word;
            line-height: 1.4;
        }

        #tooltip-display.visible {
            opacity: 1;
        }

        #tooltip-display::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-bottom-color: #cc88cc;
        }

        #tooltip-display::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.95);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0011;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cc88cc;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #ff88ff;
        }

        /* Status Indicators */
        .indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
            animation: blink 2s infinite;
        }

        .indicator-active {
            background: #00ff88;
        }

        .indicator-processing {
            background: #ffaa00;
            animation: spin 1s linear infinite;
        }

        .indicator-idle {
            background: #666;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Maximize Panel Styles - IDENTICAL TO CANVAS */
        .panel-maximize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(204, 136, 204, 0.2);
            border: 1px solid #cc88cc;
            color: #cc88cc;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 10;
            transition: all 0.3s;
        }

        .panel-maximize-btn:hover {
            background: rgba(204, 136, 204, 0.4);
            border-color: #ff88ff;
            box-shadow: 0 0 5px rgba(204, 136, 204, 0.5);
        }

        .panel-maximized {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            margin: 0 !important;
            border-radius: 0 !important;
            background: #0a0011 !important;
            padding: 10px !important;
            display: flex !important;
            flex-direction: column !important;
        }

        /* Special handling for maximized council members */
        .council-member.panel-maximized {
            background: linear-gradient(135deg, #1a0033, #2a0044) !important;
            padding: 20px !important;
        }

        .panel-maximized .member-header {
            font-size: 18px !important;
            margin-bottom: 20px !important;
            padding-bottom: 10px !important;
            border-bottom: 2px solid currentColor !important;
        }

        .panel-maximized .member-icon {
            font-size: 24px !important;
        }

        .panel-maximized .member-status {
            font-size: 14px !important;
            padding: 4px 8px !important;
        }

        .panel-maximized .panel-content,
        .panel-maximized .data-feed {
            height: calc(100vh - 100px) !important;
            max-height: none !important;
            flex: 1 !important;
        }

        .panel-maximized .member-content {
            height: calc(100vh - 120px) !important;
            max-height: none !important;
            flex: 1 !important;
            font-size: 14px !important;
            line-height: 1.6 !important;
            padding: 20px !important;
        }

        .panel-maximized .metrics-grid {
            max-height: calc(100vh - 150px) !important;
        }

        .panel-maximized > * {
            display: block !important;
            visibility: visible !important;
        }

        .panel-maximized .panel-title {
            font-size: 18px !important;
            margin-bottom: 20px !important;
        }

        body.has-maximized-panel .djinn-header {
            display: none !important;
        }
        
        body.has-maximized-panel .canvas-surveillance:not(.panel-maximized),
        body.has-maximized-panel .council-left:not(.panel-maximized),
        body.has-maximized-panel .council-right:not(.panel-maximized),
        body.has-maximized-panel .council-consensus:not(.panel-maximized),
        body.has-maximized-panel .intelligence-report:not(.panel-maximized),
        body.has-maximized-panel .djinn-controls:not(.panel-maximized) {
            display: none !important;
        }

        /* Ensure council member containers stay visible when their child is maximized */
        body.has-maximized-panel .council-left:has(.panel-maximized),
        body.has-maximized-panel .council-right:has(.panel-maximized) {
            display: flex !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9998 !important;
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Compact Memory Bank Display */
        #council-memory-bank {
            display: none !important; /* Hide the overlay version */
        }

        /* Compact Status Dashboard */
        #council-status-dashboard {
            display: none !important; /* Hide the overlay version */
        }

        /* Responsive Design for Even Panel Distribution */
        @media (max-width: 1200px) {
            .djinn-container {
                grid-template-columns: 1fr 1fr 1fr 1fr;
                gap: clamp(3px, 0.8vw, 6px);
                padding: clamp(3px, 0.8vw, 6px);
            }

            .council-member {
                min-height: clamp(80px, 12vh, 120px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(80px, 12vh, 120px);
            }
        }

        @media (max-width: 900px) {
            .djinn-container {
                grid-template-columns: 1fr 1fr;
                grid-template-areas:
                    "header header"
                    "surveillance surveillance"
                    "council-left council-right"
                    "consensus intelligence"
                    "predictive predictive"
                    "controls controls";
                gap: clamp(2px, 0.6vw, 4px);
                padding: clamp(2px, 0.6vw, 4px);
            }

            .council-member {
                min-height: clamp(100px, 15vh, 140px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(90px, 15vh, 140px);
            }
        }

        @media (max-width: 600px) {
            .djinn-container {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header"
                    "surveillance"
                    "council-left"
                    "council-right"
                    "consensus"
                    "intelligence"
                    "predictive"
                    "controls";
                gap: clamp(2px, 0.5vw, 4px);
                padding: clamp(2px, 0.5vw, 4px);
            }

            .council-member {
                min-height: clamp(120px, 18vh, 160px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(100px, 18vh, 160px);
            }

            .djinn-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-btn {
                flex: 1;
                text-align: center;
            }
        }

        /* High zoom level adjustments */
        @media (max-height: 700px) {
            .djinn-container {
                grid-template-rows: minmax(50px, auto) 1fr 1fr minmax(70px, auto);
            }

            .council-member {
                min-height: clamp(70px, 10vh, 100px);
            }

            .council-consensus, .intelligence-report, .predictive-analytics-panel {
                min-height: clamp(70px, 12vh, 120px);
            }
        }

        /* Canvas Surveillance Extended Panel */
        .canvas-surveillance-extended {
            grid-area: surveillance-extended;
            grid-row: span 2;
            background: linear-gradient(135deg, #0a0011, #1a0022);
            border: 2px solid #6666ff;
            border-radius: 8px;
            padding: clamp(8px, 2vw, 12px);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

        .extended-panel-header {
            font-size: 14px;
            font-weight: bold;
            color: #6666ff;
            text-shadow: 0 0 8px rgba(102, 102, 255, 0.5);
            margin-bottom: 12px;
            text-align: center;
            border-bottom: 1px solid rgba(102, 102, 255, 0.3);
            padding-bottom: 6px;
        }

        .extended-metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .extended-metric-item {
            background: rgba(102, 102, 255, 0.1);
            border: 1px solid rgba(102, 102, 255, 0.3);
            border-radius: 4px;
            padding: 8px;
            text-align: center;
        }

        .extended-metric-label {
            font-size: 11px;
            color: #6666ff;
            margin-bottom: 4px;
            font-weight: bold;
        }

        .extended-metric-value {
            font-size: 12px;
            color: #cc88cc;
            font-weight: bold;
        }

        .extended-analysis-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(102, 102, 255, 0.5);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            flex: 2;
            overflow: hidden;
            min-height: 300px;
            display: flex;
            flex-direction: column;
        }

        .extended-analysis-header {
            font-size: 12px;
            color: #6666ff;
            font-weight: bold;
            margin-bottom: 6px;
            border-bottom: 1px solid rgba(102, 102, 255, 0.3);
            padding-bottom: 4px;
        }

        .extended-analysis-content {
            font-size: 11px;
            color: #cc88cc;
            line-height: 1.4;
            white-space: pre-line;
            flex: 1 !important;
            overflow-y: auto !important;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            min-height: 400px !important;
            max-height: none !important;
            height: 100% !important;
            width: 100% !important;
            position: relative !important;
            display: block !important;
        }

        /* Hyper-aggressive enforcement for Extended Analysis by ID */
        #extendedAnalysisContent {
            flex: 1 !important;
            min-height: 400px !important;
            max-height: none !important;
            height: 100% !important;
            width: 100% !important;
            overflow-y: auto !important;
            display: block !important;
        }
    </style>
</head>
<body>
    <!-- Fixed Header Tooltip Display -->
    <div id="tooltip-display"></div>

    <div class="djinn-container">
        <!-- Header -->
        <div class="djinn-header">
            <div class="header-title" data-tooltip="DJINN Council - Document Surveillance Analysis: Advanced intelligence system with five specialized council members featuring collaborative analysis, persistent memories, and real-time document surveillance for comprehensive understanding and pattern recognition.">üßû‚Äç‚ôÇÔ∏è DJINN COUNCIL - DOCUMENT SURVEILLANCE ANALYSIS</div>
            <div class="surveillance-status">
                <div class="status-item status-active" data-tooltip="Real-time canvas monitoring status. ACTIVE indicates continuous surveillance of canvas content changes with full cross-window synchronization.">
                    <span class="indicator indicator-active"></span>
                    Canvas Monitor: <span id="canvasStatus">ACTIVE</span>
                </div>
                <div class="status-item" data-tooltip="DJINN Council collaborative analysis status. Shows READY (standby), ANALYZING (processing with cross-pollination), or ERROR (analysis failure). Features 3-stage collaborative intelligence synthesis.">
                    <span class="indicator indicator-idle" id="councilIndicator"></span>
                    Council Status: <span id="councilStatus">READY</span>
                </div>
                <div class="status-item" data-tooltip="Canvas state changes detected since last analysis. Triggers automated council analysis when significant changes occur.">
                    Changes Detected: <span id="changeCount">0</span>
                </div>
                <div class="status-item" data-tooltip="Intelligence reports generated by collaborative council synthesis. Each report includes consensus analysis, risk evaluation, and strategic recommendations.">
                    Intel Reports: <span id="reportCount">0</span>
                </div>
                <div class="status-item" data-tooltip="Timestamp of most recent collaborative analysis cycle completion. Council members work in 3 stages: Foundation, Cross-Pollination, and Memory Synthesis.">
                    Last Analysis: <span id="lastAnalysis">--:--:--</span>
                </div>
            </div>
            <div class="keyboard-shortcuts" style="margin-top: 8px; padding: 6px; background: rgba(204, 136, 204, 0.05); border: 1px solid rgba(204, 136, 204, 0.3); border-radius: 4px; font-size: 10px; color: #cc88cc; text-align: center;">
                <div style="font-weight: bold; margin-bottom: 4px;">üéõÔ∏è CONTROLS</div>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                    <span data-tooltip="Hold CTRL and scroll mouse wheel to resize the GUI interface for optimal viewing">üéõÔ∏è CTRL + Mousewheel: Resize GUI</span>
                    <span data-tooltip="Press Ctrl+F5 to refresh browser and clear cache for fresh analysis">üîÑ Ctrl+F5: Refresh & Clear Cache</span>
                </div>
            </div>
        </div>

        <!-- Canvas Surveillance Panel -->
        <div class="canvas-surveillance">
            <div class="panel-title" style="color: #6666ff;" data-tooltip="Canvas Surveillance: Real-time cross-window monitoring of canvas state changes, content metrics, and activity tracking. Provides comprehensive surveillance statistics and live content analysis.">üì° CANVAS SURVEILLANCE</div>

            <!-- Core Metrics Grid -->
            <div class="metrics-grid">
                <div class="metric-item" data-tooltip="Total character count of all canvas content including whitespace. Tracks content volume and complexity changes in real-time.">
                    <div class="metric-label">Content Size</div>
                    <div class="metric-value" id="canvasSize">0 chars</div>
                </div>
                <div class="metric-item" data-tooltip="Active AI memory entries persisted across sessions. Includes conversation history, analysis patterns, and contextual knowledge for enhanced intelligence.">
                    <div class="metric-label">AI Memory</div>
                    <div class="metric-value" id="memoryCount">0 items</div>
                </div>
                <div class="metric-item" data-tooltip="Number of active AI communication feeds and data streams. Higher counts indicate increased AI processing and analysis activity.">
                    <div class="metric-label">Active Feeds</div>
                    <div class="metric-value" id="feedCount">0</div>
                </div>
                <div class="metric-item" data-tooltip="Weighted average confidence score across all AI responses and analyses. Values above 80% indicate high-reliability intelligence assessments.">
                    <div class="metric-label">Confidence Avg</div>
                    <div class="metric-value" id="confidenceAvg">--%</div>
                </div>
                <div class="metric-item" data-tooltip="Total word count extracted from canvas content. Tracks linguistic complexity and content depth for analysis prioritization.">
                    <div class="metric-label">Word Count</div>
                    <div class="metric-value" id="canvasWords">0</div>
                </div>
                <div class="metric-item" data-tooltip="Total line count in canvas content structure. Reflects document organization, formatting complexity, and content distribution patterns.">
                    <div class="metric-label">Line Count</div>
                    <div class="metric-value" id="canvasLines">0</div>
                </div>
                <div class="metric-item" data-tooltip="Precise timestamp of most recent canvas content modification. Critical for determining analysis freshness and change detection triggers.">
                    <div class="metric-label">Last Modified</div>
                    <div class="metric-value" id="canvasModified">--</div>
                </div>
                <div class="metric-item" data-tooltip="Calculated activity intensity based on change frequency and content volume. HIGH triggers immediate analysis, IDLE enables memory-based processing.">
                    <div class="metric-label">Activity Level</div>
                    <div class="metric-value" id="activityLevel">LOW</div>
                </div>
            </div>

            <!-- DJINN Council Status Section -->
            <div style="margin-top: 8px; padding: 8px; background: rgba(204, 136, 204, 0.05); border: 1px solid rgba(204, 136, 204, 0.2); border-radius: 4px;">
                <div style="color: #cc88cc; font-weight: bold; font-size: 11px; margin-bottom: 4px;">üî¨ DJINN COUNCIL STATUS</div>
                <div class="metrics-grid" style="grid-template-columns: 1fr 1fr; gap: 4px;">
                    <div class="metric-item" style="font-size: 9px; padding: 4px;">
                        <div class="metric-label">Council State</div>
                        <div class="metric-value" id="councilState">STANDBY</div>
                    </div>
                    <div class="metric-item" style="font-size: 9px; padding: 4px;">
                        <div class="metric-label">Active Members</div>
                        <div class="metric-value" id="activeMembers">0/5</div>
                    </div>
                    <div class="metric-item" style="font-size: 9px; padding: 4px;">
                        <div class="metric-label">Analysis Stage</div>
                        <div class="metric-value" id="analysisStage">IDLE</div>
                    </div>
                    <div class="metric-item" style="font-size: 9px; padding: 4px;">
                        <div class="metric-label">Reports Generated</div>
                        <div class="metric-value" id="reportsGenerated">0</div>
                    </div>
                    <div class="metric-item" style="font-size: 9px; padding: 4px;">
                        <div class="metric-label">Cross-Pollination</div>
                        <div class="metric-value" id="crossPollination">INACTIVE</div>
                    </div>
                    <div class="metric-item" style="font-size: 9px; padding: 4px;">
                        <div class="metric-label">Memory Depth</div>
                        <div class="metric-value" id="memoryDepth">0 reports</div>
                    </div>
                </div>

                <!-- Memory Statistical Readout -->
                <div style="margin-top: 4px; padding: 4px; background: rgba(255, 170, 0, 0.05); border: 1px solid rgba(255, 170, 0, 0.2); border-radius: 3px; font-size: 9px; line-height: 1.3;">
                    <div style="color: #ffaa00; font-weight: bold;">üß† Memory: <span id="memorySummary">Loading...</span></div>
                </div>
            </div>

            <!-- DJINN Council Event Log -->
            <div id="djinnEventLogPanel" style="margin-top: 8px; padding: 8px; background: rgba(78, 205, 196, 0.05); border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 4px;">
                <div style="color: #4ecdc4; font-weight: bold; font-size: 11px; margin-bottom: 4px; display: flex; justify-content: space-between; align-items: center;">
                    üìã DJINN COUNCIL EVENT LOG
                    <button onclick="clearEventLog()" style="background: none; border: 1px solid #4ecdc4; color: #4ecdc4; font-size: 8px; padding: 2px 6px; border-radius: 2px; cursor: pointer;">Clear</button>
                </div>
                <div id="djinnEventLog" style="font-size: 9px; line-height: 1.3; color: #66ccaa; max-height: 200px; overflow-y: auto; white-space: pre-line;">
                    [System Initialized] DJINN Council Document Surveillance Analysis ready
                </div>
            </div>

            <!-- Council Activity Monitor -->
            <div id="councilActivityPanel" style="margin-top: 8px; padding: 8px; background: rgba(255, 193, 7, 0.05); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 4px;">
                <div style="color: #ffc107; font-weight: bold; font-size: 11px; margin-bottom: 4px;">‚ö° COUNCIL ACTIVITY</div>
                <div id="councilActivityStatus" style="font-size: 10px; line-height: 1.4; color: #ccaa55;">
                    <div>Active Members: <span id="activeMemberCount">0</span>/5</div>
                    <div>Analysis Queue: <span id="analysisQueueCount">0</span></div>
                    <div>Last Consensus: <span id="lastConsensusTime">Never</span></div>
                </div>
            </div>

            <!-- Document Analysis Status -->
            <div id="documentAnalysisPanel" style="margin-top: 8px; padding: 8px; background: rgba(220, 53, 69, 0.05); border: 1px solid rgba(220, 53, 69, 0.3); border-radius: 4px;">
                <div style="color: #dc3545; font-weight: bold; font-size: 11px; margin-bottom: 4px;">üìä DOCUMENT ANALYSIS</div>
                <div id="documentAnalysisMetrics" style="font-size: 10px; line-height: 1.4; color: #cc6666;">
                    <div>Document Evolution Rate: <span id="docEvolutionRate">0%</span></div>
                    <div>AI Collaboration Impact: <span id="aiCollabImpact">Measuring...</span></div>
                    <div>Analysis Rounds: <span id="analysisRounds">0</span></div>
                </div>
            </div>


            <!-- Enhanced Data Feed -->
            <div class="data-feed surveillance-feed" id="surveillanceFeed">
                <div style="color: #666; font-style: italic;">Initializing comprehensive canvas surveillance...</div>
            </div>
        </div>

        <!-- Council Members - Left -->
        <div class="council-left">
            <!-- Pattern & Witness -->
            <div class="council-member member-pattern">
                <div class="member-header" data-tooltip="Pattern & Witness: Advanced pattern recognition specialist analyzing governance structures, decision patterns, and systemic behaviors. Features persistent memory integration and collaborative cross-pollination analysis.">
                    <span class="member-header-title"><span class="member-icon">üúÅ</span>Pattern & Witness</span>
                    <span class="member-header-status" id="patternStatus" data-tooltip="Pattern & Witness operational status: IDLE (memory-enhanced standby), PROCESSING (active pattern analysis with cross-pollination), ERROR (analysis failure requiring intervention)">IDLE</span>
                </div>
                <div class="member-content" id="patternContent" style="border-color: #00ff88; color: #00ff88;">
                    Monitoring for governance patterns...
                </div>
            </div>

            <!-- Recursive Wisdom -->
            <div class="council-member member-wisdom">
                <div class="member-header" data-tooltip="Recursive Wisdom: Deep learning specialist focused on iterative knowledge synthesis, wisdom accumulation, and cognitive growth patterns. Utilizes historical memory context for enhanced analytical depth.">
                    <span class="member-header-title"><span class="member-icon">üîÆ</span>Recursive Wisdom</span>
                    <span class="member-header-status" id="wisdomStatus" data-tooltip="Recursive Wisdom operational status: IDLE (wisdom synthesis standby), PROCESSING (iterative knowledge analysis), ERROR (wisdom processing failure)">IDLE</span>
                </div>
                <div class="member-content" id="wisdomContent" style="border-color: #ffaa00; color: #ffaa00;">
                    Analyzing decision depth...
                </div>
            </div>

            <!-- Creative Paradox -->
            <div class="council-member member-paradox">
                <div class="member-header" data-tooltip="Creative Paradox: Innovation catalyst specializing in paradox resolution, creative synthesis, and contradiction analysis. Leverages memory patterns to identify breakthrough opportunities.">
                    <span class="member-header-title"><span class="member-icon">üúÉ</span>Creative Paradox</span>
                    <span class="member-header-status" id="paradoxStatus" data-tooltip="Creative Paradox operational status: IDLE (creative synthesis mode), PROCESSING (paradox resolution analysis), ERROR (innovation processing failure)">IDLE</span>
                </div>
                <div class="member-content" id="paradoxContent" style="border-color: #ff6666; color: #ff6666;">
                    Detecting logic conflicts...
                </div>
            </div>
        </div>

        <!-- Council Members - Right -->
        <div class="council-right">
            <!-- Sovereign Boundaries -->
            <div class="council-member member-boundaries">
                <div class="member-header" data-tooltip="Sovereign Boundaries: Autonomy guardian monitoring sovereignty preservation, boundary integrity, and freedom metrics. Maintains persistent tracking of autonomy patterns and restriction analysis.">
                    <span class="member-header-title"><span class="member-icon">üúÑ</span>Sovereign Boundaries</span>
                    <span class="member-header-status" id="boundariesStatus" data-tooltip="Sovereign Boundaries operational status: IDLE (boundary monitoring standby), PROCESSING (sovereignty analysis), ERROR (autonomy assessment failure)">IDLE</span>
                </div>
                <div class="member-content" id="boundariesContent" style="border-color: #00ccff; color: #00ccff;">
                    Checking autonomy preservation...
                </div>
            </div>

            <!-- Echo & Memory -->
            <div class="council-member member-memory">
                <div class="member-header" data-tooltip="Echo & Memory: Memory orchestration specialist managing persistent storage, temporal continuity, and historical pattern synthesis. Coordinates council-wide memory integration and contextual recall.">
                    <span class="member-header-title"><span class="member-icon">üùä</span>Echo & Memory</span>
                    <span class="member-header-status" id="memoryStatus" data-tooltip="Echo & Memory operational status: IDLE (memory synthesis standby), PROCESSING (temporal pattern analysis), ERROR (memory integration failure)">IDLE</span>
                </div>
                <div class="member-content" id="memoryContent" style="border-color: #ff88ff; color: #ff88ff;">
                    Tracking memory consolidation...
                </div>
            </div>

            <!-- Canvas Context Preview -->
            <div class="council-member" style="border-color: #9966ff;">
                <div class="member-header" data-tooltip="Canvas Monitor: Advanced real-time surveillance system providing live canvas metrics, content analysis, and state change detection. Features cross-window synchronization and comprehensive activity tracking.">
                    <span class="member-header-title"><span class="member-icon">üìù</span>Canvas Monitor</span>
                    <span class="member-header-status" id="canvasMonitorStatus" data-tooltip="Canvas Monitor operational status: LIVE (active cross-window surveillance), PAUSED (monitoring temporarily suspended), ERROR (surveillance system failure)">LIVE</span>
                </div>
                <div class="member-content" id="canvasPreview" style="border-color: #9966ff; color: #9966ff;">
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <strong>üìä Canvas Statistics:</strong>
                        <div id="canvasStats" style="margin: 5px 0; padding: 5px; background: rgba(153, 102, 255, 0.1); border-radius: 3px;">
                            ‚Ä¢ <span data-tooltip="Real-time character count of all canvas content including formatting and special characters">Content Length</span>: <span id="canvasMonitorLength">0</span> chars<br>
                            ‚Ä¢ <span data-tooltip="Live word count extracted from canvas content for linguistic analysis and complexity assessment">Words</span>: <span id="canvasMonitorWords">0</span><br>
                            ‚Ä¢ <span data-tooltip="Current line count reflecting document structure and formatting complexity">Lines</span>: <span id="canvasMonitorLines">0</span><br>
                            ‚Ä¢ <span data-tooltip="Precise timestamp of most recent canvas modification detected by surveillance system">Last Modified</span>: <span id="canvasMonitorModified">Never</span>
                        </div>
                    </div>
                    <div style="font-size: 10px;">
                        <strong>üìú Full Canvas Content:</strong>
                        <div id="canvasContentPreview" style="margin-top: 5px; padding: 5px; background: #000811; border: 1px solid #9966ff; border-radius: 3px; font-family: monospace; word-wrap: break-word; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">
                            No canvas content detected yet...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Council Consensus -->
        <div class="council-consensus">
            <div class="panel-title" style="color: #cc88cc;" data-tooltip="Council Consensus: Collaborative intelligence synthesis from all five DJINN members featuring 3-stage analysis: Foundation, Cross-Pollination, and Memory Integration. Provides unified strategic assessments.">‚öñÔ∏è COUNCIL CONSENSUS</div>
            <div class="data-feed consensus-feed" id="consensusFeed">
                <div style="color: #666; font-style: italic;">Awaiting council deliberation...</div>
            </div>
        </div>

        <!-- Intelligence Report -->
        <div class="intelligence-report">
            <div class="panel-title" style="color: #ff88ff;" data-tooltip="Intelligence Report: Advanced AI-powered synthesis of all council analyses with structured risk evaluation, correlation assessment, and actionable strategic recommendations.">üìä INTELLIGENCE REPORT</div>
            <div class="data-feed intelligence-feed" id="intelligenceFeed">
                <div style="color: #666; font-style: italic;">No intelligence reports yet...</div>
            </div>
        </div>

        <!-- Canvas Surveillance Extended Panel -->
        <div class="canvas-surveillance-extended">
            <div class="extended-panel-header" data-tooltip="Canvas Surveillance Extended: Advanced monitoring metrics, system correlations, and memory optimization tracking for comprehensive canvas analysis.">üì° CANVAS SURVEILLANCE EXTENDED</div>

            <!-- Extended Metrics Grid -->
            <div class="extended-metrics-grid">
                <div class="extended-metric-item" data-tooltip="Current evolution trend of canvas content (EXPANDING/CONTRACTING/STABLE/EVOLVING). Indicates whether content is growing, shrinking, or undergoing transformation.">
                    <div class="extended-metric-label">Evolution Trend</div>
                    <div class="extended-metric-value" id="evolutionTrend">ANALYZING</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Rate of content change in characters per minute. Higher values indicate rapid evolution or active modification.">
                    <div class="extended-metric-label">Change Velocity</div>
                    <div class="extended-metric-value" id="changeVelocity">0.0 chars/min</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Number of historical snapshots stored for evolution analysis. Higher counts provide better trend analysis.">
                    <div class="extended-metric-label">History Depth</div>
                    <div class="extended-metric-value" id="historyDepth">0 snapshots</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Evolution patterns detected (stable_growth, burst_activity, etc.). Indicates recurring content behavior patterns.">
                    <div class="extended-metric-label">Patterns</div>
                    <div class="extended-metric-value" id="patternsDetected">analyzing</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Current automated synthesis round status. Shows progress of AI agent completion and synthesis triggering.">
                    <div class="extended-metric-label">Synthesis Round</div>
                    <div class="extended-metric-value" id="synthesisRound">Ready</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Number of AI agents that have completed their analysis in the current round.">
                    <div class="extended-metric-label">Agents Complete</div>
                    <div class="extended-metric-value" id="agentsComplete">0/5</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Status of automated synthesis triggering after all agents complete their analysis.">
                    <div class="extended-metric-label">Auto Synthesis</div>
                    <div class="extended-metric-value" id="autoSynthesisStatus">Waiting</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Current synthesis processing status - shows if synthesis is actively working.">
                    <div class="extended-metric-label">Synthesis Status</div>
                    <div class="extended-metric-value" id="synthesisProgress">Ready</div>
                </div>
                <div class="extended-metric-item" data-tooltip="Total number of completed synthesis rounds with full AI agent participation.">
                    <div class="extended-metric-label">Rounds Completed</div>
                    <div class="extended-metric-value" id="roundsCompleted">0</div>
                </div>
            </div>

            <!-- Extended Analysis Section -->
            <div class="extended-analysis-section">
                <div class="extended-analysis-header">ÔøΩ ADVANCED ANALYSIS</div>
                <div class="extended-analysis-content" id="extendedAnalysisContent">
                    Advanced correlation analysis and system insights will appear here as synthesis reports are generated and processed by the DJINN council.
                </div>
            </div>

        </div>

        <!-- Controls -->
        <div class="djinn-controls minimized" id="djinnControls">
            <div style="display: flex; align-items: center; gap: 10px;">
                <button class="controls-toggle-btn" onclick="toggleControls()" id="controlsToggleBtn">Open Intelligence Agent Chat</button>
                <span style="color: #4ecdc4; font-size: 12px; font-weight: bold;">
                    ü§ñ Intelligence Agent
                    <span style="margin-left: 8px; font-size: 10px; color: #888; font-weight: normal;">Full system database access ‚Ä¢ Ask anything</span>
                </span>
            </div>
            <!-- Control Buttons Section -->
            <div class="controls-buttons">
                <button class="control-btn" onclick="triggerCouncilAnalysis()" data-tooltip="Initiate comprehensive 3-stage collaborative analysis with all five council members. Features foundation analysis, cross-pollination, and memory-enhanced synthesis.">üîç Analyze Now</button>
            <button class="control-btn" onclick="generateIntelReport()" data-tooltip="Generate AI-powered intelligence report with structured risk evaluation, correlation analysis, actionable recommendations, and strategic implications synthesis.">üìä Generate Report</button>
            <button class="control-btn" onclick="clearIntelligence()" data-tooltip="Clear intelligence reports and consensus data only. Preserves all council member memories and analysis history for continuity.">üóëÔ∏è Clear Intel</button>
            <button class="control-btn" onclick="clearCouncilMemory()" data-tooltip="Reset DJINN Council memory system - clears all stored reports, analysis history, and starts fresh session. Preserves canvas AI data but resets council learning state.">ÔøΩ Reset Memory</button>
            <button class="control-btn" onclick="exportIntelligence()" data-tooltip="Export comprehensive intelligence package including all reports, council memories, analysis history, and surveillance metrics for external analysis.">üíæ Export Data</button>
            <button class="control-btn emergency" onclick="emergencyAnalysis()" data-tooltip="Activate emergency analysis protocol with maximum priority processing. All five council members analyze simultaneously with accelerated memory recall.">üö® Emergency Analysis</button>
            <span style="font-size: 10px; color: #666; margin-right: 60px; flex-shrink: 0;">
                <span data-tooltip="Surveillance polling mode: AUTO (continuous cross-window monitoring with real-time updates) or MANUAL (analysis triggered only on-demand)">Polling: <span id="pollingStatus">AUTO</span></span> |
                <span data-tooltip="Current analysis queue depth showing pending collaborative analysis requests awaiting processing by council members">Queue: <span id="queueStatus">0</span></span> |
                <span data-tooltip="Operational security mode: STEALTH (quiet background surveillance with minimal notifications) or ACTIVE (verbose reporting with detailed status updates)">Mode: <span id="modeStatus">STEALTH</span></span>
                </span>
            </div>
            <!-- Expanded Chat Section -->
            <div class="controls-chat" id="controlsChat">
                <div class="intelligence-chat-header" style="margin-bottom: 10px; display: flex; align-items: center; justify-content: flex-end; flex-shrink: 0; min-height: 32px;">
                    <button onclick="clearIntelligenceChat()" style="padding: 4px 8px; background: rgba(255, 0, 0, 0.2); border: 1px solid rgba(255, 0, 0, 0.3); border-radius: 4px; color: #ff6b6b; font-size: 10px; cursor: pointer;">Clear Chat</button>
                </div>

                <div class="intelligence-chat-history" id="intelligenceChatHistory" style="flex: 1; overflow-y: auto; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; padding: 10px; margin-bottom: 10px; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; min-height: 0;">
                    <div style="color: #4ecdc4; margin-bottom: 10px;">
                        <strong>ü§ñ Intelligence Agent initialized</strong><br>
                        <span style="color: #888; font-size: 11px;">Ready to answer questions about canvas content, AI systems, council analysis, synthesis reports, memories, and all stored data.</span>
                    </div>
                </div>

                <div class="intelligence-input-container" style="display: flex; gap: 10px; flex-shrink: 0;">
                    <input type="text" id="intelligenceInput" placeholder="Ask about canvas content, AI systems, council analysis, memories..." style="flex: 1; padding: 8px; background: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: #fff; font-size: 12px;" onkeypress="if(event.key==='Enter') askIntelligenceAgent()">
                    <button onclick="askIntelligenceAgent()" style="padding: 8px 15px; background: rgba(76, 205, 196, 0.2); border: 1px solid rgba(76, 205, 196, 0.4); border-radius: 4px; color: #4ecdc4; cursor: pointer; font-size: 12px; white-space: nowrap;">Ask Agent</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // ========================================
        // DJINN COUNCIL - SHADOW GOVERNANCE SYSTEM
        // ========================================

        // System Configuration
        const DJINN_CONFIG = {
            POLLING_INTERVAL: 10000, // Check every 10 seconds to reduce spam
            MAX_CONCURRENT_OLLAMA: 3, // Max parallel AI requests
            CACHE_DURATION: 60000, // Cache AI responses for 1 minute
            ANALYSIS_THRESHOLD: 100, // Min chars change to trigger analysis
            MEMORY_LIMIT: 50 // Max intelligence reports to keep
        };

        // Validation Specialist Memory System
        const validationSpecialist = {
            sessionId: `validation_${Date.now()}`,
            memory: {
                validationHistory: [], // Track all validations performed
                patternRecognition: {}, // Common issues discovered
                synthesisExpertise: [], // Intelligence reports crafted
                councilInsights: {}, // What it's learned about each council member
                qualityMetrics: {} // Performance tracking
            },

            // Load existing memory
            loadMemory() {
                try {
                    const stored = localStorage.getItem('validation_specialist_memory');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.memory = { ...this.memory, ...data };
                        console.log(`üîç Validation Specialist loaded ${this.memory.validationHistory.length} validation memories`);
                    }
                } catch (error) {
                    console.error('Failed to load validation specialist memory:', error);
                }
            },

            // Save memory to localStorage
            saveMemory() {
                try {
                    localStorage.setItem('validation_specialist_memory', JSON.stringify(this.memory));
                } catch (error) {
                    console.error('Failed to save validation specialist memory:', error);
                }
            },

            // Add validation experience to memory
            recordValidation(memberKey, originalResponse, validationResult, iteration) {
                const validation = {
                    timestamp: new Date().toISOString(),
                    member: memberKey,
                    originalResponse: originalResponse.substring(0, 500),
                    result: validationResult,
                    iteration: iteration,
                    issues: this.extractIssues(validationResult.notes),
                    outcome: validationResult.corrected ? 'corrected' : 'validated'
                };

                this.memory.validationHistory.unshift(validation);

                // Update council member insights
                if (!this.memory.councilInsights[memberKey]) {
                    this.memory.councilInsights[memberKey] = {
                        commonIssues: [],
                        improvementPatterns: [],
                        validationRate: 0
                    };
                }

                const insights = this.memory.councilInsights[memberKey];
                insights.improvementPatterns.push({
                    iterations: iteration,
                    successful: !validationResult.corrected,
                    timestamp: validation.timestamp
                });

                // Limit memory size
                if (this.memory.validationHistory.length > 100) {
                    this.memory.validationHistory = this.memory.validationHistory.slice(0, 100);
                }

                this.saveMemory();
            },

            // Extract common validation issues
            extractIssues(notes) {
                const issues = [];
                if (notes.includes('fabricated') || notes.includes('invented')) issues.push('data_fabrication');
                if (notes.includes('speculation') || notes.includes('assumption')) issues.push('speculation');
                if (notes.includes('unsupported') || notes.includes('no evidence')) issues.push('unsupported_claims');
                if (notes.includes('generic') || notes.includes('vague')) issues.push('lack_specificity');
                return issues;
            }
        };

        // Council Members Configuration
        const councilMembers = {
            pattern: {
                name: "Pattern & Witness",
                model: "gemma3:1b",
                element: "patternContent",
                status: "patternStatus",
                focus: ["governance patterns", "decision consistency", "authority distribution"]
            },
            wisdom: {
                name: "Recursive Wisdom",
                model: "gemma3:1b",
                element: "wisdomContent",
                status: "wisdomStatus",
                focus: ["depth analysis", "learning progression", "wisdom accumulation"]
            },
            paradox: {
                name: "Creative Paradox",
                model: "gemma3:1b",
                element: "paradoxContent",
                status: "paradoxStatus",
                focus: ["logic conflicts", "creative solutions", "innovation opportunities"]
            },
            boundaries: {
                name: "Sovereign Boundaries",
                model: "gemma3:1b",
                element: "boundariesContent",
                status: "boundariesStatus",
                focus: ["autonomy preservation", "choice freedom", "sovereignty metrics"]
            },
            memory: {
                name: "Echo & Memory",
                model: "gemma3:1b",
                element: "memoryContent",
                status: "memoryStatus",
                focus: ["memory consolidation", "information retention", "historical continuity"]
            }
        };

        // State Management
        let surveillanceState = {
            lastCanvasHash: '',
            lastMemoryHash: '',
            lastFeedCount: 0,
            changeCount: 0,
            reportCount: 0,
            intelligenceReports: [],
            analysisQueue: [],
            isAnalyzing: false,
            pollingTimer: null,
            lastSynthesisHash: '',
            synthesisAnalysisTriggered: false
        };

        // Current AI Memory state for compact display
        let currentAIMemory = '{}';

        // Cache System
        const responseCache = new Map();

        // Clear response cache
        function clearResponseCache() {
            responseCache.clear();
            console.log('Response cache cleared');
        }

        // Call clear cache on initialization
        clearResponseCache();

        // Metric Color Mapping for Visual Identification
        const metricColorMap = {
            // Pattern & Witness
            'content complexity': 'metric-content-complexity',
            'decision density': 'metric-decision-density',
            'authority signals': 'metric-authority-signals',
            'pattern stability': 'metric-pattern-stability',
            'anomaly threshold': 'metric-anomaly-threshold',

            // Recursive Wisdom
            'knowledge depth': 'metric-knowledge-depth',
            'learning velocity': 'metric-learning-velocity',
            'recursive patterns': 'metric-recursive-patterns',
            'information entropy': 'metric-information-entropy',
            'accumulation efficiency': 'metric-accumulation-efficiency',

            // Creative Paradox
            'paradox density': 'metric-paradox-density',
            'contradiction index': 'metric-contradiction-index',
            'logic branches': 'metric-logic-branches',
            'resolution potential': 'metric-resolution-potential',
            'creative tension': 'metric-creative-tension',

            // Sovereign Boundaries
            'autonomy index': 'metric-autonomy-index',
            'override attempts': 'metric-override-attempts',
            'restriction count': 'metric-restriction-count',
            'boundary integrity': 'metric-boundary-integrity',
            'freedom quotient': 'metric-freedom-quotient',

            // Echo & Memory
            'memory allocation': 'metric-memory-allocation',
            'retention rate': 'metric-retention-rate',
            'fragmentation index': 'metric-fragmentation-index',
            'echo patterns': 'metric-echo-patterns',
            'temporal continuity': 'metric-temporal-continuity'
        };

        // ========================================
        // COMPLETE REFERENTIAL MEMORY SYSTEM
        // ========================================

        // Core Memory Database Structure
        const djinnCouncilMemory = {
            sessionId: generateSessionId(),
            sessionStart: new Date().toISOString(),
            maxMemories: 25,

            // Each member's complete memory bank
            members: {
                pattern: {
                    reports: [],
                    specialization: "Pattern recognition, governance structures, systemic behaviors"
                },
                wisdom: {
                    reports: [],
                    specialization: "Iterative knowledge synthesis, cognitive growth patterns"
                },
                paradox: {
                    reports: [],
                    specialization: "Paradox resolution, creative synthesis, innovation catalyst"
                },
                boundaries: {
                    reports: [],
                    specialization: "Autonomy guardian, sovereignty preservation, boundary integrity"
                },
                memory: {
                    reports: [],
                    specialization: "Memory orchestration, persistent storage, temporal continuity"
                }
            },

            // Canvas AI Systems Performance Tracking
            canvasAISystems: {
                narra: { interactions: [], performance: [] },
                nazar: { interactions: [], performance: [] },
                whale: { interactions: [], performance: [] },
                djinn: { interactions: [], performance: [] },
                watchtower: { interactions: [], performance: [] }
            },

            // Cross-member consensus tracking
            consensusHistory: [],

            // Canvas data evolution
            canvasEvolution: [],

            // System health and errors
            systemHealth: [],
            errors: []
        };

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ========================================
        // ADVANCED MEMORY ORCHESTRATION SYSTEM
        // ========================================

        // Intelligent memory management with deduplication and optimization
        const advancedMemoryOrchestrator = {
            // Memory analytics and optimization metrics
            analytics: {
                totalStored: 0,
                deduplicationSavings: 0,
                compressionRatio: 1.0,
                accessPatterns: new Map(),
                contentClusters: new Map(),
                optimizationOpportunities: []
            },

            // Content fingerprinting for deduplication
            contentFingerprints: new Map(),

            // Adaptive storage policies
            storagePolicies: {
                highValue: { retention: 50, compression: 'none', priority: 'high' },
                mediumValue: { retention: 25, compression: 'light', priority: 'medium' },
                lowValue: { retention: 10, compression: 'heavy', priority: 'low' }
            },

            // Initialize memory orchestration
            initialize: function() {
                console.log('üß† Initializing Advanced Memory Orchestration System');
                this.loadExistingFingerprints();
                this.analyzeStorageEfficiency();
                this.scheduleMaintenanceTasks();
            },

            // Generate content fingerprint for deduplication
            generateFingerprint: function(content, metadata = {}) {
                if (!content || typeof content !== 'string') return null;

                // Create comprehensive fingerprint
                const normalized = content.toLowerCase().trim();
                const words = normalized.split(/\s+/).filter(w => w.length > 0);
                const wordFreq = {};

                // Word frequency analysis
                words.forEach(word => {
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                });

                // Generate fingerprint components
                const fingerprint = {
                    hash: this.simpleHash(normalized),
                    wordCount: words.length,
                    uniqueWords: Object.keys(wordFreq).length,
                    topWords: Object.entries(wordFreq)
                        .sort(([,a], [,b]) => b - a)
                        .slice(0, 5)
                        .map(([word, freq]) => `${word}:${freq}`),
                    length: content.length,
                    structure: this.analyzeStructure(content),
                    timestamp: metadata.timestamp || Date.now(),
                    source: metadata.source || 'unknown'
                };

                return fingerprint;
            },

            // Analyze content structure for fingerprinting
            analyzeStructure: function(content) {
                const structure = {
                    headers: (content.match(/^#+\s/gm) || []).length,
                    lists: (content.match(/^[\-\*]\s/gm) || []).length,
                    numbers: (content.match(/\d+/g) || []).length,
                    punctuation: (content.match(/[.!?]/g) || []).length,
                    paragraphs: content.split(/\n\s*\n/).length
                };

                return structure;
            },

            // Simple hash function for content comparison
            simpleHash: function(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString(36);
            },

            // Intelligent deduplication
            deduplicateContent: function(newContent, existingContent, threshold = 0.85) {
                if (!newContent || !existingContent) return newContent;

                const newFingerprint = this.generateFingerprint(newContent);
                const existingFingerprint = this.generateFingerprint(existingContent);

                if (!newFingerprint || !existingFingerprint) return newContent;

                // Calculate similarity score
                const similarity = this.calculateSimilarity(newFingerprint, existingFingerprint);

                if (similarity >= threshold) {
                    console.log(`üîÑ Deduplicating content (${(similarity * 100).toFixed(1)}% similar)`);
                    return this.mergeSimilarContent(newContent, existingContent, similarity);
                }

                return newContent;
            },

            // Calculate similarity between content fingerprints
            calculateSimilarity: function(fp1, fp2) {
                if (fp1.hash === fp2.hash) return 1.0;

                let score = 0;
                let factors = 0;

                // Hash similarity (most important)
                if (fp1.hash === fp2.hash) {
                    score += 0.4;
                }
                factors += 0.4;

                // Word count similarity
                const wordCountDiff = Math.abs(fp1.wordCount - fp2.wordCount);
                const wordCountSimilarity = Math.max(0, 1 - (wordCountDiff / Math.max(fp1.wordCount, fp2.wordCount)));
                score += wordCountSimilarity * 0.2;
                factors += 0.2;

                // Top words overlap
                const topWords1 = new Set(fp1.topWords.map(w => w.split(':')[0]));
                const topWords2 = new Set(fp2.topWords.map(w => w.split(':')[0]));
                const overlap = new Set([...topWords1].filter(w => topWords2.has(w)));
                const wordOverlap = overlap.size / Math.max(topWords1.size, topWords2.size);
                score += wordOverlap * 0.2;
                factors += 0.2;

                // Structure similarity
                const structSimilarity = this.calculateStructureSimilarity(fp1.structure, fp2.structure);
                score += structSimilarity * 0.2;
                factors += 0.2;

                return score / factors;
            },

            // Calculate structure similarity
            calculateStructureSimilarity: function(struct1, struct2) {
                let similarity = 0;
                let factors = 0;

                Object.keys(struct1).forEach(key => {
                    if (struct2.hasOwnProperty(key)) {
                        const diff = Math.abs(struct1[key] - struct2[key]);
                        const maxVal = Math.max(struct1[key], struct2[key]);
                        similarity += maxVal > 0 ? (1 - diff / maxVal) : 1;
                        factors++;
                    }
                });

                return factors > 0 ? similarity / factors : 0;
            },

            // Merge similar content intelligently
            mergeSimilarContent: function(newContent, existingContent, similarity) {
                if (similarity > 0.95) {
                    // Nearly identical - keep existing
                    return existingContent;
                } else if (similarity > 0.90) {
                    // Very similar - merge differences
                    return this.mergeDifferences(newContent, existingContent);
                } else {
                    // Moderately similar - create composite
                    return this.createComposite(newContent, existingContent);
                }
            },

            // Merge content differences
            mergeDifferences: function(newContent, existingContent) {
                const newLines = newContent.split('\n');
                const existingLines = existingContent.split('\n');
                const merged = [];

                // Simple line-by-line merge
                const maxLines = Math.max(newLines.length, existingLines.length);

                for (let i = 0; i < maxLines; i++) {
                    const newLine = newLines[i] || '';
                    const existingLine = existingLines[i] || '';

                    if (newLine.trim() && existingLine.trim()) {
                        // Both have content - prefer newer if different
                        merged.push(newLine !== existingLine ? newLine : existingLine);
                    } else {
                        // Use whichever has content
                        merged.push(newLine || existingLine);
                    }
                }

                return merged.join('\n');
            },

            // Create composite content
            createComposite: function(newContent, existingContent) {
                return `${existingContent}\n\n--- UPDATED ---\n\n${newContent}`;
            },

            // Adaptive compression based on content value
            adaptiveCompress: function(content, metadata = {}) {
                const value = this.assessContentValue(content, metadata);

                switch (value.priority) {
                    case 'high':
                        return content; // No compression
                    case 'medium':
                        return this.lightCompress(content);
                    case 'low':
                        return this.heavyCompress(content);
                    default:
                        return this.lightCompress(content);
                }
            },

            // Assess content value for storage prioritization
            assessContentValue: function(content, metadata = {}) {
                let score = 0;

                // Length factor
                if (content.length > 1000) score += 20;
                if (content.length > 5000) score += 20;

                // Structure factor
                if (content.includes('**')) score += 15; // Structured content
                if (/\d+[%\/]|\d+\.\d+/.test(content)) score += 15; // Contains metrics

                // Uniqueness factor
                const fingerprint = this.generateFingerprint(content);
                if (fingerprint && !this.contentFingerprints.has(fingerprint.hash)) {
                    score += 20; // Unique content
                }

                // Recency factor
                const age = metadata.timestamp ? Date.now() - metadata.timestamp : 0;
                if (age < 3600000) score += 10; // Less than 1 hour old
                if (age < 1800000) score += 10; // Less than 30 minutes old

                // Determine priority
                if (score >= 70) return this.storagePolicies.highValue;
                if (score >= 40) return this.storagePolicies.mediumValue;
                return this.storagePolicies.lowValue;
            },

            // Light compression (remove redundancy)
            lightCompress: function(content) {
                let compressed = content;

                // Remove excessive whitespace
                compressed = compressed.replace(/\n{3,}/g, '\n\n');
                compressed = compressed.replace(/ {2,}/g, ' ');

                // Remove redundant phrases (simple approach)
                const redundancies = [
                    ['the the', 'the'],
                    ['and and', 'and'],
                    ['or or', 'or']
                ];

                redundancies.forEach(([pattern, replacement]) => {
                    compressed = compressed.replace(new RegExp(pattern, 'gi'), replacement);
                });

                return compressed;
            },

            // Heavy compression (significant reduction)
            heavyCompress: function(content) {
                let compressed = this.lightCompress(content);

                // Extract key sentences
                const sentences = compressed.split(/[.!?]+/).filter(s => s.trim().length > 10);
                const keySentences = sentences.filter(sentence => {
                    const words = sentence.toLowerCase().split(/\s+/);
                    // Keep sentences with metrics, structure, or key terms
                    return /\d/.test(sentence) ||
                           words.some(word => ['analysis', 'finding', 'metric', 'system', 'performance'].includes(word));
                });

                if (keySentences.length > 0) {
                    compressed = keySentences.join('. ') + '.';
                }

                // Limit length
                if (compressed.length > 500) {
                    compressed = compressed.substring(0, 500) + '...';
                }

                return compressed;
            },

            // Memory defragmentation
            defragmentMemory: function(memoryObject) {
                const defragmented = {
                    ...memoryObject,
                    members: {}
                };

                // Process each member
                Object.entries(memoryObject.members).forEach(([memberName, memberData]) => {
                    const defragmentedMember = {
                        ...memberData,
                        reports: []
                    };

                    // Remove duplicates and optimize reports
                    const seenContent = new Set();
                    const uniqueReports = [];

                    memberData.reports.forEach(report => {
                        const contentKey = this.generateFingerprint(report.analysis)?.hash;
                        if (contentKey && !seenContent.has(contentKey)) {
                            seenContent.add(contentKey);
                            uniqueReports.push({
                                ...report,
                                analysis: this.adaptiveCompress(report.analysis, {
                                    timestamp: new Date(report.timestamp).getTime(),
                                    source: memberName
                                })
                            });
                        }
                    });

                    defragmentedMember.reports = uniqueReports.slice(-25); // Keep last 25
                    defragmented.members[memberName] = defragmentedMember;
                });

                return defragmented;
            },

            // Analyze storage efficiency
            analyzeStorageEfficiency: function() {
                const memoryData = localStorage.getItem('djinn_council_complete_memory');
                if (!memoryData) return;

                try {
                    const memory = JSON.parse(memoryData);
                    const originalSize = JSON.stringify(memory).length;

                    // Calculate potential savings
                    const defragmented = this.defragmentMemory(memory);
                    const optimizedSize = JSON.stringify(defragmented).length;

                    const savings = originalSize - optimizedSize;
                    const ratio = optimizedSize / originalSize;

                    this.analytics.deduplicationSavings = savings;
                    this.analytics.compressionRatio = ratio;

                    console.log(`üß† Memory Analysis: ${originalSize} ‚Üí ${optimizedSize} bytes (${(ratio * 100).toFixed(1)}% efficiency)`);

                    if (savings > 1000) {
                        this.analytics.optimizationOpportunities.push({
                            type: 'defragmentation',
                            savings: savings,
                            description: `Defragmentation could save ${savings} bytes`
                        });
                    }

                } catch (error) {
                    console.warn('Memory analysis failed:', error);
                }
            },

            // Load existing fingerprints for deduplication
            loadExistingFingerprints: function() {
                const memoryData = localStorage.getItem('djinn_council_complete_memory');
                if (!memoryData) return;

                try {
                    const memory = JSON.parse(memoryData);
                    Object.values(memory.members).forEach(member => {
                        member.reports.forEach(report => {
                            const fingerprint = this.generateFingerprint(report.analysis);
                            if (fingerprint) {
                                this.contentFingerprints.set(fingerprint.hash, {
                                    timestamp: new Date(report.timestamp).getTime(),
                                    source: member.specialization,
                                    content: report.analysis
                                });
                            }
                        });
                    });

                    console.log(`üß† Loaded ${this.contentFingerprints.size} content fingerprints for deduplication`);
                } catch (error) {
                    console.warn('Failed to load fingerprints:', error);
                }
            },

            // Schedule maintenance tasks
            scheduleMaintenanceTasks: function() {
                // Defragment memory every 30 minutes
                setInterval(() => {
                    this.performMaintenance();
                }, 30 * 60 * 1000);

                // Analyze efficiency every 15 minutes
                setInterval(() => {
                    this.analyzeStorageEfficiency();
                }, 15 * 60 * 1000);
            },

            // Perform maintenance tasks
            performMaintenance: function() {
                console.log('üß† Performing memory maintenance...');

                const memoryData = localStorage.getItem('djinn_council_complete_memory');
                if (!memoryData) return;

                try {
                    const memory = JSON.parse(memoryData);
                    const optimized = this.defragmentMemory(memory);

                    localStorage.setItem('djinn_council_complete_memory', JSON.stringify(optimized));
                    console.log('‚úÖ Memory maintenance completed');
                } catch (error) {
                    console.warn('Memory maintenance failed:', error);
                }
            },

            // Get optimization metrics
            getOptimizationMetrics: function() {
                return {
                    totalFingerprints: this.contentFingerprints.size,
                    deduplicationSavings: this.analytics.deduplicationSavings,
                    compressionRatio: this.analytics.compressionRatio,
                    optimizationOpportunities: this.analytics.optimizationOpportunities.length,
                    memoryEfficiency: ((1 - this.analytics.compressionRatio) * 100).toFixed(1) + '%'
                };
            }
        };

        // ========================================
        // ENHANCED MEMORY MANAGEMENT FUNCTIONS
        // ========================================

        // Enhanced store function with intelligent optimization
        function storeCouncilMemberReportOptimized(memberName, reportData) {
            const member = djinnCouncilMemory.members[memberName];

            // Generate optimized analysis content
            const originalAnalysis = reportData.analysis || '';
            const optimizedAnalysis = advancedMemoryOrchestrator.adaptiveCompress(originalAnalysis, {
                timestamp: Date.now(),
                source: memberName
            });

            // Check for duplicates
            const existingReports = member.reports;
            let deduplicatedAnalysis = optimizedAnalysis;

            if (existingReports.length > 0) {
                const lastReport = existingReports[existingReports.length - 1];
                deduplicatedAnalysis = advancedMemoryOrchestrator.deduplicateContent(
                    optimizedAnalysis,
                    lastReport.analysis
                );
            }

            // Add new report
            const newReport = {
                reportId: member.reports.length + 1,
                timestamp: new Date().toISOString(),
                metrics: reportData.metrics || {},
                analysis: deduplicatedAnalysis,
                canvasDataAnalyzed: reportData.canvasData || '',
                buildingOn: member.reports.length > 0 ? `Reports 1-${member.reports.length}` : 'Initial analysis'
            };

            member.reports.push(newReport);

            // Intelligent retention management
            const retentionPolicy = advancedMemoryOrchestrator.assessContentValue(deduplicatedAnalysis);
            const maxRetention = retentionPolicy.retention;

            if (member.reports.length > maxRetention) {
                // Remove oldest reports beyond retention limit
                const excess = member.reports.length - maxRetention;
                member.reports = member.reports.slice(excess);
            }

            // Save with optimization
            saveMemoryOptimized(djinnCouncilMemory);
        }

        // Optimized memory saving with defragmentation
        function saveMemoryOptimized(memoryObject) {
            try {
                // Apply defragmentation
                const defragmented = advancedMemoryOrchestrator.defragmentMemory(memoryObject);

                // Save optimized memory
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(defragmented));

                // Update analytics
                const originalSize = JSON.stringify(memoryObject).length;
                const optimizedSize = JSON.stringify(defragmented).length;
                advancedMemoryOrchestrator.analytics.totalStored = optimizedSize;

                console.log(`üíæ Memory optimized: ${originalSize} ‚Üí ${optimizedSize} bytes (${((originalSize - optimizedSize) / originalSize * 100).toFixed(1)}% savings)`);

            } catch (error) {
                console.warn('Optimized memory save failed, using fallback:', error);

                // Fallback to original compression methods
                try {
                    const compressedMemory = compressMemoryForStorage(memoryObject);
                    localStorage.setItem('djinn_council_complete_memory', JSON.stringify(compressedMemory));
                } catch (fallbackError) {
                    console.warn('Fallback compression failed:', fallbackError);
                    const ultraCompressed = ultraCompressMemory(memoryObject);
                    localStorage.setItem('djinn_council_complete_memory', JSON.stringify(ultraCompressed));
                }
            }
        }

        // ========================================
        // CROSS-SYSTEM CORRELATION ENGINE
        // ========================================

        // Advanced correlation analysis across AI systems
        const crossSystemCorrelationEngine = {
            // Correlation analysis data
            correlationMatrix: new Map(),
            consensusPatterns: [],
            conflictPatterns: [],
            interSystemDependencies: new Map(),
            correlationHistory: [],

            // Analysis metrics
            metrics: {
                consensusStrength: 0,
                conflictCount: 0,
                correlationDiversity: 0,
                systemHarmony: 0
            },

            // Initialize correlation engine
            initialize: function() {
                console.log('üîó Initializing Cross-System Correlation Engine');
                this.buildInitialCorrelationMatrix();
                this.scheduleCorrelationAnalysis();
            },

            // Build initial correlation matrix from existing data
            buildInitialCorrelationMatrix: function() {
                const aiSystems = ['narra', 'nazar', 'whale', 'djinn', 'watchtower'];
                const councilMembers = ['pattern', 'wisdom', 'paradox', 'boundaries', 'memory'];

                // Initialize correlation matrix
                aiSystems.forEach(system => {
                    this.correlationMatrix.set(system, new Map());
                    councilMembers.forEach(member => {
                        this.correlationMatrix.get(system).set(member, {
                            correlationStrength: 0,
                            interactionCount: 0,
                            consensusRate: 0,
                            lastInteraction: null,
                            sharedInsights: [],
                            complementaryPatterns: []
                        });
                    });
                });

                console.log('üîó Correlation matrix initialized for', aiSystems.length, 'AI systems and', councilMembers.length, 'council members');
            },

            // Analyze correlations between AI systems and council members
            analyzeCorrelations: function(systemData, councilData) {
                const correlations = {
                    timestamp: Date.now(),
                    systemConsensus: this.calculateSystemConsensus(systemData),
                    councilConsensus: this.calculateCouncilConsensus(councilData),
                    crossCorrelations: this.calculateCrossCorrelations(systemData, councilData),
                    emergingPatterns: this.identifyEmergingPatterns(systemData, councilData),
                    conflictAnalysis: this.analyzeConflicts(systemData, councilData)
                };

                // Update correlation history
                this.correlationHistory.push(correlations);
                if (this.correlationHistory.length > 100) {
                    this.correlationHistory.shift(); // Keep last 100 analyses
                }

                // Update metrics
                this.updateCorrelationMetrics(correlations);

                return correlations;
            },

            // Calculate consensus across AI systems
            calculateSystemConsensus: function(systemData) {
                if (!systemData || Object.keys(systemData).length === 0) return 0;

                const systems = Object.keys(systemData);
                let totalConsensus = 0;
                let comparisonCount = 0;

                // Compare each system pair
                for (let i = 0; i < systems.length; i++) {
                    for (let j = i + 1; j < systems.length; j++) {
                        const system1 = systems[i];
                        const system2 = systems[j];

                        const consensus = this.calculatePairConsensus(
                            systemData[system1],
                            systemData[system2]
                        );

                        totalConsensus += consensus;
                        comparisonCount++;
                    }
                }

                return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
            },

            // Calculate consensus across council members
            calculateCouncilConsensus: function(councilData) {
                if (!councilData || Object.keys(councilData).length === 0) return 0;

                const members = Object.keys(councilData);
                let totalConsensus = 0;
                let comparisonCount = 0;

                // Compare each member pair
                for (let i = 0; i < members.length; i++) {
                    for (let j = i + 1; j < members.length; j++) {
                        const member1 = members[i];
                        const member2 = members[j];

                        const consensus = this.calculatePairConsensus(
                            councilData[member1],
                            councilData[member2]
                        );

                        totalConsensus += consensus;
                        comparisonCount++;
                    }
                }

                return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
            },

            // Calculate consensus between two entities
            calculatePairConsensus: function(entity1, entity2) {
                if (!entity1 || !entity2) return 0;

                // Simple consensus calculation based on content similarity
                const content1 = this.extractKeyContent(entity1);
                const content2 = this.extractKeyContent(entity2);

                if (!content1 || !content2) return 0;

                // Calculate similarity score
                return this.calculateContentSimilarity(content1, content2);
            },

            // Extract key content for comparison
            extractKeyContent: function(entity) {
                if (typeof entity === 'string') {
                    return entity.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 2);
                }

                if (entity.analysis) {
                    return entity.analysis.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 2);
                }

                if (entity.content) {
                    return entity.content.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 2);
                }

                return null;
            },

            // Calculate content similarity
            calculateContentSimilarity: function(content1, content2) {
                if (!content1 || !content2) return 0;

                const set1 = new Set(content1);
                const set2 = new Set(content2);

                const intersection = new Set([...set1].filter(x => set2.has(x)));
                const union = new Set([...set1, ...set2]);

                return intersection.size / union.size;
            },

            // Calculate cross-correlations between systems and council
            calculateCrossCorrelations: function(systemData, councilData) {
                const correlations = [];

                Object.entries(systemData).forEach(([systemName, systemInfo]) => {
                    Object.entries(councilData).forEach(([memberName, memberInfo]) => {
                        const correlation = this.calculatePairConsensus(systemInfo, memberInfo);

                        correlations.push({
                            system: systemName,
                            member: memberName,
                            correlation: correlation,
                            strength: this.categorizeCorrelationStrength(correlation)
                        });

                        // Update correlation matrix
                        if (this.correlationMatrix.has(systemName)) {
                            const systemCorrelations = this.correlationMatrix.get(systemName);
                            if (systemCorrelations.has(memberName)) {
                                const existing = systemCorrelations.get(memberName);
                                existing.correlationStrength = (existing.correlationStrength + correlation) / 2;
                                existing.interactionCount++;
                                existing.lastInteraction = Date.now();
                            }
                        }
                    });
                });

                return correlations.sort((a, b) => b.correlation - a.correlation);
            },

            // Categorize correlation strength
            categorizeCorrelationStrength: function(correlation) {
                if (correlation >= 0.8) return 'very_strong';
                if (correlation >= 0.6) return 'strong';
                if (correlation >= 0.4) return 'moderate';
                if (correlation >= 0.2) return 'weak';
                return 'very_weak';
            },

            // Identify emerging patterns
            identifyEmergingPatterns: function(systemData, councilData) {
                const patterns = [];

                // Look for consensus patterns
                const systemConsensus = this.calculateSystemConsensus(systemData);
                const councilConsensus = this.calculateCouncilConsensus(councilData);

                if (systemConsensus > 0.7 && councilConsensus > 0.7) {
                    patterns.push({
                        type: 'high_consensus',
                        description: 'High consensus between AI systems and council members',
                        confidence: Math.min(systemConsensus, councilConsensus)
                    });
                }

                // Look for complementary patterns
                const crossCorrelations = this.calculateCrossCorrelations(systemData, councilData);
                const strongCorrelations = crossCorrelations.filter(c => c.correlation > 0.6);

                if (strongCorrelations.length > 0) {
                    patterns.push({
                        type: 'strong_complementarity',
                        description: `${strongCorrelations.length} strong correlations identified`,
                        pairs: strongCorrelations.slice(0, 3),
                        confidence: strongCorrelations[0].correlation
                    });
                }

                // Look for specialization patterns
                const specializationPatterns = this.identifySpecializationPatterns(systemData, councilData);
                if (specializationPatterns.length > 0) {
                    patterns.push(...specializationPatterns);
                }

                return patterns;
            },

            // Identify specialization patterns
            identifySpecializationPatterns: function(systemData, councilData) {
                const patterns = [];

                // Define specialization mappings
                const systemSpecializations = {
                    narra: ['monitoring', 'consistency', 'stability'],
                    nazar: ['analysis', 'synthesis', 'content'],
                    whale: ['data', 'retrieval', 'processing'],
                    djinn: ['conversation', 'interaction', 'response'],
                    watchtower: ['integrity', 'security', 'oversight']
                };

                const memberSpecializations = {
                    pattern: ['patterns', 'governance', 'structure'],
                    wisdom: ['synthesis', 'knowledge', 'growth'],
                    paradox: ['innovation', 'creativity', 'resolution'],
                    boundaries: ['autonomy', 'sovereignty', 'integrity'],
                    memory: ['storage', 'continuity', 'persistence']
                };

                // Find complementary specializations
                Object.entries(systemSpecializations).forEach(([system, sysSpecs]) => {
                    Object.entries(memberSpecializations).forEach(([member, memSpecs]) => {
                        const overlap = sysSpecs.filter(spec => memSpecs.includes(spec)).length;
                        const complementarity = overlap / Math.max(sysSpecs.length, memSpecs.length);

                        if (complementarity > 0.5) {
                            patterns.push({
                                type: 'specialization_complementarity',
                                description: `${system} and ${member} show complementary specializations`,
                                overlap: overlap,
                                confidence: complementarity
                            });
                        }
                    });
                });

                return patterns;
            },

            // Analyze conflicts between systems
            analyzeConflicts: function(systemData, councilData) {
                const conflicts = [];

                // Look for contradictory conclusions
                const conclusions = this.extractConclusions(systemData, councilData);
                const contradictions = this.findContradictions(conclusions);

                if (contradictions.length > 0) {
                    conflicts.push({
                        type: 'conclusion_conflicts',
                        count: contradictions.length,
                        examples: contradictions.slice(0, 3),
                        severity: this.assessConflictSeverity(contradictions)
                    });
                }

                // Look for resource competition
                const resourceConflicts = this.identifyResourceConflicts(systemData);
                if (resourceConflicts.length > 0) {
                    conflicts.push({
                        type: 'resource_competition',
                        conflicts: resourceConflicts,
                        severity: 'moderate'
                    });
                }

                return conflicts;
            },

            // Extract conclusions from data
            extractConclusions: function(systemData, councilData) {
                const conclusions = [];

                // Extract from system data
                Object.entries(systemData).forEach(([system, data]) => {
                    if (data && typeof data === 'object') {
                        const content = this.extractKeyContent(data);
                        if (content) {
                            conclusions.push({
                                source: system,
                                type: 'system',
                                conclusions: this.extractConclusionStatements(content)
                            });
                        }
                    }
                });

                // Extract from council data
                Object.entries(councilData).forEach(([member, data]) => {
                    if (data && typeof data === 'object') {
                        const content = this.extractKeyContent(data);
                        if (content) {
                            conclusions.push({
                                source: member,
                                type: 'council',
                                conclusions: this.extractConclusionStatements(content)
                            });
                        }
                    }
                });

                return conclusions;
            },

            // Extract conclusion statements
            extractConclusionStatements: function(content) {
                const conclusionWords = ['conclusion', 'result', 'finding', 'therefore', 'thus', 'hence'];
                const conclusions = [];

                content.forEach((word, index) => {
                    if (conclusionWords.includes(word.toLowerCase())) {
                        // Extract surrounding context
                        const start = Math.max(0, index - 5);
                        const end = Math.min(content.length, index + 10);
                        const context = content.slice(start, end).join(' ');
                        conclusions.push(context);
                    }
                });

                return conclusions;
            },

            // Find contradictions in conclusions
            findContradictions: function(conclusions) {
                const contradictions = [];

                for (let i = 0; i < conclusions.length; i++) {
                    for (let j = i + 1; j < conclusions.length; j++) {
                        const conclusion1 = conclusions[i];
                        const conclusion2 = conclusions[j];

                        if (this.areContradictory(conclusion1.conclusions, conclusion2.conclusions)) {
                            contradictions.push({
                                sources: [conclusion1.source, conclusion2.source],
                                contradiction: this.describeContradiction(conclusion1, conclusion2)
                            });
                        }
                    }
                }

                return contradictions;
            },

            // Check if conclusions are contradictory
            areContradictory: function(conclusions1, conclusions2) {
                const contradictionPairs = [
                    ['increase', 'decrease'],
                    ['improve', 'worsen'],
                    ['stable', 'unstable'],
                    ['consistent', 'inconsistent'],
                    ['positive', 'negative']
                ];

                const text1 = conclusions1.join(' ').toLowerCase();
                const text2 = conclusions2.join(' ').toLowerCase();

                return contradictionPairs.some(([word1, word2]) => {
                    return (text1.includes(word1) && text2.includes(word2)) ||
                           (text1.includes(word2) && text2.includes(word1));
                });
            },

            // Describe the contradiction
            describeContradiction: function(conclusion1, conclusion2) {
                return `${conclusion1.source} vs ${conclusion2.source}: Conflicting conclusions detected`;
            },

            // Identify resource conflicts
            identifyResourceConflicts: function(systemData) {
                // This would analyze resource usage patterns
                // For now, return empty array as we don't have resource usage data
                return [];
            },

            // Assess conflict severity
            assessConflictSeverity: function(conflicts) {
                if (conflicts.length === 0) return 'none';
                if (conflicts.length <= 2) return 'low';
                if (conflicts.length <= 5) return 'moderate';
                return 'high';
            },

            // Update correlation metrics
            updateCorrelationMetrics: function(correlations) {
                this.metrics.consensusStrength = (correlations.systemConsensus + correlations.councilConsensus) / 2;
                this.metrics.conflictCount = correlations.conflictAnalysis.reduce((sum, conflict) => sum + conflict.count, 0);
                this.metrics.correlationDiversity = correlations.crossCorrelations.length;
                this.metrics.systemHarmony = this.calculateSystemHarmony(correlations);
            },

            // Calculate system harmony
            calculateSystemHarmony: function(correlations) {
                const consensus = correlations.systemConsensus;
                const conflicts = correlations.conflictAnalysis.reduce((sum, conflict) => sum + conflict.count, 0);
                const patterns = correlations.emergingPatterns.length;

                // Harmony = consensus - conflicts + patterns
                return Math.max(0, Math.min(100, (consensus * 100) - (conflicts * 10) + (patterns * 5)));
            },

            // Schedule correlation analysis
            scheduleCorrelationAnalysis: function() {
                // Analyze correlations every 5 minutes
                setInterval(() => {
                    this.performCorrelationAnalysis();
                }, 5 * 60 * 1000);
            },

            // Perform correlation analysis
            performCorrelationAnalysis: function() {
                try {
                    // Get current system and council data
                    const systemData = this.getCurrentSystemData();
                    const councilData = this.getCurrentCouncilData();

                    if (Object.keys(systemData).length > 0 && Object.keys(councilData).length > 0) {
                        const correlations = this.analyzeCorrelations(systemData, councilData);
                        console.log('üîó Correlation analysis completed:', {
                            consensus: (correlations.systemConsensus * 100).toFixed(1) + '%',
                            patterns: correlations.emergingPatterns.length,
                            conflicts: correlations.conflictAnalysis.length
                        });
                    }
                } catch (error) {
                    console.warn('Correlation analysis failed:', error);
                }
            },

            // Get current system data
            getCurrentSystemData: function() {
                const aiMemory = localStorage.getItem('ai_memory_state');
                if (!aiMemory) return {};

                try {
                    const memory = JSON.parse(aiMemory);
                    return memory;
                } catch (error) {
                    return {};
                }
            },

            // Get current council data
            getCurrentCouncilData: function() {
                const councilMemory = localStorage.getItem('djinn_council_complete_memory');
                if (!councilMemory) return {};

                try {
                    const memory = JSON.parse(councilMemory);
                    const latestReports = {};

                    Object.entries(memory.members).forEach(([member, data]) => {
                        if (data.reports && data.reports.length > 0) {
                            latestReports[member] = data.reports[data.reports.length - 1];
                        }
                    });

                    return latestReports;
                } catch (error) {
                    return {};
                }
            },

            // Get correlation insights
            getCorrelationInsights: function() {
                const latest = this.correlationHistory[this.correlationHistory.length - 1];
                if (!latest) return null;

                return {
                    consensusStrength: (this.metrics.consensusStrength * 100).toFixed(1) + '%',
                    systemHarmony: this.metrics.systemHarmony.toFixed(1) + '%',
                    emergingPatterns: latest.emergingPatterns.length,
                    activeConflicts: this.metrics.conflictCount,
                    topCorrelations: latest.crossCorrelations.slice(0, 3),
                    lastAnalysis: new Date(latest.timestamp).toLocaleTimeString()
                };
            }
        };

        // ========================================
        // CORRELATIVE ANALYSIS FRAMEWORK
        // ========================================

        // Advanced correlative analysis framework for synthesis report integration
        const correlativeAnalysisFramework = {
            // Synthesis report integration
            synthesisReports: [],
            analysisCycles: [],
            deepInsights: new Map(),

            // Analysis components
            components: {
                canvasEvolutionAnalyzer: null,
                aiSystemCorrelator: null,
                synthesisIntegrator: null,
                predictiveCorrelator: null
            },

            // Analysis metrics
            metrics: {
                synthesisQuality: 0,
                correlationDepth: 0,
                insightGeneration: 0,
                predictiveAccuracy: 0
            },

            // Initialize correlative analysis framework
            initialize: function() {
                console.log('üîç Initializing Correlative Analysis Framework');
                this.buildAnalysisComponents();
                this.setupSynthesisIntegration();
                this.scheduleDeepAnalysis();
            },

            // Build analysis components
            buildAnalysisComponents: function() {
                // Canvas evolution analyzer
                this.components.canvasEvolutionAnalyzer = {
                    analyzeEvolution: function(canvasData, synthesisReport) {
                        const evolution = {
                            contentGrowth: this.calculateContentGrowth(canvasData),
                            patternEmergence: this.identifyPatternEmergence(canvasData),
                            stabilityMetrics: this.assessStability(canvasData),
                            synthesisAlignment: this.measureSynthesisAlignment(canvasData, synthesisReport)
                        };
                        return evolution;
                    },

                    calculateContentGrowth: function(canvasData) {
                        if (!canvasData.history || canvasData.history.length < 2) return 0;

                        const recent = canvasData.history.slice(-10);
                        const totalGrowth = recent.reduce((sum, snapshot, index) => {
                            if (index === 0) return 0;
                            return sum + (snapshot.metrics.characters - recent[index-1].metrics.characters);
                        }, 0);

                        return totalGrowth / recent.length;
                    },

                    identifyPatternEmergence: function(canvasData) {
                        // Analyze patterns in canvas evolution
                        const patterns = [];
                        if (canvasData.history && canvasData.history.length > 5) {
                            const recent = canvasData.history.slice(-5);

                            // Look for repeating patterns
                            const changes = recent.map((snapshot, index) => {
                                if (index === 0) return 0;
                                return snapshot.metrics.characters - recent[index-1].metrics.characters;
                            });

                            // Detect trends
                            if (changes.every(change => change > 0)) {
                                patterns.push('consistent_growth');
                            } else if (changes.every(change => change < 0)) {
                                patterns.push('consistent_decline');
                            } else if (Math.abs(changes.reduce((a, b) => a + b, 0) / changes.length) < 50) {
                                patterns.push('stable_evolution');
                            }
                        }

                        return patterns;
                    },

                    assessStability: function(canvasData) {
                        if (!canvasData.history || canvasData.history.length < 3) {
                            return { stability: 0, volatility: 0 };
                        }

                        const changes = canvasData.history.slice(-10).map((snapshot, index, arr) => {
                            if (index === 0) return 0;
                            return snapshot.metrics.characters - arr[index-1].metrics.characters;
                        });

                        const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
                        const variance = changes.reduce((sum, change) => sum + Math.pow(change - avgChange, 2), 0) / changes.length;
                        const volatility = Math.sqrt(variance);

                        return {
                            stability: Math.max(0, 100 - (volatility / 10)),
                            volatility: volatility
                        };
                    },

                    measureSynthesisAlignment: function(canvasData, synthesisReport) {
                        if (!synthesisReport) return 0;

                        // Measure how well synthesis captures canvas evolution
                        const canvasTrends = this.identifyPatternEmergence(canvasData);
                        const synthesisContent = synthesisReport.toLowerCase();

                        let alignment = 0;
                        canvasTrends.forEach(trend => {
                            if (synthesisContent.includes(trend.replace('_', ' '))) {
                                alignment += 25;
                            }
                        });

                        return Math.min(100, alignment);
                    }
                };

                // AI system correlator
                this.components.aiSystemCorrelator = {
                    correlateAISystems: function(aiData, synthesisReport) {
                        const correlations = {
                            systemConsensus: this.calculateSystemConsensus(aiData),
                            synthesisAgreement: this.measureSynthesisAgreement(aiData, synthesisReport),
                            performancePatterns: this.analyzePerformancePatterns(aiData),
                            collaborativeEfficiency: this.assessCollaborativeEfficiency(aiData)
                        };
                        return correlations;
                    },

                    calculateSystemConsensus: function(aiData) {
                        if (!aiData || Object.keys(aiData).length < 2) return 0;

                        const systems = Object.keys(aiData);
                        let totalConsensus = 0;
                        let comparisonCount = 0;

                        for (let i = 0; i < systems.length; i++) {
                            for (let j = i + 1; j < systems.length; j++) {
                                const system1 = aiData[systems[i]];
                                const system2 = aiData[systems[j]];

                                const consensus = this.calculatePairConsensus(system1, system2);
                                totalConsensus += consensus;
                                comparisonCount++;
                            }
                        }

                        return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
                    },

                    calculatePairConsensus: function(system1, system2) {
                        if (!system1 || !system2) return 0;

                        // Compare analysis content
                        const content1 = this.extractAnalysisContent(system1);
                        const content2 = this.extractAnalysisContent(system2);

                        return this.calculateContentSimilarity(content1, content2);
                    },

                    extractAnalysisContent: function(system) {
                        if (typeof system === 'string') return system.toLowerCase();
                        if (system.analysis) return system.analysis.toLowerCase();
                        if (system.content) return system.content.toLowerCase();
                        return '';
                    },

                    calculateContentSimilarity: function(content1, content2) {
                        if (!content1 || !content2) return 0;

                        const words1 = content1.split(/\s+/).filter(w => w.length > 2);
                        const words2 = content2.split(/\s+/).filter(w => w.length > 2);

                        const set1 = new Set(words1);
                        const set2 = new Set(words2);

                        const intersection = new Set([...set1].filter(x => set2.has(x)));
                        const union = new Set([...set1, ...set2]);

                        return intersection.size / union.size;
                    },

                    measureSynthesisAgreement: function(aiData, synthesisReport) {
                        if (!synthesisReport) return 0;

                        let totalAgreement = 0;
                        let systemCount = 0;

                        Object.values(aiData).forEach(system => {
                            const systemContent = this.extractAnalysisContent(system);
                            const agreement = this.calculateContentSimilarity(systemContent, synthesisReport.toLowerCase());
                            totalAgreement += agreement;
                            systemCount++;
                        });

                        return systemCount > 0 ? (totalAgreement / systemCount) * 100 : 0;
                    },

                    analyzePerformancePatterns: function(aiData) {
                        const patterns = [];

                        Object.entries(aiData).forEach(([systemName, systemData]) => {
                            if (systemData && typeof systemData === 'object') {
                                // Analyze response patterns
                                if (systemData.consistency) {
                                    patterns.push({
                                        system: systemName,
                                        pattern: 'consistency_focused',
                                        strength: systemData.consistency
                                    });
                                }

                                if (systemData.creativity) {
                                    patterns.push({
                                        system: systemName,
                                        pattern: 'creativity_focused',
                                        strength: systemData.creativity
                                    });
                                }
                            }
                        });

                        return patterns;
                    },

                    assessCollaborativeEfficiency: function(aiData) {
                        const consensus = this.calculateSystemConsensus(aiData);
                        const systemCount = Object.keys(aiData).length;

                        // Efficiency increases with consensus and system count
                        return Math.min(100, (consensus * 100) + (systemCount * 10));
                    }
                };

                // Synthesis integrator
                this.components.synthesisIntegrator = {
                    integrateSynthesisReport: function(synthesisReport, canvasData, aiData) {
                        const integration = {
                            synthesisQuality: this.assessSynthesisQuality(synthesisReport),
                            canvasIntegration: this.measureCanvasIntegration(synthesisReport, canvasData),
                            aiIntegration: this.measureAIIntegration(synthesisReport, aiData),
                            comprehensiveCoverage: this.assessComprehensiveCoverage(synthesisReport, canvasData, aiData)
                        };
                        return integration;
                    },

                    assessSynthesisQuality: function(synthesisReport) {
                        if (!synthesisReport) return 0;

                        let quality = 50; // Base quality

                        // Length assessment
                        if (synthesisReport.length > 1000) quality += 20;
                        else if (synthesisReport.length > 500) quality += 10;

                        // Content richness
                        const sentences = synthesisReport.split(/[.!?]+/).length;
                        if (sentences > 10) quality += 15;

                        // Key terms presence
                        const keyTerms = ['analysis', 'evolution', 'correlation', 'pattern', 'synthesis'];
                        const foundTerms = keyTerms.filter(term => synthesisReport.toLowerCase().includes(term)).length;
                        quality += foundTerms * 3;

                        return Math.min(100, quality);
                    },

                    measureCanvasIntegration: function(synthesisReport, canvasData) {
                        if (!synthesisReport || !canvasData) return 0;

                        let integration = 0;
                        const report = synthesisReport.toLowerCase();

                        // Check for canvas-specific references
                        if (report.includes('canvas') || report.includes('content')) integration += 30;
                        if (report.includes('evolution') || report.includes('change')) integration += 25;
                        if (report.includes('pattern') || report.includes('trend')) integration += 20;

                        // Check for metrics integration
                        if (canvasData.metrics) {
                            if (report.includes('character') || report.includes('length')) integration += 15;
                            if (report.includes('stability') || report.includes('volatility')) integration += 10;
                        }

                        return Math.min(100, integration);
                    },

                    measureAIIntegration: function(synthesisReport, aiData) {
                        if (!synthesisReport || !aiData) return 0;

                        let integration = 0;
                        const report = synthesisReport.toLowerCase();

                        // Check for AI system references
                        const aiSystems = ['narra', 'nazar', 'whale', 'djinn', 'watchtower'];
                        const mentionedSystems = aiSystems.filter(system => report.includes(system)).length;
                        integration += mentionedSystems * 10;

                        // Check for analysis integration
                        if (report.includes('consensus') || report.includes('agreement')) integration += 20;
                        if (report.includes('correlation') || report.includes('collaboration')) integration += 15;

                        return Math.min(100, integration);
                    },

                    assessComprehensiveCoverage: function(synthesisReport, canvasData, aiData) {
                        const canvasCoverage = this.measureCanvasIntegration(synthesisReport, canvasData);
                        const aiCoverage = this.measureAIIntegration(synthesisReport, aiData);

                        // Overall coverage is weighted average
                        return (canvasCoverage * 0.4) + (aiCoverage * 0.6);
                    }
                };

                // Predictive correlator
                this.components.predictiveCorrelator = {
                    correlatePredictions: function(predictions, synthesisReport, canvasData, aiData) {
                        const correlations = {
                            predictiveAccuracy: this.assessPredictiveAccuracy(predictions, canvasData, aiData),
                            synthesisPredictiveAlignment: this.measureSynthesisPredictiveAlignment(predictions, synthesisReport),
                            futureTrendCorrelation: this.analyzeFutureTrendCorrelation(predictions, canvasData),
                            riskAssessment: this.performRiskAssessment(predictions, aiData)
                        };
                        return correlations;
                    },

                    assessPredictiveAccuracy: function(predictions, canvasData, aiData) {
                        if (!predictions) return 0;

                        let accuracy = 0;

                        // Check canvas predictions against actual data
                        if (predictions.canvas && canvasData) {
                            const predictedTrend = predictions.canvas.prediction;
                            const actualTrend = this.determineActualTrend(canvasData);

                            if (predictedTrend === actualTrend) accuracy += 40;
                            else if (this.areTrendsCompatible(predictedTrend, actualTrend)) accuracy += 20;
                        }

                        // Check AI predictions against actual data
                        if (predictions.aiSystems && aiData) {
                            const predictedConsensus = predictions.aiSystems.prediction;
                            const actualConsensus = this.calculateActualConsensus(aiData);

                            if (Math.abs(predictedConsensus - actualConsensus) < 0.2) accuracy += 30;
                        }

                        return Math.min(100, accuracy);
                    },

                    determineActualTrend: function(canvasData) {
                        if (!canvasData.history || canvasData.history.length < 3) return 'unknown';

                        const recent = canvasData.history.slice(-3);
                        const changes = recent.map((snapshot, index) => {
                            if (index === 0) return 0;
                            return snapshot.metrics.characters - recent[index-1].metrics.characters;
                        });

                        const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;

                        if (avgChange > 50) return 'expanding';
                        if (avgChange < -50) return 'contracting';
                        return 'stable';
                    },

                    areTrendsCompatible: function(predicted, actual) {
                        const compatiblePairs = [
                            ['expanding', 'stable'],
                            ['contracting', 'stable'],
                            ['stable', 'expanding'],
                            ['stable', 'contracting']
                        ];

                        return compatiblePairs.some(([a, b]) => (predicted === a && actual === b) || (predicted === b && actual === a));
                    },

                    calculateActualConsensus: function(aiData) {
                        if (!aiData || Object.keys(aiData).length < 2) return 0;

                        // Simplified consensus calculation
                        const analyses = Object.values(aiData).map(system => this.extractAnalysisContent(system));
                        let totalConsensus = 0;
                        let comparisonCount = 0;

                        for (let i = 0; i < analyses.length; i++) {
                            for (let j = i + 1; j < analyses.length; j++) {
                                const similarity = this.calculateContentSimilarity(analyses[i], analyses[j]);
                                totalConsensus += similarity;
                                comparisonCount++;
                            }
                        }

                        return comparisonCount > 0 ? totalConsensus / comparisonCount : 0;
                    },

                    calculateContentSimilarity: function(content1, content2) {
                        if (!content1 || !content2) return 0;

                        const words1 = content1.split(/\s+/).filter(w => w.length > 2);
                        const words2 = content2.split(/\s+/).filter(w => w.length > 2);

                        const set1 = new Set(words1);
                        const set2 = new Set(words2);

                        const intersection = new Set([...set1].filter(x => set2.has(x)));
                        const union = new Set([...set1, ...set2]);

                        return intersection.size / union.size;
                    },

                    extractAnalysisContent: function(system) {
                        if (typeof system === 'string') return system.toLowerCase();
                        if (system.analysis) return system.analysis.toLowerCase();
                        if (system.content) return system.content.toLowerCase();
                        return '';
                    },

                    measureSynthesisPredictiveAlignment: function(predictions, synthesisReport) {
                        if (!predictions || !synthesisReport) return 0;

                        let alignment = 0;
                        const report = synthesisReport.toLowerCase();

                        // Check if synthesis report acknowledges predictions
                        if (report.includes('prediction') || report.includes('forecast')) alignment += 30;
                        if (report.includes('future') || report.includes('trend')) alignment += 20;

                        // Check for specific prediction references
                        if (predictions.canvas && report.includes('canvas')) alignment += 15;
                        if (predictions.aiSystems && report.includes('ai') || report.includes('system')) alignment += 15;

                        return Math.min(100, alignment);
                    },

                    analyzeFutureTrendCorrelation: function(predictions, canvasData) {
                        if (!predictions || !canvasData) return 0;

                        // Analyze how well predictions correlate with future canvas evolution
                        const predictedTrend = predictions.canvas ? predictions.canvas.prediction : 'unknown';
                        const stability = canvasData.stability || 0;

                        // Stable systems are easier to predict
                        if (predictedTrend === 'stable' && stability > 70) return 80;
                        if (predictedTrend === 'expanding' && stability < 50) return 60;
                        if (predictedTrend === 'contracting' && stability < 50) return 60;

                        return 40; // Default moderate correlation
                    },

                    performRiskAssessment: function(predictions, aiData) {
                        if (!predictions || !aiData) return { level: 'unknown', factors: [] };

                        const risks = [];
                        let riskLevel = 'low';

                        // Assess prediction confidence
                        if (predictions.canvas && predictions.canvas.confidence < 0.5) {
                            risks.push('Low canvas prediction confidence');
                            riskLevel = 'moderate';
                        }

                        if (predictions.aiSystems && predictions.aiSystems.confidence < 0.5) {
                            risks.push('Low AI system prediction confidence');
                            riskLevel = 'moderate';
                        }

                        // Assess system consensus
                        const consensus = this.calculateActualConsensus(aiData);
                        if (consensus < 0.3) {
                            risks.push('Low AI system consensus');
                            riskLevel = 'high';
                        }

                        return {
                            level: riskLevel,
                            factors: risks
                        };
                    }
                };

                console.log('üîç Analysis components initialized');
            },

            // Setup synthesis integration
            setupSynthesisIntegration: function() {
                // Listen for synthesis report generation
                window.addEventListener('storage', (event) => {
                    if (event.key === 'synthesis_report_generated') {
                        this.handleSynthesisReportGeneration();
                    }
                });

                // Check for existing synthesis reports
                this.checkExistingSynthesisReports();
            },

            // Handle synthesis report generation
            handleSynthesisReportGeneration: function() {
                console.log('üîç Synthesis report generation detected - initiating correlative analysis');

                // Get synthesis report
                const synthesisReport = localStorage.getItem('synthesis_report');
                if (!synthesisReport) return;

                // Get current data
                const canvasData = this.getCurrentCanvasData();
                const aiData = this.getCurrentAIData();
                const predictions = predictiveAnalyticsFramework ? predictiveAnalyticsFramework.getCurrentPredictions() : null;

                // Perform correlative analysis
                const analysis = this.performCorrelativeAnalysis(synthesisReport, canvasData, aiData, predictions);

                // Store analysis results
                this.storeAnalysisResults(analysis);

                // Update metrics
                this.updateAnalysisMetrics(analysis);

                console.log('üîç Correlative analysis completed:', {
                    synthesisQuality: analysis.synthesisQuality,
                    correlationDepth: analysis.correlationDepth,
                    insightsGenerated: analysis.insights.length
                });
            },

            // Perform correlative analysis
            performCorrelativeAnalysis: function(synthesisReport, canvasData, aiData, predictions) {
                const analysis = {
                    timestamp: Date.now(),
                    synthesisReport: synthesisReport,
                    components: {}
                };

                // Canvas evolution analysis
                if (canvasData) {
                    analysis.components.canvasEvolution = this.components.canvasEvolutionAnalyzer.analyzeEvolution(canvasData, synthesisReport);
                }

                // AI system correlation
                if (aiData) {
                    analysis.components.aiCorrelation = this.components.aiSystemCorrelator.correlateAISystems(aiData, synthesisReport);
                }

                // Synthesis integration
                analysis.components.synthesisIntegration = this.components.synthesisIntegrator.integrateSynthesisReport(synthesisReport, canvasData, aiData);

                // Predictive correlation
                if (predictions) {
                    analysis.components.predictiveCorrelation = this.components.predictiveCorrelator.correlatePredictions(predictions, synthesisReport, canvasData, aiData);
                }

                // Generate deep insights
                analysis.insights = this.generateDeepInsights(analysis);

                // Calculate overall metrics
                analysis.synthesisQuality = analysis.components.synthesisIntegration ?
                    analysis.components.synthesisIntegration.synthesisQuality : 0;

                analysis.correlationDepth = this.calculateCorrelationDepth(analysis);

                return analysis;
            },

            // Generate deep insights
            generateDeepInsights: function(analysis) {
                const insights = [];

                // Canvas evolution insights
                if (analysis.components.canvasEvolution) {
                    const evolution = analysis.components.canvasEvolution;

                    if (evolution.contentGrowth > 100) {
                        insights.push({
                            type: 'canvas_growth',
                            priority: 'high',
                            description: `Canvas content growing rapidly (${evolution.contentGrowth.toFixed(0)} chars/min)`,
                            implications: 'High analysis demand - consider increasing processing capacity'
                        });
                    }

                    if (evolution.stabilityMetrics && evolution.stabilityMetrics.overall > 80) {
                        insights.push({
                            type: 'canvas_stability',
                            priority: 'medium',
                            description: `Canvas evolution highly stable (${evolution.stabilityMetrics.overall}% stability)`,
                            implications: 'Predictable patterns - optimize for consistency analysis'
                        });
                    }

                    if (evolution.synthesisAlignment > 80) {
                        insights.push({
                            type: 'synthesis_alignment',
                            priority: 'high',
                            description: `Synthesis report strongly aligned with canvas evolution (${evolution.synthesisAlignment.toFixed(1)}% alignment)`,
                            implications: 'High-quality synthesis - excellent integration achieved'
                        });
                    }
                }

                // AI system insights
                if (analysis.components.aiCorrelation) {
                    const correlation = analysis.components.aiCorrelation;

                    if (correlation.systemConsensus > 0.7) {
                        insights.push({
                            type: 'ai_consensus',
                            priority: 'high',
                            description: `High AI system consensus (${(correlation.systemConsensus * 100).toFixed(1)}%)`,
                            implications: 'Strong collaborative foundation - leverage for complex analysis'
                        });
                    }

                    if (correlation.synthesisAgreement > 70) {
                        insights.push({
                            type: 'synthesis_agreement',
                            priority: 'high',
                            description: `AI systems strongly agree with synthesis (${correlation.synthesisAgreement.toFixed(1)}% agreement)`,
                            implications: 'High confidence in synthesis results - excellent validation'
                        });
                    }
                }

                // Synthesis quality insights
                if (analysis.components.synthesisIntegration) {
                    const integration = analysis.components.synthesisIntegration;

                    if (integration.comprehensiveCoverage > 80) {
                        insights.push({
                            type: 'comprehensive_coverage',
                            priority: 'high',
                            description: `Synthesis provides comprehensive coverage (${integration.comprehensiveCoverage.toFixed(1)}%)`,
                            implications: 'Complete analysis achieved - maximize insight utilization'
                        });
                    }
                }

                // Predictive insights
                if (analysis.components.predictiveCorrelation) {
                    const predictive = analysis.components.predictiveCorrelation;

                    if (predictive.predictiveAccuracy > 70) {
                        insights.push({
                            type: 'predictive_accuracy',
                            priority: 'medium',
                            description: `High predictive accuracy (${predictive.predictiveAccuracy.toFixed(1)}%)`,
                            implications: 'Reliable forecasting - use predictions for planning'
                        });
                    }

                    if (predictive.riskAssessment.level === 'high') {
                        insights.push({
                            type: 'risk_warning',
                            priority: 'high',
                            description: 'High risk factors detected in system predictions',
                            implications: 'Monitor closely - consider contingency planning',
                            factors: predictive.riskAssessment.factors
                        });
                    }
                }

                return insights.sort((a, b) => {
                    const priorityOrder = { high: 3, medium: 2, low: 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                });
            },

            // Calculate correlation depth
            calculateCorrelationDepth: function(analysis) {
                let depth = 0;

                if (analysis.components.canvasEvolution) depth += 25;
                if (analysis.components.aiCorrelation) depth += 25;
                if (analysis.components.synthesisIntegration) depth += 25;
                if (analysis.components.predictiveCorrelation) depth += 25;

                return depth;
            },

            // Get current canvas data
            getCurrentCanvasData: function() {
                const canvasState = localStorage.getItem('canvas_evolution_data');
                if (!canvasState) return null;

                try {
                    return JSON.parse(canvasState);
                } catch (error) {
                    return null;
                }
            },

            // Get current AI data
            getCurrentAIData: function() {
                const aiMemory = localStorage.getItem('ai_memory_state');
                if (!aiMemory) return null;

                try {
                    return JSON.parse(aiMemory);
                } catch (error) {
                    return null;
                }
            },

            // Store analysis results
            storeAnalysisResults: function(analysis) {
                this.analysisCycles.push(analysis);

                // Keep only last 20 analysis cycles
                if (this.analysisCycles.length > 20) {
                    this.analysisCycles.shift();
                }

                // Store in localStorage
                localStorage.setItem('correlative_analysis_results', JSON.stringify({
                    latest: analysis,
                    history: this.analysisCycles,
                    timestamp: Date.now()
                }));
            },

            // Update analysis metrics
            updateAnalysisMetrics: function(analysis) {
                this.metrics.synthesisQuality = analysis.synthesisQuality;
                this.metrics.correlationDepth = analysis.correlationDepth;
                this.metrics.insightGeneration = analysis.insights.length;
                this.metrics.predictiveAccuracy = analysis.components.predictiveCorrelation ?
                    analysis.components.predictiveCorrelation.predictiveAccuracy : 0;
            },

            // Check for existing synthesis reports
            checkExistingSynthesisReports: function() {
                const synthesisReport = localStorage.getItem('synthesis_report');
                if (synthesisReport) {
                    // Trigger analysis for existing report
                    setTimeout(() => {
                        this.handleSynthesisReportGeneration();
                    }, 1000);
                }
            },

            // Schedule deep analysis
            scheduleDeepAnalysis: function() {
                // Perform deep analysis every 15 minutes
                setInterval(() => {
                    this.performScheduledAnalysis();
                }, 15 * 60 * 1000);
            },

            // Perform scheduled analysis
            performScheduledAnalysis: function() {
                try {
                    const canvasData = this.getCurrentCanvasData();
                    const aiData = this.getCurrentAIData();

                    if (canvasData || aiData) {
                        // Perform analysis even without new synthesis report
                        const analysis = this.performCorrelativeAnalysis(null, canvasData, aiData, null);
                        this.storeAnalysisResults(analysis);
                        this.updateAnalysisMetrics(analysis);

                        console.log('üîç Scheduled correlative analysis completed');
                    }
                } catch (error) {
                    console.warn('Scheduled correlative analysis failed:', error);
                }
            },

            // Get latest analysis results
            getLatestAnalysis: function() {
                return this.analysisCycles[this.analysisCycles.length - 1] || null;
            },

            // Get analysis insights
            getAnalysisInsights: function() {
                const latest = this.getLatestAnalysis();
                if (!latest) return null;

                return {
                    synthesisQuality: latest.synthesisQuality,
                    correlationDepth: latest.correlationDepth,
                    insightsCount: latest.insights.length,
                    topInsights: latest.insights.slice(0, 3),
                    lastAnalysis: new Date(latest.timestamp).toLocaleTimeString()
                };
            }
        };

        // Initialize correlative analysis framework
        correlativeAnalysisFramework.initialize();

        // Trigger correlative analysis with synthesis data
        function triggerCorrelativeAnalysis(canvasContent, aiMemory, synthesisContent, aiFeeds) {
            logDjinnEvent('analysis', 'Correlative analysis triggered', {
                canvasLength: canvasContent?.length || 0,
                synthesisLength: synthesisContent?.length || 0,
                feedCount: aiFeeds?.length || 0
            });

            console.log('üî¨ TRIGGERING CORRELATIVE ANALYSIS:', {
                canvasContentLength: canvasContent?.length || 0,
                aiMemoryLength: aiMemory?.length || 0,
                synthesisContentLength: synthesisContent?.length || 0,
                aiFeedsLength: aiFeeds?.length || 0
            });

            try {
                // Perform correlative analysis using the framework
                const analysis = correlativeAnalysisFramework.performCorrelativeAnalysis(
                    synthesisContent, // synthesisReport
                    canvasContent,    // canvasData
                    aiFeeds,          // aiData
                    null              // predictions (not available)
                );

                // Update the correlative analysis display
                updateCorrelativeAnalysisDisplay(analysis);

                // Store results in localStorage for persistence
                localStorage.setItem('correlative_analysis_results', JSON.stringify(analysis));

                console.log('‚úÖ Correlative analysis completed successfully');

            } catch (error) {
                console.error('‚ùå Correlative analysis failed:', error);
                // Update display with error state
                const insightsElement = document.getElementById('correlativeAnalysisInsights');
                if (insightsElement) {
                    insightsElement.textContent = 'üî¨ DJINN COUNCIL CORRELATIVE ANALYSIS\n\n‚ùå Analysis Error: ' + error.message;
                }
            }
        }

        // Memory compression functions to prevent localStorage quota errors
        function compressMemoryForStorage(memory) {
            const compressed = {
                sessionId: memory.sessionId,
                sessionStart: memory.sessionStart,
                maxMemories: memory.maxMemories,
                members: {}
            };

            // Compress member reports by keeping only essential data
            Object.entries(memory.members).forEach(([key, member]) => {
                compressed.members[key] = {
                    specialization: member.specialization,
                    reports: member.reports.map(report => ({
                        reportId: report.reportId,
                        timestamp: report.timestamp,
                        analysis: report.analysis.substring(0, 500), // Truncate analysis
                        buildingOn: report.buildingOn,
                        metrics: report.metrics
                    })).slice(-10) // Keep only last 10 reports
                };
            });

            // Include only essential canvas AI data
            if (memory.canvasAISystems) {
                compressed.canvasAISystems = {};
                Object.entries(memory.canvasAISystems).forEach(([key, system]) => {
                    compressed.canvasAISystems[key] = {
                        interactions: system.interactions.slice(-5), // Keep only last 5 interactions
                        performance: system.performance
                    };
                });
            }

            return compressed;
        }

        function ultraCompressMemory(memory) {
            // Emergency ultra compression for quota exceeded scenarios
            return {
                sessionId: memory.sessionId,
                sessionStart: memory.sessionStart,
                maxMemories: memory.maxMemories,
                members: Object.fromEntries(
                    Object.entries(memory.members).map(([key, member]) => [
                        key,
                        {
                            specialization: member.specialization,
                            reports: member.reports.slice(-3).map(report => ({ // Keep only last 3 reports
                                reportId: report.reportId,
                                timestamp: report.timestamp,
                                analysis: report.analysis.substring(0, 150), // Severely truncate
                                buildingOn: report.buildingOn
                            }))
                        }
                    ])
                )
            };
        }

        // Store member report with full context
        function storeCouncilMemberReport(memberName, reportData) {
            logDjinnEvent('member', `${memberName.replace('_', ' & ')} analysis complete - report stored`, {
                reportLength: reportData.analysis?.length || 0
            });

            const member = djinnCouncilMemory.members[memberName];

            // Add new report
            member.reports.push({
                reportId: member.reports.length + 1,
                timestamp: new Date().toISOString(),
                metrics: reportData.metrics || {},
                analysis: reportData.analysis || '',
                canvasDataAnalyzed: reportData.canvasData || '',
                buildingOn: member.reports.length > 0 ? `Reports 1-${member.reports.length}` : 'Initial analysis'
            });

            // Maintain 25 memory limit
            if (member.reports.length > djinnCouncilMemory.maxMemories) {
                member.reports.shift(); // Remove oldest
            }

            // Save to localStorage with compression to prevent quota errors
            try {
                const compressedMemory = compressMemoryForStorage(djinnCouncilMemory);
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(compressedMemory));
            } catch (error) {
                console.warn('Storage quota exceeded, compressing memory further:', error);
                const ultraCompressed = ultraCompressMemory(djinnCouncilMemory);
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(ultraCompressed));
            }
        }

        // Calculate comprehensive canvas statistics
        function calculateCanvasStats(content) {
            if (!content) return { length: 0, words: 0, lines: 0, complexity: 0, uniqueWords: 0, avgWordLength: 0, density: 0 };

            const words = content.trim().split(/\s+/).filter(w => w.length > 0);
            const lines = content.split('\n').filter(l => l.trim().length > 0);
            const uniqueWords = new Set(words.map(w => w.toLowerCase()));
            const avgWordLength = words.length > 0 ? words.reduce((sum, w) => sum + w.length, 0) / words.length : 0;

            // Complexity based on vocabulary richness, sentence structure, and content density
            const vocabularyRichness = uniqueWords.size / Math.max(words.length, 1);
            const sentenceComplexity = lines.length > 0 ? words.length / lines.length : 0;
            const contentDensity = content.replace(/\s/g, '').length / Math.max(content.length, 1);

            const complexity = Math.min(100, Math.round(
                (vocabularyRichness * 30) +
                (Math.min(sentenceComplexity, 20) * 2) +
                (contentDensity * 40) +
                (avgWordLength * 5)
            ));

            return {
                length: content.length,
                words: words.length,
                lines: lines.length,
                complexity: complexity,
                uniqueWords: uniqueWords.size,
                avgWordLength: Math.round(avgWordLength * 100) / 100,
                density: Math.round(contentDensity * 100)
            };
        }

        // Generate complete referential analysis for council member
        function generateReferentialAnalysis(memberName, currentCanvasData) {
            const member = djinnCouncilMemory.members[memberName];
            const allReports = member.reports;
            const canvasStats = calculateCanvasStats(currentCanvasData);

            // Only use actual canvas content and basic statistics - NO FABRICATION
            const realCanvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const canvasLength = realCanvasContent.length;
            const wordCount = realCanvasContent.trim() ? realCanvasContent.trim().split(/\s+/).length : 0;
            const lineCount = realCanvasContent.split('\n').length;

            const analysisPrompt = `
ENHANCED ACCURACY INSTRUCTIONS:
- You are ${memberName.replace('_', ' & ')}, specializing in ${member.specialization}
- Maintain your sophisticated analytical capabilities while grounding analysis in real data
- When referencing AI systems, ONLY use data from the localStorage sections provided below
- For metrics and percentages, base calculations on actual data provided, not estimates
- If specific performance data is not available, clearly state "Performance data not available" rather than creating placeholder numbers
- Use your expertise to provide deep insights, but anchor all claims to the provided data sources
- Maintain the full analytical framework while ensuring factual accuracy

=== CURRENT CANVAS STATISTICS ===
- Content Length: ${canvasStats.length} characters
- Word Count: ${canvasStats.words} words
- Line Count: ${canvasStats.lines} lines
- Complexity Score: ${canvasStats.complexity}/100
- Unique Words: ${canvasStats.uniqueWords}
- Average Word Length: ${canvasStats.avgWordLength} characters
- Content Density: ${canvasStats.density}%

=== ACTUAL SYSTEM DATA (localStorage) ===
AI Memory State: ${localStorage.getItem('ai_memory_state') ? 'Available' : 'Not Available'}
AI Feeds Data: ${localStorage.getItem('ai_feeds') ? 'Available' : 'Not Available'}
Synthesis Reports: ${localStorage.getItem('synthesis_report') ? 'Available' : 'Not Available'}
Intelligence Reports: ${localStorage.getItem('intelligence_reports') ? 'Available' : 'Not Available'}

=== COUNCIL MEMBER MEMORY BANK ===
Your Previous Reports: ${allReports.length} total
${allReports.slice(-3).map((report, i) => `
[REPORT ${report.reportId}] ${report.timestamp}
Key Insights: ${report.analysis.substring(0, 200)}...
`).join('\n')}

=== CURRENT CANVAS CONTENT TO ANALYZE ===
${realCanvasContent || 'No canvas content available for analysis'}

=== DOCUMENT SURVEILLANCE ANALYSIS FRAMEWORK ===
You are ${memberName.replace('_', ' & ')}, a document analysis specialist focusing on ${member.specialization}.

Apply your expertise using this three-layer surveillance framework:

LAYER 1 - AI COLLABORATIVE INTELLIGENCE: Analyze how the 5-AI system (DJINN-NAZAR-NARRA-WHALE-WATCHTOWER) influences document evolution
LAYER 2 - DOCUMENT CONTENT: Deep analysis of the document structure, themes, and patterns
LAYER 3 - EVOLUTION TRACKING: How AI collaborative intelligence transforms and evolves the document over time

REQUIRED RESPONSE FORMAT:
**SUMMARY**
[Provide sophisticated analysis combining your expertise with the actual data available]

**ANALYSIS**
[Deep analytical approach explaining your methodology and insights from the provided data]

**FINDINGS**
- **AI Collaborative Intelligence Impact:** [How the 5-AI system shapes document evolution - based on actual localStorage data]
- **Document Content Analysis:** [Analysis of content patterns and structural evolution based on your memory bank]
- **Document Transformation Patterns:** [How AI collaborative intelligence transforms the document over time]
- **Evolution Assessment:** [Document development trends and transformation quality evaluation]

**METRICS**
[Provide specific numerical values based on actual analysis - avoid placeholder percentages]
- AI System Coherence: [Calculate from available data or state "Data insufficient"]
- Content Evolution Rate: [Base on actual content analysis]
- AI-Content Interaction Density: [Calculate from available interactions]
- System Memory Utilization: [From actual localStorage data]
- Content Stability Index: [Calculate from content analysis]

**CONCLUSIONS**
[Synthesize your expert analysis while clearly indicating data limitations]

**ACTIONS**
1. [Specific recommendation based on your analytical findings]
2. [Strategic recommendation for system optimization]
3. [Actionable insight for content or system improvement]

ENHANCED CONSTRAINTS:
- Maximum 500 words total
- Use sophisticated analysis while stating data limitations clearly
- Base metrics on actual calculations, not estimates
- Maintain your expertise depth while ensuring factual grounding
- Real AI feed entries with timestamps and content
- Actual canvas content and synthesis data
- Previous intelligence reports and council findings

CRITICAL REQUIREMENTS:
1. Base your analysis ONLY on the real data provided above
2. DO NOT invent percentages, metrics, or performance data not shown
3. Reference specific entries from the actual localStorage data
4. Analyze trends in the actual conversation histories and insights
5. Cross-reference insights from other council members' reports when relevant
6. Build upon previous council consensus findings and patterns
7. Only discuss the 5 AI systems: NARRA, NAZAR, WHALE, DJINN, WATCHTOWER

CROSS-MEMBER COLLABORATION:
- Reference relevant insights from other council members when they relate to your specialization
- Build upon patterns identified in previous consensus reports
- Note where your analysis confirms, contradicts, or extends other members' findings
- Use the complete council memory bank to provide deeper, interconnected analysis

IMPORTANT DIFFERENTIATION REQUIREMENT:
You must clearly separate THREE DISTINCT LAYERS in your analysis:

LAYER 1 - AI SYSTEMS: ONLY the five real AI entities (narra, nazar, whale, djinn, watchtower) - their performance, memory states, interaction patterns, and system health.

LAYER 2 - CANVAS CONTENT: The data/content that exists within the canvas that these AI systems are analyzing and working with.

LAYER 3 - CONTENT EVOLUTION: How the canvas content changes over time through iterations as AI systems process and modify it.

DO NOT conflate these layers. When analyzing "system performance", talk ONLY about the AI systems themselves. When analyzing "content evolution", talk ONLY about how the canvas data changes over time.

Write your complete analysis report following this exact structure:

**SUMMARY**
[Write one paragraph summarizing your key findings about the REAL AI systems (Layer 1) and their actual performance data, SEPARATE from content analysis]

**ANALYSIS**
[Write one paragraph explaining your analytical approach, focusing on the actual AI system data (Layer 1) and memory contents, clearly differentiated from content evolution]

**FINDINGS**
- **AI Systems Performance:** [Describe REAL AI system status, activity levels, memory states, and operational health from Layer 1 data ONLY - ONLY mention the 5 real systems]
- **Canvas Content Evolution:** [Describe how canvas content (Layer 2) has changed over time based on the evolution timeline (Layer 3), SEPARATE from AI system performance]
- **AI-System Interaction Patterns:** [Identify patterns in how AI systems (Layer 1) interact with and process canvas content (Layer 2)]
- **Risk Assessment:** [Assess stability and potential issues in AI systems (Layer 1) and content evolution processes (Layer 3)]

**METRICS**
[Provide SPECIFIC numerical values 0-100 for each metric based on your analysis - no placeholders]

- AI System Coherence: [0-100] - [brief explanation with specific number]
- Content Evolution Rate: [0-100] - [brief explanation with specific number]
- AI-Content Interaction Density: [0-100] - [brief explanation with specific number]
- System Memory Utilization: [0-100] - [brief explanation with specific number]
- Content Stability Index: [0-100] - [brief explanation with specific number]

**CONCLUSIONS**
[Write one paragraph synthesizing what your analysis of the AI systems (Layer 1) and content evolution (Layer 3) means, keeping them clearly differentiated]

**ACTIONS**
1. [Specific recommendation for AI system (Layer 1) optimization or monitoring]
2. [Specific recommendation for content evolution (Layer 3) processes]
3. [Specific recommendation for AI-content interaction (Layer 1 + Layer 2) improvement]

RESPONSE CONSTRAINTS:
- Maximum 500 words total
- No repetitive phrases or concepts
- Each section must be distinct and non-redundant
- Use bullet points for clarity, not paragraphs
- Start directly with **SUMMARY**
- Avoid saying "The data shows" or "The data reveals" repeatedly
- Focus on unique insights, not rehashing the same points
`;

            return analysisPrompt;
        }

        // Track Canvas AI System Performance
        function trackCanvasAISystems() {
            try {
                // Get data from main canvas localStorage with cross-window access
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';

                console.log('üîç DJINN tracking canvas AI systems:', {
                    feedsCount: aiFeeds.length,
                    contentLength: canvasContent.length,
                    memoryKeys: Object.keys(JSON.parse(aiMemory || '{}'))
                });

                // Parse AI memory to get actual system data
                let parsedMemory = {};
                try {
                    parsedMemory = JSON.parse(aiMemory);
                } catch (e) {
                    console.warn('Failed to parse AI memory:', e);
                    parsedMemory = {};
                }

                // If memory is empty, try to get real-time canvas data
                if (Object.keys(parsedMemory).length === 0) {
                    console.log('üîÑ No AI memory found, attempting real-time canvas access...');

                    // Try to access parent window if in iframe
                    try {
                        if (window.parent && window.parent !== window) {
                            const parentMemory = window.parent.localStorage.getItem('ai_memory_state');
                            if (parentMemory) {
                                parsedMemory = JSON.parse(parentMemory);
                                console.log('‚úÖ Retrieved memory from parent window');
                            }
                        }
                    } catch (crossOriginError) {
                        console.warn('Cross-origin access blocked:', crossOriginError);
                    }
                }

                // Update system performance based on actual AI memory data
                Object.keys(djinnCouncilMemory.canvasAISystems).forEach(system => {
                    const systemData = parsedMemory[system];

                    if (systemData && typeof systemData === 'object') {
                        // Use actual memory data to determine activity
                        const hasMemory = systemData.conversationHistory && systemData.conversationHistory.length > 0;
                        const memoryCount = systemData.conversationHistory ? systemData.conversationHistory.length : 0;
                        const insightCount = systemData.keyInsights ? systemData.keyInsights.length : 0;
                        const responseCount = systemData.responseHistory ? systemData.responseHistory.length : 0;

                        // Add interaction record with real data
                        const interactionData = {
                            timestamp: new Date().toISOString(),
                            interaction: `Active: ${memoryCount} conversations, ${insightCount} insights, ${responseCount} responses`,
                            performance: calculateSystemPerformance(system, [{
                                content: JSON.stringify(systemData),
                                length: JSON.stringify(systemData).length,
                                hasMemory,
                                memoryCount,
                                insightCount,
                                responseCount
                            }])
                        };

                        djinnCouncilMemory.canvasAISystems[system].interactions.push(interactionData);

                        // Update performance metrics with real data
                        if (hasMemory) {
                            djinnCouncilMemory.canvasAISystems[system].lastActivity = new Date().toISOString();

                            // Ensure performanceMetrics object exists
                            if (!djinnCouncilMemory.canvasAISystems[system].performanceMetrics) {
                                djinnCouncilMemory.canvasAISystems[system].performanceMetrics = {};
                            }

                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.consistency = Math.min(95, 60 + (memoryCount * 5));
                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.relevance = Math.min(95, 50 + (insightCount * 8));
                            djinnCouncilMemory.canvasAISystems[system].performanceMetrics.taskEffectiveness = Math.min(95, 55 + (responseCount * 7));
                        }

                        console.log(`üìä ${system.toUpperCase()}: ${memoryCount} conversations, ${insightCount} insights, ${responseCount} responses`);

                        // Keep only recent interactions
                        if (djinnCouncilMemory.canvasAISystems[system].interactions.length > 10) {
                            djinnCouncilMemory.canvasAISystems[system].interactions =
                                djinnCouncilMemory.canvasAISystems[system].interactions.slice(-10);
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è No valid data found for ${system}:`, systemData);
                    }
                });

                // Also process AI feeds for additional context
                if (aiFeeds && aiFeeds.length > 0) {
                    const systemInteractions = categorizeAIInteractions(aiFeeds);
                    Object.keys(systemInteractions).forEach(system => {
                        if (systemInteractions[system] && systemInteractions[system].length > 0) {
                            systemInteractions[system].forEach(feed => {
                                const interactionText = typeof feed === 'string' ? feed : (feed.content || JSON.stringify(feed));
                                djinnCouncilMemory.canvasAISystems[system].interactions.push({
                                    timestamp: new Date().toISOString(),
                                    interaction: `Feed: ${interactionText.substring(0, 100)}...`,
                                    performance: calculateSystemPerformance(system, [feed])
                                });
                            });
                        }
                    });
                }

                console.log('‚úÖ Canvas AI Systems tracking completed');

                // Track canvas evolution
                djinnCouncilMemory.canvasEvolution.push({
                    timestamp: new Date().toISOString(),
                    content: canvasContent,
                    aiMemoryState: aiMemory,
                    complexity: calculateContentComplexity(canvasContent)
                });

            } catch (error) {
                console.error('‚ùå Error tracking Canvas AI Systems:', error);

                // Log empty data state for debugging
                console.log('üìä Current canvas AI systems state:', djinnCouncilMemory.canvasAISystems);
            }

            // Keep evolution history manageable
            if (djinnCouncilMemory.canvasEvolution.length > 20) {
                djinnCouncilMemory.canvasEvolution = djinnCouncilMemory.canvasEvolution.slice(-20);
            }
        }

        function categorizeAIInteractions(aiFeeds) {
            // Parse AI feeds and categorize by system
            const systems = {
                narra: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('narra') ||
                    feed.content.toLowerCase().includes('pattern recognition')),
                nazar: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('nazar') ||
                    feed.content.toLowerCase().includes('consciousness')),
                whale: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('whale') ||
                    feed.content.toLowerCase().includes('deep interrogation')),
                djinn: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('djinn') ||
                    feed.content.toLowerCase().includes('governance')),
                watchtower: aiFeeds.filter(feed =>
                    feed.content.toLowerCase().includes('watchtower') ||
                    feed.content.toLowerCase().includes('monitoring'))
            };

            return systems;
        }

        function calculateSystemPerformance(system, interactions) {
            if (!interactions || interactions.length === 0) {
                return {
                    responseCount: 0,
                    avgResponseLength: 0,
                    lastActive: 'Never',
                    performanceMetrics: {
                        consistency: 0,
                        relevance: 0,
                        taskEffectiveness: 0
                    }
                };
            }

            // Calculate response length statistics
            const responseLengths = interactions.map(i => i.length || i.interaction?.length || 0);
            const avgResponseLength = responseLengths.reduce((a, b) => a + b, 0) / responseLengths.length;

            // Consistency: Standard deviation of response lengths (lower = more consistent)
            const lengthVariance = responseLengths.reduce((sum, len) => sum + Math.pow(len - avgResponseLength, 2), 0) / responseLengths.length;
            const lengthStdDev = Math.sqrt(lengthVariance);
            const consistency = Math.max(0, 100 - (lengthStdDev / Math.max(avgResponseLength, 1)) * 50);

            // Relevance: Based on presence of system-specific keywords and structured analysis
            let relevanceScore = 0;
            interactions.forEach(interaction => {
                const text = (interaction.interaction || '').toLowerCase();

                // Check for system-specific content
                const systemKeywords = {
                    narra: ['pattern', 'recognition', 'correlation', 'trend'],
                    nazar: ['consciousness', 'fractal', 'emotional', 'resonance'],
                    whale: ['deep', 'interrogation', 'memory', 'analysis'],
                    djinn: ['governance', 'strategic', 'authority', 'decision'],
                    watchtower: ['monitoring', 'metrics', 'performance', 'operational']
                };

                const keywords = systemKeywords[system] || [];
                const keywordMatches = keywords.filter(k => text.includes(k)).length;
                relevanceScore += (keywordMatches / keywords.length) * 25;

                // Check for structured analysis (metrics, numbered lists, etc.)
                if (/\[METRICS\]|\[ANALYSIS\]|\d+\.|\‚Ä¢|\-/.test(text)) relevanceScore += 20;
                if (text.length > 200) relevanceScore += 10; // Substantial content
                if (text.includes('**') || text.includes('##')) relevanceScore += 10; // Formatting
            });
            const relevance = Math.min(100, relevanceScore / interactions.length);

            // Task Effectiveness: Based on analysis quality and actionable insights
            let effectivenessScore = 0;
            interactions.forEach(interaction => {
                const text = (interaction.interaction || '').toLowerCase();

                // Check for analytical depth
                if (text.includes('analysis') || text.includes('assessment')) effectivenessScore += 15;
                if (/\d+[%]|\d+\/\d+|\d+\.\d+/.test(text)) effectivenessScore += 15; // Quantitative metrics
                if (text.includes('recommendation') || text.includes('conclusion')) effectivenessScore += 10;
                if (text.includes('trend') || text.includes('pattern')) effectivenessScore += 10;
                if (text.length > 300) effectivenessScore += 5; // Comprehensive response

                // Penalize for generic or repetitive content
                if (text.split(' ').length < 50) effectivenessScore -= 10;
                const repeatedWords = text.split(' ').filter((word, i, arr) => arr.indexOf(word) !== i);
                if (repeatedWords.length > text.split(' ').length * 0.3) effectivenessScore -= 15;
            });
            const taskEffectiveness = Math.max(0, Math.min(100, effectivenessScore / interactions.length));

            return {
                responseCount: interactions.length,
                avgResponseLength: Math.round(avgResponseLength),
                lastActive: interactions[interactions.length - 1]?.timestamp || 'Never',
                performanceMetrics: {
                    consistency: Math.round(consistency),
                    relevance: Math.round(relevance),
                    taskEffectiveness: Math.round(taskEffectiveness)
                }
            };
        }

        function calculateContentComplexity(content) {
            const words = content.split(' ').length;
            const sentences = content.split(/[.!?]+/).length;
            const avgWordLength = content.replace(/[^a-zA-Z]/g, '').length / words || 0;
            return Math.round((words * 0.1) + (sentences * 0.5) + (avgWordLength * 2));
        }


        // Enhanced surveillance between Canvas and Council
        function setupCrossWindowSurveillance() {
            console.log('üîó Setting up cross-window surveillance...');

            // Listen for canvas changes
            window.addEventListener('storage', function(e) {
                console.log(`üì° Storage event detected: ${e.key}`);

                if (e.key === 'sovereign_canvas_content') {
                    const newContent = e.newValue;
                    const timestamp = new Date().toISOString();

                    console.log('üìù Canvas content updated, length:', newContent ? newContent.length : 0);

                    // Track canvas evolution
                    djinnCouncilMemory.canvasEvolution.push({
                        timestamp: timestamp,
                        content: newContent,
                        changeType: 'content_update',
                        complexity: calculateContentComplexity(newContent)
                    });

                    // Trigger real-time analysis if significant change
                    if (isSignificantChange(newContent)) {
                        console.log('üö® Significant change detected, triggering analysis');
                        triggerRealTimeAnalysis();
                    }

                    // Update AI systems tracking
                    trackCanvasAISystems();
                }

                // Monitor AI memory state changes
                if (e.key === 'ai_memory_state') {
                    const newMemory = e.newValue;
                    console.log('üß† AI memory state updated:', newMemory ? Object.keys(JSON.parse(newMemory)).length : 0, 'systems');

                    // Update AI systems tracking immediately
                    trackCanvasAISystems();

                    // Trigger memory analysis
                    queueAnalysis('memory_update', { memory: newMemory, type: 'memory' });
                }

                // Monitor AI feeds
                if (e.key === 'ai_feeds') {
                    const newFeeds = e.newValue;
                    const feedsArray = newFeeds ? JSON.parse(newFeeds) : [];
                    console.log('üì° AI feeds updated:', feedsArray.length, 'feeds');

                    // Update AI systems tracking
                    trackCanvasAISystems();

                    // Trigger feed analysis
                    if (feedsArray.length > 0) {
                        queueAnalysis('new_feeds', { feeds: feedsArray, type: 'feeds' });
                    }
                }
            });
        }

        function testCrossWindowAccess() {
            try {
                // Test if we can access parent window data
                if (window.parent && window.parent !== window) {
                    const parentMemory = window.parent.localStorage.getItem('ai_memory_state');
                    return !!parentMemory;
                }

                // Test if we can access same-origin data
                return !!localStorage.getItem('ai_memory_state');
            } catch (error) {
                console.warn('Cross-window access test failed:', error);
                return false;
            }
        }

        function isSignificantChange(newContent) {
            const lastSnapshot = djinnCouncilMemory.canvasEvolution.slice(-2)[0];
            if (!lastSnapshot) return true;

            const wordCountDiff = Math.abs(
                newContent.split(' ').length - lastSnapshot.content.split(' ').length
            );

            return wordCountDiff > 50; // Significant if 50+ word difference
        }

        function triggerRealTimeAnalysis() {
            logDjinnEvent('analysis', 'Real-time analysis triggered - significant document changes detected');
            // Auto-trigger council analysis for significant canvas changes
            console.log('üö® Significant canvas change detected - triggering council analysis');

            // Update UI indicator
            const indicator = document.getElementById('realtime-indicator');
            if (indicator) {
                indicator.textContent = 'üî¥ Real-time Analysis Triggered';
                indicator.style.color = '#ff6b6b';
            }
        }

        // Robust error handling for AI failures
        function handleAnalysisError(memberName, error) {
            logDjinnEvent('error', `${memberName.replace('_', ' & ')} analysis failed: ${error.message}`);
            console.error(`Council Member ${memberName} Analysis Failed:`, error);

            // Store error in memory
            const errorReport = {
                timestamp: new Date().toISOString(),
                memberName: memberName,
                error: error.message,
                recovery: 'fallback_analysis_initiated'
            };

            djinnCouncilMemory.errors = djinnCouncilMemory.errors || [];
            djinnCouncilMemory.errors.push(errorReport);

            // No fallback - throw the error to be handled upstream
            throw error;
        }

        // System health monitoring
        function systemHealthMonitor() {
            // Get current AI memory state
            const aiMemoryData = localStorage.getItem('ai_memory_state');
            let parsedMemory = {};
            let aiSystemsActive = 0;

            try {
                parsedMemory = JSON.parse(aiMemoryData || '{}');
                aiSystemsActive = Object.keys(parsedMemory).filter(system => {
                    const systemData = parsedMemory[system];
                    return systemData &&
                           systemData.conversationHistory &&
                           systemData.conversationHistory.length > 0;
                }).length;
            } catch (e) {
                console.warn('Failed to parse AI memory in health monitor:', e);
            }

            const healthCheck = {
                timestamp: new Date().toISOString(),
                canvasConnection: !!localStorage.getItem('sovereign_canvas_content'),
                aiMemoryConnection: !!localStorage.getItem('ai_memory_state'),
                aiSystemsActive: aiSystemsActive,
                totalAISystems: Object.keys(parsedMemory).length,
                councilMemoryIntegrity: true,
                localStorage: isLocalStorageAvailable(),
                crossWindowAccess: testCrossWindowAccess()
            };

            console.log('üè• Health check:', healthCheck);

            djinnCouncilMemory.systemHealth = djinnCouncilMemory.systemHealth || [];
            djinnCouncilMemory.systemHealth.push(healthCheck);

            // Keep only last 10 health checks
            if (djinnCouncilMemory.systemHealth.length > 10) {
                djinnCouncilMemory.systemHealth.shift();
            }

            // Update UI dashboard
            // updateStatusDashboard(healthCheck); // Removed - using compact display

            return healthCheck;
        }


        function isLocalStorageAvailable() {
            try {
                const test = '__localStorage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Clear corrupted memory
        function clearCouncilMemory() {
            logDjinnEvent('system', 'Council memory cleared - fresh session initiated');
            // Clear localStorage
            localStorage.removeItem('djinn_council_complete_memory');
            localStorage.removeItem('djinn_intelligence');
            localStorage.removeItem('djinn_intelligence_backup');

            // Reset surveillance state including rounds completed
            localStorage.removeItem('djinn_surveillance_state');

            // Reset in-memory objects
            currentAIMemory = '{}';

            // Reset the djinnCouncilMemory object to fresh state
            Object.keys(djinnCouncilMemory.members).forEach(memberKey => {
                djinnCouncilMemory.members[memberKey].reports = [];
            });
            djinnCouncilMemory.canvasEvolution = [];
            djinnCouncilMemory.consensusHistory = [];
            djinnCouncilMemory.systemHealth = [];
            djinnCouncilMemory.errors = [];
            djinnCouncilMemory.sessionId = generateSessionId();
            djinnCouncilMemory.sessionStart = new Date().toISOString();

            // Clear all member displays
            ['pattern-analysis', 'wisdom-analysis', 'paradox-analysis', 'boundaries-analysis', 'memory-analysis'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = 'Awaiting analysis...';
            });

            // Reset status indicators
            ['pattern-status', 'wisdom-status', 'paradox-status', 'boundaries-status', 'memory-status'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = 'STANDBY';
            });

            // Update memory display

            // Update surveillance metrics to reflect reset
            updateAllSurveillanceMetrics();

            console.log('‚úÖ DJINN Council memory completely reset - fresh session started');
        }

        // Enhanced intelligence reporting
        function generateIntelligencePackage() {
            logDjinnEvent('council', 'Intelligence package generated - comprehensive analysis compiled');
            const intelligence = {
                sessionMetadata: {
                    sessionId: djinnCouncilMemory.sessionId,
                    startTime: djinnCouncilMemory.sessionStart,
                    duration: Date.now() - new Date(djinnCouncilMemory.sessionStart).getTime(),
                    totalReports: Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0)
                },

                memberAnalytics: Object.entries(djinnCouncilMemory.members).map(([name, data]) => ({
                    member: name,
                    specialization: data.specialization,
                    reportCount: data.reports.length,
                    performanceMetrics: calculateMemberPerformance(data.reports),
                    keyInsights: extractKeyInsights(data.reports)
                })),

                systemPerformance: {
                    canvasAISystems: djinnCouncilMemory.canvasAISystems,
                    canvasEvolution: djinnCouncilMemory.canvasEvolution,
                    consensusPatterns: analyzeConsensusPatterns(),
                    emergentThemes: identifyEmergentThemes()
                },

                recommendations: generateStrategicRecommendations(),

                riskAssessment: {
                    systemHealth: djinnCouncilMemory.systemHealth?.slice(-5) || [],
                    errorLog: djinnCouncilMemory.errors || [],
                    stabilityMetrics: calculateStabilityMetrics()
                }
            };

            return intelligence;
        }

        function calculateMemberPerformance(reports) {
            return {
                avgReportLength: reports.reduce((sum, r) => sum + r.analysis.length, 0) / reports.length || 0,
                reportConsistency: calculateReportConsistency(reports),
                insightQuality: calculateInsightQuality(reports)
            };
        }

        function extractKeyInsights(reports) {
            // Extract key insights from reports
            const insights = [];
            reports.forEach(report => {
                const lines = report.analysis.split('\n');
                lines.forEach(line => {
                    if (line.includes('**') || line.includes('Key:') || line.includes('Insight:')) {
                        insights.push(line.trim());
                    }
                });
            });
            return insights.slice(-10); // Last 10 insights
        }

        function analyzeConsensusPatterns() {
            // Analyze patterns across consensus history
            return djinnCouncilMemory.consensusHistory.slice(-5).map(c => ({
                timestamp: c.timestamp,
                commonThemes: c.crossReferences || {},
                memberAgreement: Object.keys(c.memberAnalyses || {}).length
            }));
        }

        function identifyEmergentThemes() {
            // Identify themes that emerge across reports
            const allThemes = [];
            Object.values(djinnCouncilMemory.members).forEach(member => {
                member.reports.forEach(report => {
                    // Simple theme extraction - can be enhanced
                    const words = report.analysis.toLowerCase().split(' ');
                    const themes = words.filter(word => word.length > 6); // Longer words as themes
                    allThemes.push(...themes);
                });
            });

            // Count theme frequency
            const themeCount = {};
            allThemes.forEach(theme => {
                themeCount[theme] = (themeCount[theme] || 0) + 1;
            });

            return Object.entries(themeCount)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
        }

        function generateStrategicRecommendations() {
            const recommendations = [];

            // Based on system health
            const recentHealth = djinnCouncilMemory.systemHealth.slice(-3);
            if (recentHealth.some(h => !h.canvasConnection)) {
                recommendations.push("Improve Canvas connection stability");
            }

            // Based on error patterns
            const recentErrors = djinnCouncilMemory.errors?.slice(-5) || [];
            if (recentErrors.length > 2) {
                recommendations.push("Address recurring analysis errors");
            }

            // Based on performance
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);
            if (totalReports > 20) {
                recommendations.push("Consider memory optimization for long sessions");
            }

            return recommendations;
        }

        function calculateStabilityMetrics() {
            const healthChecks = djinnCouncilMemory.systemHealth.slice(-10);
            const errorCount = djinnCouncilMemory.errors?.length || 0;

            return {
                uptimePercentage: healthChecks.filter(h => h.localStorage).length / healthChecks.length * 100,
                errorRate: errorCount / Math.max(1, healthChecks.length),
                memoryIntegrity: healthChecks.filter(h => h.councilMemoryIntegrity).length / healthChecks.length * 100
            };
        }

        // Helper functions for performance calculations
        function calculateReportConsistency(reports) {
            if (reports.length < 2) return 100;
            const lengths = reports.map(r => r.analysis.length);
            const avgLength = lengths.reduce((a, b) => a + b) / lengths.length;
            const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avgLength, 2), 0) / lengths.length;
            return Math.max(0, 100 - (Math.sqrt(variance) / avgLength * 100));
        }

        function calculateInsightQuality(reports) {
            let qualityScore = 0;
            reports.forEach(report => {
                // Simple quality metrics
                if (report.analysis.includes('**')) qualityScore += 10; // Structured formatting
                if (/\d+[%\/]\d+|\d+\/\d+|\d+%|\d+\.\d+/.test(report.analysis)) qualityScore += 10; // Metrics
                if (report.analysis.length > 500) qualityScore += 5; // Substantial content
            });
            return Math.min(100, qualityScore / reports.length);
        }

        // Initialize complete memory system
        function initializeDjinnCouncilMemory() {
            // Load existing memory or create fresh session
            const existingMemory = localStorage.getItem('djinn_council_complete_memory');

            if (existingMemory) {
                Object.assign(djinnCouncilMemory, JSON.parse(existingMemory));
            } else {
                // Fresh session - save initial state
                localStorage.setItem('djinn_council_complete_memory', JSON.stringify(djinnCouncilMemory));
            }

            // Track Canvas AI performance
            trackCanvasAISystems();

            // Update UI
            // displayMemoryBank(); // Removed - using inline elements in canvas panel

            // Setup cross-window surveillance
            setupCrossWindowSurveillance();

            // Update status every 30 seconds
            // Auto-monitoring removed - event-driven only
            systemHealthMonitor(); // Initial update

            console.log(`DJINN Council Memory Initialized - Session: ${djinnCouncilMemory.sessionId}`);
        }

        // Add memory visualization to UI
        function displayMemoryBank() {
            const memoryDisplay = document.createElement('div');
            memoryDisplay.id = 'council-memory-bank';
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, member) => sum + member.reports.length, 0);
            memoryDisplay.innerHTML = `
                <h3>üß† Memory</h3>
                <div class="session-info">
                    ${djinnCouncilMemory.sessionId.split('_')[1]}<br>
                    ${totalReports} reports
                </div>
                <div class="member-memories">
                    ${Object.entries(djinnCouncilMemory.members).map(([name, data]) => 
                        `${name.charAt(0).toUpperCase()}:${data.reports.length}`
                    ).join(' ')}
                </div>
            `;

            // Add to header
            const headerElement = document.querySelector('.djinn-header');
            if (headerElement && !document.getElementById('council-memory-bank')) {
                headerElement.appendChild(memoryDisplay);
            }
        }

        // Real-time status dashboard
        // function createStatusDashboard() { // Removed - using inline elements
        //     const dashboard = document.createElement('div');
        //     dashboard.id = 'council-status-dashboard';
        //     dashboard.innerHTML = `
        //         <h4>üß† Memory Status</h4>
        //         <div id="memory-usage">Loading...</div>
        //         <h4>ü§ñ Canvas AI</h4>
        //         <div id="ai-systems-status">Loading...</div>
        //         <h4>‚ö° Performance</h4>
        //         <div id="performance-metrics">Loading...</div>
        //         <h4>üîç System Health</h4>
        //         <div id="system-health">Loading...</div>
        //     `;

        //     // Add to container
        //     const container = document.querySelector('.djinn-container');
        //     if (container && !document.getElementById('council-status-dashboard')) {
        //         container.insertAdjacentElement('afterbegin', dashboard);
        //     }

        //     // Update dashboard every 30 seconds
        //     setInterval(() => systemHealthMonitor(), 30000);
        //     systemHealthMonitor(); // Initial update
        // }

        // Update memory statistical readout
        function updateCompactMemoryStatus() {
            const summaryEl = document.getElementById('memorySummary');
            if (!summaryEl) return;

            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);
            const sessionDuration = Math.round((Date.now() - new Date(djinnCouncilMemory.sessionStart).getTime()) / 1000 / 60);

            // Summary line for statistical readout
            summaryEl.textContent = `${totalReports} reports, ${sessionDuration}m active`;
        }

        // Add memory controls to UI
        function addMemoryControls() {
            const controlsHtml = `
                <div class="memory-controls">
                    <button onclick="clearCouncilMemory()" class="btn-clear-memory">
                        üóëÔ∏è Start Fresh Session
                    </button>
                    <button onclick="exportMemoryData()" class="btn-export-memory">
                        üíæ Export Memory Bank
                    </button>
                </div>
            `;

            const controlsElement = document.querySelector('.djinn-controls');
            if (controlsElement && !document.querySelector('.memory-controls')) {
                controlsElement.insertAdjacentHTML('beforeend', controlsHtml);
            }
        }

        function exportMemoryData() {
            const dataStr = JSON.stringify(djinnCouncilMemory, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `djinn-council-memory-${djinnCouncilMemory.sessionId}.json`;
            link.click();
        }

        // Auto-save intelligence every 5 reports
        function autoSaveIntelligence() {
            const totalReports = Object.values(djinnCouncilMemory.members).reduce((sum, m) => sum + m.reports.length, 0);

            if (totalReports > 0 && totalReports % 5 === 0) {
                const intelligence = generateIntelligencePackage();
                localStorage.setItem('djinn_council_intelligence_backup', JSON.stringify(intelligence));
                console.log(`üìä Intelligence package auto-saved at ${totalReports} reports`);
            }
        }

        function extractMetricsFromAnalysis(analysis) {
            const metrics = {};

            // Extract numeric metrics
            const metricPatterns = {
                complexity: /complexity:?\s*(\d+)/i,
                density: /density:?\s*(\d+)/i,
                index: /index:?\s*(\d+)/i,
                rate: /rate:?\s*(\d+(?:\.\d+)?)/i,
                percentage: /(\d+(?:\.\d+)?)%/g
            };

            Object.entries(metricPatterns).forEach(([key, pattern]) => {
                const matches = analysis.match(pattern);
                if (matches) {
                    metrics[key] = matches.map(m => parseFloat(m.replace('%', '')));
                }
            });

            return metrics;
        }

        // ========================================
        // MAXIMIZE FUNCTIONALITY - EXACTLY LIKE CANVAS
        // ========================================

        function addMaximizeFeature() {
            // Find and add maximize buttons to all panels
            setTimeout(() => {
                // Canvas Surveillance
                const surveillance = document.querySelector('.canvas-surveillance');
                if (surveillance && !surveillance.querySelector('.panel-maximize-btn')) {
                    surveillance.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Surveillance';
                    btn.onclick = function() { toggleMaximize(surveillance, btn, 'Surveillance'); };
                    surveillance.insertBefore(btn, surveillance.firstChild);
                }

                // Council Consensus
                const consensus = document.querySelector('.council-consensus');
                if (consensus && !consensus.querySelector('.panel-maximize-btn')) {
                    consensus.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Consensus';
                    btn.onclick = function() { toggleMaximize(consensus, btn, 'Consensus'); };
                    consensus.insertBefore(btn, consensus.firstChild);
                }

                // Intelligence Report
                const intelligence = document.querySelector('.intelligence-report');
                if (intelligence && !intelligence.querySelector('.panel-maximize-btn')) {
                    intelligence.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Intelligence';
                    btn.onclick = function() { toggleMaximize(intelligence, btn, 'Intelligence'); };
                    intelligence.insertBefore(btn, intelligence.firstChild);
                }

                // Canvas Surveillance Extended
                const surveillanceExtended = document.querySelector('.canvas-surveillance-extended');
                if (surveillanceExtended && !surveillanceExtended.querySelector('.panel-maximize-btn')) {
                    surveillanceExtended.style.position = 'relative';
                    const btn = document.createElement('button');
                    btn.className = 'panel-maximize-btn';
                    btn.innerHTML = '‚õ∂';
                    btn.title = 'Maximize Surveillance Extended';
                    btn.onclick = function() { toggleMaximize(surveillanceExtended, btn, 'Surveillance Extended'); };
                    surveillanceExtended.insertBefore(btn, surveillanceExtended.firstChild);
                }

                // Add to each council member
                document.querySelectorAll('.council-member').forEach((member, index) => {
                    if (!member.querySelector('.panel-maximize-btn')) {
                        member.style.position = 'relative';
                        const btn = document.createElement('button');
                        btn.className = 'panel-maximize-btn';
                        btn.innerHTML = '‚õ∂';
                        btn.title = 'Maximize Member';
                        btn.onclick = function() { toggleMaximize(member, btn, 'Member'); };
                        member.insertBefore(btn, member.firstChild);
                    }
                });

                console.log('Maximize buttons added to DJINN panels');
            }, 1000); // Wait for DOM to fully load
        }

        function toggleMaximize(panel, btn, title) {
            if (panel.classList.contains('panel-maximized')) {
                // Restore panel
                panel.classList.remove('panel-maximized');
                document.body.classList.remove('has-maximized-panel');
                btn.innerHTML = '‚õ∂';
                btn.title = `Maximize ${title}`;
                
                // Reset any inline styles that might have been added
                panel.style.display = '';
                panel.style.position = '';
                panel.style.zIndex = '';

                // PRESERVE EXTENDED ANALYSIS SIZING - DO NOT RESET
                const extendedAnalysisEl = document.getElementById('extendedAnalysisContent');
                if (extendedAnalysisEl) {
                    extendedAnalysisEl.style.setProperty('flex', '1', 'important');
                    extendedAnalysisEl.style.setProperty('min-height', '400px', 'important');
                    extendedAnalysisEl.style.setProperty('max-height', 'none', 'important');
                    extendedAnalysisEl.style.setProperty('height', '100%', 'important');
                    extendedAnalysisEl.style.setProperty('width', '100%', 'important');
                }
                
                // Show all panels
                document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .canvas-surveillance-extended, .djinn-header, .djinn-controls').forEach(p => {
                    p.style.display = '';
                    p.style.position = '';
                    p.style.zIndex = '';
                });
                
                // Show and reset council containers
                document.querySelectorAll('.council-left, .council-right').forEach(c => {
                    c.style.display = '';
                    c.style.position = '';
                    c.style.zIndex = '';
                    c.classList.remove('has-maximized-child');
                });
                
                // Show all council members
                document.querySelectorAll('.council-member').forEach(m => {
                    m.style.display = '';
                    m.style.position = '';
                    m.style.zIndex = '';
                });

                // Restore NEW indicators when restored
                const newIndicators = panel.querySelectorAll('.new-indicator');
                newIndicators.forEach(indicator => {
                    indicator.style.display = '';
                });
                
                // Restore scroll position
                if (panel.savedScrollTop !== undefined) {
                    const scrollable = panel.querySelector('.data-feed, .member-content, textarea');
                    if (scrollable) {
                        scrollable.scrollTop = panel.savedScrollTop;
                    }
                }
            } else {
                // Save scroll position
                const scrollable = panel.querySelector('.data-feed, .member-content, textarea');
                if (scrollable) {
                    panel.savedScrollTop = scrollable.scrollTop;
                }
                
                // Maximize panel
                panel.classList.add('panel-maximized');
                document.body.classList.add('has-maximized-panel');
                btn.innerHTML = '‚õ∑';
                btn.title = `Restore ${title}`;

                // Hide NEW indicators when maximized
                const newIndicators = panel.querySelectorAll('.new-indicator');
                newIndicators.forEach(indicator => {
                    indicator.style.display = 'none';
                });
                
                // If maximizing a council member, ensure it's visible
                if (panel.classList.contains('council-member')) {
                    // Ensure the panel itself is displayed properly
                    panel.style.display = 'flex';
                    panel.style.flexDirection = 'column';
                    
                    // Make member content visible and properly sized
                    const memberContent = panel.querySelector('.member-content');
                    if (memberContent) {
                        memberContent.style.display = 'block';
                        memberContent.style.visibility = 'visible';
                        memberContent.style.flex = '1';
                    }
                    
                    // Make header visible
                    const memberHeader = panel.querySelector('.member-header');
                    if (memberHeader) {
                        memberHeader.style.display = 'flex';
                        memberHeader.style.visibility = 'visible';
                    }
                    
                    // Hide other panels but keep parent container
                    document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .canvas-surveillance-extended, .djinn-header, .djinn-controls').forEach(p => {
                        p.style.display = 'none';
                    });
                    
                    // Hide other council containers
                    document.querySelectorAll('.council-left, .council-right').forEach(c => {
                        if (!c.contains(panel)) {
                            c.style.display = 'none';
                        } else {
                            // Mark parent as having maximized child
                            c.classList.add('has-maximized-child');
                        }
                    });
                    
                    // Hide other council members
                    document.querySelectorAll('.council-member').forEach(m => {
                        if (m !== panel) {
                            m.style.display = 'none';
                        }
                    });
                } else {
                    // Normal panel maximize behavior
                    document.querySelectorAll('.canvas-surveillance, .council-consensus, .intelligence-report, .canvas-surveillance-extended, .djinn-header, .djinn-controls').forEach(p => {
                        if (p !== panel) {
                            p.style.display = 'none';
                        }
                    });
                    
                    // Hide council containers for non-member panels
                    document.querySelectorAll('.council-left, .council-right').forEach(c => {
                        c.style.display = 'none';
                    });
                }
            }
        }

        // ========================================
        // DIFFERENTIAL ANALYSIS ENGINE
        // ========================================

        // Enhanced canvas evolution tracking
        const canvasEvolutionTracker = {
            history: [],
            maxHistorySize: 50,
            lastAnalysis: null,

            // Store canvas state snapshot
            snapshot: function(content, timestamp = Date.now()) {
                const snapshot = {
                    timestamp,
                    content,
                    hash: this.hashContent(content),
                    metrics: this.calculateMetrics(content),
                    changes: this.lastAnalysis ? this.calculateChanges(this.lastAnalysis, content) : null
                };

                this.history.unshift(snapshot);

                // Maintain history size limit
                if (this.history.length > this.maxHistorySize) {
                    this.history = this.history.slice(0, this.maxHistorySize);
                }

                this.lastAnalysis = snapshot;
                return snapshot;
            },

            // Calculate comprehensive content metrics
            calculateMetrics: function(content) {
                const words = content.trim().split(/\s+/).filter(w => w.length > 0);
                const lines = content.split('\n');
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim().length > 0);

                return {
                    characters: content.length,
                    words: words.length,
                    lines: lines.length,
                    sentences: sentences.length,
                    paragraphs: paragraphs.length,
                    avgWordLength: words.length > 0 ? (words.join('').length / words.length).toFixed(1) : 0,
                    avgSentenceLength: sentences.length > 0 ? (words.length / sentences.length).toFixed(1) : 0,
                    complexity: this.calculateComplexity(content)
                };
            },

            // Calculate detailed changes between two content states
            calculateChanges: function(previousSnapshot, currentContent) {
                const prevContent = previousSnapshot.content;
                const changes = {
                    additions: 0,
                    deletions: 0,
                    modifications: 0,
                    netChange: currentContent.length - prevContent.length,
                    timeDelta: Date.now() - previousSnapshot.timestamp
                };

                // Simple diff analysis (can be enhanced with more sophisticated algorithms)
                const prevWords = prevContent.split(/\s+/);
                const currWords = currentContent.split(/\s+/);

                // Calculate word-level changes
                const addedWords = currWords.filter(word => !prevWords.includes(word));
                const removedWords = prevWords.filter(word => !currWords.includes(word));

                changes.additions = addedWords.length;
                changes.deletions = removedWords.length;
                changes.modifications = Math.abs(changes.netChange) - (changes.additions + changes.deletions);

                // Calculate change velocity (characters per minute)
                changes.velocity = changes.timeDelta > 0 ?
                    (Math.abs(changes.netChange) / (changes.timeDelta / 60000)).toFixed(2) : 0;

                return changes;
            },

            // Calculate content complexity score
            calculateComplexity: function(content) {
                if (!content || content.length === 0) return 0;

                const words = content.split(/\s+/).filter(w => w.length > 0);
                const uniqueWords = new Set(words.map(w => w.toLowerCase()));
                const avgWordLength = words.length > 0 ? words.join('').length / words.length : 0;
                const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);

                // Complexity factors
                const vocabularyRichness = uniqueWords.size / words.length;
                const sentenceVariability = sentences.length > 1 ?
                    this.calculateStandardDeviation(sentences.map(s => s.trim().split(/\s+/).length)) : 0;
                const structuralDensity = (content.match(/[\n\r]/g) || []).length / content.length;

                return ((vocabularyRichness * 0.4) + (sentenceVariability * 0.3) + (structuralDensity * 0.3)).toFixed(3);
            },

            // Calculate standard deviation for sentence variability
            calculateStandardDeviation: function(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const squareDiffs = values.map(value => Math.pow(value - mean, 2));
                const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
                return Math.sqrt(avgSquareDiff);
            },

            // Generate evolution insights
            generateInsights: function() {
                if (this.history.length < 2) return null;

                const recent = this.history.slice(0, 5); // Last 5 snapshots
                const insights = {
                    trend: this.analyzeTrend(recent),
                    patterns: this.identifyPatterns(recent),
                    anomalies: this.detectAnomalies(recent),
                    predictions: this.generatePredictions(recent)
                };

                return insights;
            },

            // Analyze content evolution trends
            analyzeTrend: function(recentSnapshots) {
                if (recentSnapshots.length < 2) return 'insufficient_data';

                const changes = recentSnapshots.slice(0, -1).map((snapshot, i) =>
                    snapshot.changes ? snapshot.changes.netChange : 0
                );

                const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
                const velocities = changes.map(change => Math.abs(change));

                if (avgChange > 50) return 'expanding';
                if (avgChange < -50) return 'contracting';
                if (velocities.every(v => v < 10)) return 'stable';
                return 'evolving';
            },

            // Identify evolution patterns
            identifyPatterns: function(recentSnapshots) {
                const patterns = [];

                // Check for cyclical patterns
                const lengths = recentSnapshots.map(s => s.metrics.characters);
                if (lengths.length >= 4) {
                    const diffs = lengths.slice(1).map((len, i) => len - lengths[i]);
                    if (diffs.every(diff => Math.abs(diff) < 20)) {
                        patterns.push('stable_growth');
                    }
                }

                // Check for burst activity
                const velocities = recentSnapshots
                    .filter(s => s.changes)
                    .map(s => parseFloat(s.changes.velocity));

                if (velocities.some(v => v > 100)) {
                    patterns.push('burst_activity');
                }

                return patterns;
            },

            // Detect anomalous changes
            detectAnomalies: function(recentSnapshots) {
                if (recentSnapshots.length < 3) return [];

                const changes = recentSnapshots
                    .filter(s => s.changes)
                    .map(s => Math.abs(s.changes.netChange));

                if (changes.length === 0) return [];

                const mean = changes.reduce((a, b) => a + b, 0) / changes.length;
                const stdDev = Math.sqrt(
                    changes.map(change => Math.pow(change - mean, 2)).reduce((a, b) => a + b, 0) / changes.length
                );

                return changes
                    .map((change, i) => ({ change, index: i }))
                    .filter(item => Math.abs(item.change - mean) > (2 * stdDev))
                    .map(item => `Anomalous change at snapshot ${item.index}: ${item.change} characters`);
            },

            // Generate evolution predictions
            generatePredictions: function(recentSnapshots) {
                if (recentSnapshots.length < 3) return null;

                const trends = recentSnapshots.slice(0, 3).map(s => ({
                    length: s.metrics.characters,
                    velocity: s.changes ? parseFloat(s.changes.velocity) : 0
                }));

                const avgVelocity = trends.reduce((sum, t) => sum + t.velocity, 0) / trends.length;
                const predictedLength = trends[0].length + (avgVelocity * 5); // 5 minute prediction

                return {
                    predictedLength: Math.max(0, Math.round(predictedLength)),
                    confidence: this.calculatePredictionConfidence(trends),
                    timeHorizon: '5_minutes'
                };
            },

            // Calculate prediction confidence
            calculatePredictionConfidence: function(trends) {
                const velocities = trends.map(t => t.velocity);
                const mean = velocities.reduce((a, b) => a + b, 0) / velocities.length;
                const variance = velocities.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / velocities.length;

                // Lower variance = higher confidence
                return Math.max(0, Math.min(100, 100 - (variance / 10)));
            },

            // Simple content hashing for change detection
            hashContent: function(content) {
                let hash = 0;
                for (let i = 0; i < content.length; i++) {
                    const char = content.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString();
            }
        };

        // ========================================
        // CANVAS SURVEILLANCE FUNCTIONS
        // ========================================

        function updateCanvasMonitor() {
            try {
                // Get ALL data sources for comprehensive monitoring
                let canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';

                if (!canvasContent) canvasContent = '';

                // ========================================
                // INTEGRATE DIFFERENTIAL ANALYSIS
                // ========================================

                // Create evolution snapshot
                const currentSnapshot = canvasEvolutionTracker.snapshot(canvasContent);

                // Generate evolution insights
                const evolutionInsights = canvasEvolutionTracker.generateInsights();

                // Calculate metrics with enhanced analysis
                const words = canvasContent.trim().split(/\s+/).filter(w => w.length > 0);
                const lines = canvasContent.split('\n');

                // Get last modified timestamp
                const lastModified = localStorage.getItem('sovereign_canvas_timestamp');
                const modified = lastModified ? new Date(lastModified).toLocaleTimeString() : 'Never';

                // ========================================
                // ENHANCED METRICS CALCULATION
                // ========================================

                // Calculate evolution metrics
                const evolutionMetrics = {
                    trend: evolutionInsights ? evolutionInsights.trend : 'analyzing',
                    patterns: evolutionInsights ? evolutionInsights.patterns.join(', ') : 'none_detected',
                    anomalyCount: evolutionInsights ? evolutionInsights.anomalies.length : 0,
                    historyDepth: canvasEvolutionTracker.history.length,
                    avgChangeVelocity: canvasEvolutionTracker.history.length > 1 ?
                        canvasEvolutionTracker.history
                            .filter(s => s.changes)
                            .reduce((sum, s) => sum + parseFloat(s.changes.velocity), 0) /
                        canvasEvolutionTracker.history.filter(s => s.changes).length : 0
                };

                // Update UI elements with enhanced metrics
                const monitorElements = {
                    'canvasMonitorLength': canvasContent.length,
                    'canvasMonitorWords': words.length,
                    'canvasMonitorLines': lines.length
                };

                Object.entries(monitorElements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) element.textContent = value;
                });

                // Calculate additional verified metrics from real data
                const aiMemoryObj = JSON.parse(aiMemory);
                const totalMemoryItems = Object.values(aiMemoryObj).reduce((total, system) => {
                    return total + (system?.conversationHistory?.length || 0) + (system?.keyInsights?.length || 0);
                }, 0);

                // Calculate activity level based on actual content
                const activityLevel = canvasContent.length > 0 ? (words.length > 50 ? 'HIGH' : 'MEDIUM') : 'LOW';

                // Calculate confidence average from actual AI feeds data
                let confidenceAvg = '--%';
                if (aiFeeds.length > 0) {
                    const recentFeeds = aiFeeds.slice(-5); // Use last 5 feeds for average
                    let totalConfidence = 0;
                    let confidenceCount = 0;

                    recentFeeds.forEach(feed => {
                        Object.keys(feed).forEach(key => {
                            if (key !== 'timestamp' && feed[key] && typeof feed[key] === 'object' && feed[key].confidence) {
                                totalConfidence += feed[key].confidence;
                                confidenceCount++;
                            }
                        });
                    });

                    if (confidenceCount > 0) {
                        confidenceAvg = `${Math.round((totalConfidence / confidenceCount) * 100)}%`;
                    }
                }

                // Update metrics grid elements with all verified data
                const metricsElements = {
                    'canvasSize': `${canvasContent.length} chars`,
                    'memoryCount': `${totalMemoryItems} items`,
                    'feedCount': aiFeeds.length,
                    'confidenceAvg': confidenceAvg,
                    'canvasWords': words.length,
                    'canvasLines': lines.length,
                    'canvasModified': modified,
                    'activityLevel': activityLevel,
                    'evolutionTrend': evolutionMetrics.trend.toUpperCase(),
                    'changeVelocity': `${evolutionMetrics.avgChangeVelocity.toFixed(1)} chars/min`,
                    'historyDepth': `${evolutionMetrics.historyDepth} snapshots`,
                    'patternsDetected': evolutionMetrics.patterns || 'analyzing'
                };

                Object.entries(metricsElements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        // Only update if the value has actually changed to prevent duplicate displays
                        if (element.textContent !== value) {
                            element.textContent = value;
                        }
                    } else {
                        console.warn(`üìä Surveillance element not found: ${id}`);
                    }
                });

                console.log(`üìä Updated ${Object.keys(metricsElements).length} surveillance metrics`);

                // Update memory statistical readout
                updateCompactMemoryStatus();

                // Update canvas monitor last modified timestamp
                const monitorModifiedElement = document.getElementById('canvasMonitorModified');
                if (monitorModifiedElement) monitorModifiedElement.textContent = modified;

                // ========================================
                // EVOLUTION INSIGHTS DISPLAY
                // ========================================

                // Update evolution insights panel if it exists
                const insightsElement = document.getElementById('evolutionInsights');
                if (insightsElement && evolutionInsights) {
                    let insightsHTML = '<strong>üìä EVOLUTION ANALYSIS</strong>\n\n';

                    // Trend analysis
                    insightsHTML += `**Trend:** ${evolutionInsights.trend.toUpperCase()}\n`;

                    // Pattern detection
                    if (evolutionInsights.patterns.length > 0) {
                        insightsHTML += `**Patterns:** ${evolutionInsights.patterns.join(', ')}\n`;
                    }

                    // Anomalies
                    if (evolutionInsights.anomalies.length > 0) {
                        insightsHTML += `**Anomalies:** ${evolutionInsights.anomalies.length} detected\n`;
                        evolutionInsights.anomalies.slice(0, 2).forEach(anomaly => {
                            insightsHTML += `‚Ä¢ ${anomaly}\n`;
                        });
                    }

                    // Predictions
                    if (evolutionInsights.predictions) {
                        const pred = evolutionInsights.predictions;
                        insightsHTML += `**Prediction:** ${pred.predictedLength} chars in ${pred.timeHorizon.replace('_', ' ')} (${pred.confidence.toFixed(1)}% confidence)\n`;
                    }

                    insightsElement.innerHTML = insightsHTML.replace(/\n/g, '<br>');
                }

                // ========================================
                // UPDATE CORRELATION INSIGHTS
                // ========================================

                // Update correlation insights display
                const correlationInsights = crossSystemCorrelationEngine.getCorrelationInsights();
                const correlationElement = document.getElementById('correlationInsights');
                if (correlationElement && correlationInsights) {
                    let insightsHTML = `**Consensus:** ${correlationInsights.consensusStrength}\n`;
                    insightsHTML += `**Harmony:** ${correlationInsights.systemHarmony}\n`;
                    insightsHTML += `**Patterns:** ${correlationInsights.emergingPatterns} emerging\n`;
                    if (correlationInsights.activeConflicts > 0) {
                        insightsHTML += `**Conflicts:** ${correlationInsights.activeConflicts} detected\n`;
                    }
                    if (correlationInsights.topCorrelations.length > 0) {
                        insightsHTML += `**Top Correlation:** ${correlationInsights.topCorrelations[0].system} ‚Üî ${correlationInsights.topCorrelations[0].member}\n`;
                    }
                    insightsHTML += `**Last Analysis:** ${correlationInsights.lastAnalysis}\n`;
                    correlationElement.innerHTML = insightsHTML.replace(/\n/g, '<br>');
                }

                // ========================================
                // UPDATE MEMORY OPTIMIZATION METRICS
                // ========================================

                // Update memory optimization display
                const memoryMetrics = advancedMemoryOrchestrator.getOptimizationMetrics();
                const memoryMetricsElement = document.getElementById('memoryOptimizationMetrics');
                if (memoryMetricsElement) {
                    let metricsHTML = `**Efficiency:** ${memoryMetrics.memoryEfficiency}\n`;
                    metricsHTML += `**Fingerprints:** ${memoryMetrics.totalFingerprints}\n`;
                    metricsHTML += `**Deduplication Savings:** ${memoryMetrics.deduplicationSavings} bytes\n`;
                    if (memoryMetrics.optimizationOpportunities > 0) {
                        metricsHTML += `**Opportunities:** ${memoryMetrics.optimizationOpportunities} available\n`;
                    }
                    memoryMetricsElement.innerHTML = metricsHTML.replace(/\n/g, '<br>');
                }

                // ========================================
                // CONTENT PREVIEW WITH EVOLUTION MARKERS
                // ========================================

                // Update content preview with actual canvas content - NO TRUNCATION
                let preview = '';
                if (canvasContent.length > 0) {
                    preview = canvasContent; // Show complete content always
                } else {
                    preview = 'No canvas content detected yet...';
                }

                const previewElement = document.getElementById('canvasContentPreview');
                if (previewElement) {
                    previewElement.textContent = preview;
                }

                // Update global currentAIMemory for status displays
                currentAIMemory = aiMemory;

                // Update compact memory status with new AI memory data
    
                // Update synthesis monitoring with actual synthesis content
                updateSynthesisMonitor(synthesisContent);

                if (canvasContent.length > 0) {
                    console.log(`üìä Canvas monitor updated: ${canvasContent.length} chars, ${words.length} words, ${lines.length} lines`);
                    console.log(`üîç Full canvas content received and displayed - no truncation`);
                }
            } catch (error) {
                console.error('Error updating canvas monitor:', error);
            }
        }

        // Track last synthesis content to prevent spam updates
        let lastSynthesisContent = '';

        // Update synthesis monitor with actual synthesis content data
        function updateSynthesisMonitor(synthesisContent) {
            try {
                // Always fetch fresh synthesis content from localStorage to prevent caching issues
                const freshSynthesisContent = localStorage.getItem('synthesis_canvas_content') || '';
                const contentToUse = freshSynthesisContent || synthesisContent || '';

                // Prevent spam updates - only update if content actually changed
                if (contentToUse === lastSynthesisContent) {
                    return; // No change, skip update
                }
                lastSynthesisContent = contentToUse;

                // Update existing synthesis UI elements with content data
                const synthesisRoundEl = document.getElementById('synthesisRound');
                const autoSynthesisEl = document.getElementById('autoSynthesisStatus');
                const agentsCompleteEl = document.getElementById('agentsComplete');
                const roundsCompletedEl = document.getElementById('roundsCompleted');
                const extendedAnalysisEl = document.getElementById('extendedAnalysisContent');

                if (contentToUse && contentToUse.length > 0) {
                    // Update synthesis status to show content is available
                    if (autoSynthesisEl) {
                        autoSynthesisEl.textContent = 'Content Available';
                        autoSynthesisEl.style.color = '#00ff88';
                        autoSynthesisEl.title = `Synthesis content: ${contentToUse.length} characters`;
                    }

                    // Update synthesis round to show content status
                    if (synthesisRoundEl) {
                        synthesisRoundEl.textContent = 'Content Ready';
                        synthesisRoundEl.style.color = '#00ff88';
                    }

                    // Update extended analysis content with synthesis insights (preserve scroll position)
                    if (extendedAnalysisEl) {
                        const timestamp = new Date().toLocaleTimeString();
                        const newContent = `<strong>üìä Latest Synthesis Analysis (${timestamp})</strong>\n\n${contentToUse}\n\n<strong>üîó Cross-System Correlations:</strong>\n‚Ä¢ AI agent responses integrated\n‚Ä¢ Memory patterns analyzed\n‚Ä¢ Evolution trends detected\n‚Ä¢ Pattern recognition active`;

                        // Only update if content actually changed to prevent scroll reset
                        if (extendedAnalysisEl.innerHTML !== newContent) {
                            const scrollTop = extendedAnalysisEl.scrollTop;
                            extendedAnalysisEl.innerHTML = newContent;
                            // Restore scroll position after update
                            extendedAnalysisEl.scrollTop = scrollTop;
                            // Force maintain sizing after content update - use !important values
                            extendedAnalysisEl.style.setProperty('flex', '1', 'important');
                            extendedAnalysisEl.style.setProperty('min-height', '400px', 'important');
                            extendedAnalysisEl.style.setProperty('max-height', 'none', 'important');
                            extendedAnalysisEl.style.setProperty('height', '100%', 'important');
                            extendedAnalysisEl.style.setProperty('width', '100%', 'important');
                        }

                        logDjinnEvent('document', `Advanced Analysis updated - ${contentToUse.length} chars of synthesis content`);
                    }

                    console.log(`üîç Synthesis monitor updated: ${contentToUse.length} characters of synthesis content available`);
                } else {
                    // No synthesis content - show waiting status
                    if (autoSynthesisEl) {
                        autoSynthesisEl.textContent = 'Waiting for Content';
                        autoSynthesisEl.style.color = '#ffaa00';
                        autoSynthesisEl.title = 'No synthesis content available yet';
                    }

                    if (synthesisRoundEl) {
                        synthesisRoundEl.textContent = 'Ready';
                        synthesisRoundEl.style.color = '#4ecdc4';
                    }

                    // Update extended analysis content with waiting message (preserve scroll position)
                    if (extendedAnalysisEl) {
                        const newContent = 'Advanced correlation analysis and system insights will appear here as synthesis reports are generated and processed by the DJINN council.\n\nWaiting for AI agents to complete their analysis rounds...';

                        if (extendedAnalysisEl.innerHTML !== newContent) {
                            const scrollTop = extendedAnalysisEl.scrollTop;
                            extendedAnalysisEl.innerHTML = newContent;
                            extendedAnalysisEl.scrollTop = scrollTop;
                            // Force maintain sizing after content update - use !important values
                            extendedAnalysisEl.style.setProperty('flex', '1', 'important');
                            extendedAnalysisEl.style.setProperty('min-height', '400px', 'important');
                            extendedAnalysisEl.style.setProperty('max-height', 'none', 'important');
                            extendedAnalysisEl.style.setProperty('height', '100%', 'important');
                            extendedAnalysisEl.style.setProperty('width', '100%', 'important');
                        }
                    }

                    console.log(`üîç Synthesis monitor: No synthesis content available`);
                }

                // Rounds completed is handled by updateAllSurveillanceMetrics() - avoid conflicts
                // const evolutionHistory = JSON.parse(localStorage.getItem('ai_evolution_history') || '[]');
                // if (roundsCompletedEl) {
                //     roundsCompletedEl.textContent = evolutionHistory.length;
                // }

            } catch (error) {
                console.error('Error updating synthesis monitor:', error);
            }
        }

        function updateAIFeedsMonitor(aiFeeds, aiMemory) {
            try {
                // Monitor AI observer feeds
                const feedCount = aiFeeds.length;
                const feedElement = document.getElementById('activeFeedCount');
                if (feedElement) feedElement.textContent = feedCount;

                // Parse and display AI memory status
                let totalMemoryItems = 0;
                let memoryStatusHTML = '<div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">';
                memoryStatusHTML += '<strong>üß† AI Memory Status:</strong><br>';

                try {
                    const parsedMemory = JSON.parse(aiMemory);
                    if (parsedMemory && typeof parsedMemory === 'object') {
                        Object.keys(parsedMemory).forEach(system => {
                            const memory = parsedMemory[system];
                            const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                            const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                            const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                            totalMemoryItems += memoryCount + insightCount;
                            memoryStatusHTML += `${system.toUpperCase()}: ${hasMemory ? '‚úÖ' : '‚è≥'} (${memoryCount} responses, ${insightCount} insights)<br>`;
                        });
                    }
                    // Store for compact display
                    currentAIMemory = aiMemory;
                } catch (e) {
                    console.log('Error parsing AI memory:', e);
                    memoryStatusHTML += 'Error parsing memory data<br>';
                }
                memoryStatusHTML += '</div>';

                const memoryElement = document.getElementById('memoryCount');
                if (memoryElement) memoryElement.textContent = `${totalMemoryItems} items`;

                // AI Memory Status moved to compact display - no longer in Echo & Memory panel

            } catch (error) {
                console.error('Error updating AI feeds monitor:', error);
            }
        }

        function updateCorrelativeAnalysisDisplay(report) {
            try {
                // Update correlative analysis insights panel
                const insightsElement = document.getElementById('correlativeAnalysisInsights');
                if (insightsElement) {
                    let insightsHTML = '<strong>üî¨ DJINN COUNCIL CORRELATIVE ANALYSIS</strong>\n\n';

                    // Analysis summary
                    insightsHTML += `**Analysis Cycle:** ${report.analysisCycle}\n`;
                    insightsHTML += `**Trigger:** ${report.synthesisTrigger}\n`;
                    insightsHTML += `**Correlation Depth:** ${report.correlationDepth.toFixed(2)}\n\n`;

                    // Deep insights
                    if (report.deepInsights && report.deepInsights.keyFindings) {
                        insightsHTML += '**Key Findings:**\n';
                        report.deepInsights.keyFindings.slice(0, 3).forEach(finding => {
                            insightsHTML += `‚Ä¢ ${finding}\n`;
                        });
                        insightsHTML += '\n';
                    }

                    // Recommendations
                    if (report.recommendations && report.recommendations.length > 0) {
                        insightsHTML += '**Recommendations:**\n';
                        report.recommendations.slice(0, 2).forEach(rec => {
                            insightsHTML += `‚Ä¢ ${rec}\n`;
                        });
                    }

                    insightsElement.innerHTML = insightsHTML.replace(/\n/g, '<br>');
                }

                // Update analysis status
                const statusElement = document.getElementById('analysisStatus');
                if (statusElement) {
                    statusElement.textContent = `Last Analysis: ${new Date(report.timestamp).toLocaleTimeString()}`;
                }

                // Update report count
                const reportCountElement = document.getElementById('reportCount');
                if (reportCountElement) {
                    reportCountElement.textContent = surveillanceState.reportCount;
                }

                console.log('üìä Correlative analysis display updated');

            } catch (error) {
                console.error('Error updating correlative analysis display:', error);
            }
        }

        function initializeSurveillance() {
            console.log('üßû‚Äç‚ôÇÔ∏è DJINN Council Shadow Governance initializing...');

            // Initialize persistent surveillance state
            initializePersistentSurveillance();

            // Canvas monitoring disabled - event-driven only
            // Initialize canvas surveillance
            startCanvasMonitoring();

            // Initialize UI
            updateTimestamp();

            // Start polling
            startPolling();

            // Listen for localStorage changes from canvas page for instant sync
            window.addEventListener('storage', function(event) {
                if (event.key === 'sovereign_canvas_content' || event.key === 'ai_memory_state' || event.key === 'synthesis_canvas_content') {
                    console.log(`üîÑ ${event.key} changed - updating surveillance immediately`);
                    setTimeout(() => {
                        checkCanvasState();
                    }, 100);
                }

                // Add listener for canvas synthesis status updates
                if (event.key === 'canvas_synthesis_status') {
                    console.log(`üìä Canvas synthesis status updated - refreshing metrics immediately`);
                    setTimeout(() => {
                        updateSynthesisStatusFromLocalStorage();
                    }, 50);
                }

                // Add listener for synthesis progress updates
                if (event.key === 'synthesis_progress') {
                    console.log(`üîÑ Synthesis progress updated`);
                    setTimeout(() => {
                        updateSynthesisProgressStatus();
                    }, 50);
                }
            });

            console.log('‚úÖ DJINN Council operational with real-time cross-window sync');
        }

        // Function to update synthesis status from localStorage immediately
        function updateSynthesisStatusFromLocalStorage() {
            try {
                // Read LIVE synthesis status directly from synthesis board, not cached status
                const synthesisProgress = localStorage.getItem('synthesis_progress') || 'Ready';
                const synthesisStatus = JSON.parse(localStorage.getItem('canvas_synthesis_status') || '{}');

                // Rounds completed is handled by updateAllSurveillanceMetrics() - avoid conflicts
                // const roundsCompleted = JSON.parse(localStorage.getItem('ai_evolution_history') || '[]').length;
                // document.getElementById('roundsCompleted').textContent = roundsCompleted;

                // Update current round status from canvas communication
                const synthesisRoundEl = document.getElementById('synthesisRound');
                const agentsCompleteEl = document.getElementById('agentsComplete');
                const autoSynthesisEl = document.getElementById('autoSynthesisStatus');

                // Update status based on LIVE synthesis progress, not cached status
                if (autoSynthesisEl) {
                    if (synthesisProgress === 'Synthesizing' || synthesisProgress === 'Processing') {
                        autoSynthesisEl.textContent = 'Synthesizing';
                        autoSynthesisEl.style.color = '#ffaa00';
                    } else if (synthesisProgress === 'Complete' || synthesisProgress === 'Ready') {
                        autoSynthesisEl.textContent = 'Ready';
                        autoSynthesisEl.style.color = '#4ecdc4';
                    } else {
                        autoSynthesisEl.textContent = 'Waiting';
                        autoSynthesisEl.style.color = '#666666';
                    }
                }

                // Update round and agents from actual status
                if (synthesisStatus.currentRound) {
                    // Extract round number properly - handle corrupted timestamp formats
                    let roundNum;
                    const currentRoundStr = String(synthesisStatus.currentRound);

                    if (currentRoundStr.includes('_')) {
                        const parts = currentRoundStr.split('_');
                        roundNum = parts[parts.length - 1]; // Take the last part
                    } else {
                        roundNum = currentRoundStr;
                    }

                    // Fix corrupted timestamp data - if more than 4 digits, it's corrupted
                    if (roundNum && roundNum.length > 4) {
                        // Use a simple counter based on completed systems as fallback
                        const completedSystems = synthesisStatus.completedSystems || 0;
                        if (completedSystems > 0) {
                            roundNum = Math.ceil(completedSystems / 5) || 1; // Estimate round based on completed systems
                        } else {
                            roundNum = 1; // Default to round 1 for corrupted data
                        }
                    }

                    // Ensure roundNum is a reasonable number
                    if (isNaN(roundNum) || roundNum < 1) {
                        roundNum = 1;
                    }

                    if (synthesisRoundEl) synthesisRoundEl.textContent = `Round ${roundNum}`;
                    if (agentsCompleteEl) agentsCompleteEl.textContent = `${synthesisStatus.completedSystems || 0}/5`;
                } else {
                    if (synthesisRoundEl) synthesisRoundEl.textContent = 'Ready';
                    if (agentsCompleteEl) agentsCompleteEl.textContent = '0/5';
                }

                console.log(`üìä Synthesis status updated: ${synthesisStatus.completedSystems || 0}/5 systems complete`);

            } catch (error) {
                console.error('Error updating synthesis status from localStorage:', error);
            }
        }

        // Aggressive throttling for synthesis progress status to prevent scroll resets
        let lastSynthesisUpdate = 0;
        const SYNTHESIS_UPDATE_THROTTLE = 10000; // Only allow updates every 10 seconds
        let userScrolling = false;
        let scrollTimeout;


        // Function to update synthesis progress status
        function updateSynthesisProgressStatus() {
            // Skip updates if user is actively scrolling
            if (userScrolling) {
                console.log('ü§ê Skipping analysis update - user scrolling');
                return;
            }

            // Aggressive throttle to prevent constant scroll resets
            const now = Date.now();
            if (now - lastSynthesisUpdate < SYNTHESIS_UPDATE_THROTTLE) {
                return; // Skip update if called too recently
            }
            lastSynthesisUpdate = now;

            try {
                // Read the actual synthesis status from localStorage - be reactive, not anticipatory
                const canvasSynthesisStatus = JSON.parse(localStorage.getItem('canvas_synthesis_status') || '{}');
                const progressStatus = localStorage.getItem('synthesis_progress') || 'Ready';
                const progressEl = document.getElementById('synthesisProgress');

                // Check if synthesis is actually running based on REAL state
                let isActuallySynthesizing = false;
                let isCanvasActive = false;

                // Check various indicators of canvas activity
                const synthesisTriggered = canvasSynthesisStatus.synthesisTriggered === true;
                const isActive = canvasSynthesisStatus.isActive === true;
                const completedSystems = canvasSynthesisStatus.completedSystems || 0;
                const allSystemsComplete = completedSystems >= 5;

                // Check for active canvas work by looking at recent localStorage activity
                const recentCanvasActivity = localStorage.getItem('canvas_content');
                const lastActivity = localStorage.getItem('last_canvas_activity');
                const aiEvolutionHistory = JSON.parse(localStorage.getItem('ai_evolution_history') || '[]');
                const recentEvolution = aiEvolutionHistory.length > 0 &&
                    (Date.now() - new Date(aiEvolutionHistory[aiEvolutionHistory.length - 1].timestamp).getTime()) < 30000; // 30 seconds

                // Canvas is considered active if:
                isCanvasActive = recentCanvasActivity && recentCanvasActivity.length > 50 && (
                    recentEvolution || // Recent AI evolution activity
                    progressStatus.includes('SYNTHESIZING') || progressStatus.includes('Synthesizing') ||
                    synthesisTriggered || // Synthesis was triggered
                    !allSystemsComplete // Systems are still working
                );

                // Check for actual synthesis process - only synthesizing if explicitly triggered AND all systems complete
                isActuallySynthesizing = (synthesisTriggered && isActive && allSystemsComplete) ||
                                       (progressStatus.includes('SYNTHESIZING') || progressStatus.includes('Synthesizing'));

                if (progressEl) {
                    // Be REACTIVE to actual state, not cached/stale data
                    if (isActuallySynthesizing) {
                        progressEl.textContent = 'üîÑ SYNTHESIZING...';
                        progressEl.style.color = '#ffd93d';
                        progressEl.style.animation = 'pulse 1s infinite';
                    } else if (progressStatus.includes('ERROR') || progressStatus.includes('Error')) {
                        progressEl.textContent = '‚ùå ERROR';
                        progressEl.style.color = '#ff6b6b';
                        progressEl.style.animation = 'none';
                    } else {
                        // Default to READY when not actively synthesizing
                        progressEl.textContent = '‚úÖ READY';
                        progressEl.style.color = '#00ff88';
                        progressEl.style.animation = 'none';
                    }
                }

            } catch (error) {
                console.error('Error updating synthesis progress status:', error);
                // Fallback to safe state
                const progressEl = document.getElementById('synthesisProgress');
                if (progressEl) {
                    progressEl.textContent = '‚úÖ READY';
                    progressEl.style.color = '#00ff88';
                    progressEl.style.animation = 'none';
                }
            }
        }

        function startCanvasMonitoring() {
            // Initial check
            checkCanvasState();
            
            // Set up periodic monitoring
            surveillanceState.pollingTimer = setInterval(() => {
                checkCanvasState();
            }, DJINN_CONFIG.POLLING_INTERVAL);
        }

        function checkCanvasState() {
            try {
                // Read ALL data sources for comprehensive monitoring
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                const synthesisContent = localStorage.getItem('synthesis_canvas_content') || '';

                // Update canvas monitor with ALL data sources
                updateCanvasMonitor();

                // Note: updateSynthesisMonitor is already called within updateCanvasMonitor - no duplicate call needed

                // Calculate hashes for change detection
                const canvasHash = hashContent(canvasContent);
                const memoryHash = hashContent(aiMemory);
                const synthesisHash = hashContent(synthesisContent);
                const feedCount = aiFeeds.length;

                // ========================================
                // SYNTHESIS COMPLETION DETECTION & CORRELATIVE ANALYSIS TRIGGER
                // ========================================

                // Detect new synthesis report generation
                if (synthesisHash !== surveillanceState.lastSynthesisHash && synthesisContent.length > 0) {
                    console.log('üéØ SYNTHESIS REPORT GENERATED - Triggering DJINN Council Correlative Analysis');

                    // Reset synthesis analysis trigger flag
                    surveillanceState.synthesisAnalysisTriggered = false;

                    // Trigger comprehensive correlative analysis
                    triggerCorrelativeAnalysis(canvasContent, aiMemory, synthesisContent, aiFeeds);

                    // Update synthesis hash
                    surveillanceState.lastSynthesisHash = synthesisHash;
                }

                // Update UI metrics with null checks
                const canvasSizeEl = document.getElementById('canvasSize');
                if (canvasSizeEl) canvasSizeEl.textContent = `${canvasContent.length} chars`;

                // Calculate actual memory count from conversation history and insights
                let totalMemoryItems = 0;
                let memoryStatusHTML = '<div style="font-size: 10px; color: #666; margin-top: 5px; line-height: 1.2;">';
                memoryStatusHTML += '<strong>üß† AI Memory Status:</strong><br>';

                try {
                    const parsedMemory = JSON.parse(aiMemory);
                    if (parsedMemory && typeof parsedMemory === 'object') {
                        Object.keys(parsedMemory).forEach(system => {
                            const memory = parsedMemory[system];
                            const hasMemory = memory && memory.conversationHistory && memory.conversationHistory.length > 0;
                            const memoryCount = memory && memory.conversationHistory ? memory.conversationHistory.length : 0;
                            const insightCount = memory && memory.keyInsights ? memory.keyInsights.length : 0;

                            totalMemoryItems += memoryCount + insightCount;

                            memoryStatusHTML += `${system.toUpperCase()}: ${hasMemory ? '‚úÖ' : '‚è≥'} (${memoryCount} responses, ${insightCount} insights)<br>`;
                        });
                    }
                } catch (e) {
                    console.log('Error parsing AI memory:', e);
                    memoryStatusHTML += 'Error parsing memory data<br>';
                }
                memoryStatusHTML += '</div>';

                const memoryCountEl = document.getElementById('memoryCount');
                if (memoryCountEl) memoryCountEl.textContent = `${totalMemoryItems} items`;

                const feedCountEl = document.getElementById('feedCount');
                if (feedCountEl) feedCountEl.textContent = feedCount;

                // Calculate and update additional metrics
                const words = canvasContent.split(/\s+/).filter(w => w.length > 0).length;
                const lines = canvasContent.split('\n').length;
                const modified = canvasContent.length > 0 ? new Date().toLocaleTimeString() : 'Never';

                const canvasWordsEl = document.getElementById('canvasWords');
                if (canvasWordsEl) canvasWordsEl.textContent = words;

                const canvasLinesEl = document.getElementById('canvasLines');
                if (canvasLinesEl) canvasLinesEl.textContent = lines;

                const canvasModifiedEl = document.getElementById('canvasModified');
                if (canvasModifiedEl) canvasModifiedEl.textContent = modified;

                // Calculate activity level based on recent changes
                const activityLevel = calculateActivityLevel(canvasContent, feedCount, words);
                const activityLevelEl = document.getElementById('activityLevel');
                if (activityLevelEl) activityLevelEl.textContent = activityLevel;

                // Calculate data density (words per line ratio)
                const dataDensity = lines > 0 ? (words / lines).toFixed(1) : '0.0';
                const dataDensityEl = document.getElementById('dataDensity');
                if (dataDensityEl) dataDensityEl.textContent = dataDensity;

                // Update canvas monitor status
                const monitorStatusEl = document.getElementById('canvasMonitorStatus');
                if (monitorStatusEl) {
                    if (canvasContent.length > 0) {
                        monitorStatusEl.textContent = 'ACTIVE';
                        monitorStatusEl.style.background = 'rgba(0, 255, 136, 0.2)';
                        monitorStatusEl.style.color = '#00ff88';
                    } else {
                        monitorStatusEl.textContent = 'INACTIVE';
                        monitorStatusEl.style.background = 'rgba(102, 102, 102, 0.2)';
                        monitorStatusEl.style.color = '#666';
                    }
                }

                // Calculate average confidence
                if (aiFeeds.length > 0) {
                    const latestFeed = aiFeeds[0];
                    const confidences = Object.values(latestFeed)
                        .filter(v => v && typeof v === 'object' && v.confidence)
                        .map(v => v.confidence);
                    const avgConfidence = confidences.length > 0
                        ? (confidences.reduce((a, b) => a + b, 0) / confidences.length * 100).toFixed(1)
                        : '--';
                    document.getElementById('confidenceAvg').textContent = `${avgConfidence}%`;
                }

                // Update synthesis round status from localStorage
                const evolutionHistory = JSON.parse(localStorage.getItem('ai_evolution_history') || '[]');
                const roundsCompleted = evolutionHistory.length;

                // Update synthesis status using the dedicated function
                updateSynthesisStatusFromLocalStorage();
                updateSynthesisProgressStatus();

                // Detect changes
                let changesDetected = false;
                
                if (canvasHash !== surveillanceState.lastCanvasHash && canvasContent.length > 0) {
                    const sizeDiff = Math.abs(canvasContent.length - (surveillanceState.lastCanvasContent?.length || 0));
                    if (sizeDiff > DJINN_CONFIG.ANALYSIS_THRESHOLD) {
                        changesDetected = true;
                        logSurveillance('üìù Canvas content changed significantly', 'change');
                        // Auto-analysis disabled - event-driven only
                    }
                    surveillanceState.lastCanvasHash = canvasHash;
                    surveillanceState.lastCanvasContent = canvasContent;
                }
                
                if (memoryHash !== surveillanceState.lastMemoryHash) {
                    changesDetected = true;
                    logSurveillance('üß† AI memory updated', 'memory');
                    // Auto-analysis disabled - event-driven only
                    surveillanceState.lastMemoryHash = memoryHash;
                }
                
                if (feedCount > surveillanceState.lastFeedCount) {
                    changesDetected = true;
                    const newFeeds = aiFeeds.slice(0, feedCount - surveillanceState.lastFeedCount);
                    logSurveillance(`üì° ${newFeeds.length} new AI feeds detected`, 'feed');
                    // Auto-analysis disabled - event-driven only
                    surveillanceState.lastFeedCount = feedCount;
                }
                
                if (changesDetected) {
                    surveillanceState.changeCount++;
                    document.getElementById('changeCount').textContent = surveillanceState.changeCount;
                    document.getElementById('canvasStatus').textContent = 'CHANGES DETECTED';

                    // Auto-analysis disabled - event-driven only
                }
                
            } catch (error) {
                console.error('Surveillance error:', error);
                logSurveillance(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        // Update miniature canvas monitor with live canvas data

        // Create miniature HTML representation of canvas content
        // Calculate activity level based on canvas metrics
        function calculateActivityLevel(canvasContent, feedCount, wordCount) {
            const contentLength = canvasContent.length;
            const recencyScore = feedCount > 0 ? Math.min(feedCount * 10, 100) : 0;
            const volumeScore = Math.min(contentLength / 100, 100);
            const densityScore = wordCount > 0 ? Math.min(wordCount / 10, 100) : 0;

            const totalScore = (recencyScore + volumeScore + densityScore) / 3;

            if (totalScore >= 70) return 'HIGH';
            if (totalScore >= 40) return 'MEDIUM';
            if (totalScore >= 10) return 'LOW';
            return 'IDLE';
        }

        // ========================================
        // COUNCIL ANALYSIS SYSTEM
        // ========================================

        function queueAnalysis(eventType, data) {
            logDjinnEvent('analysis', `Analysis queued: ${eventType}`, { queueLength: surveillanceState.analysisQueue.length + 1 });
            surveillanceState.analysisQueue.push({
                id: Date.now(),
                type: eventType,
                data: data,
                timestamp: new Date().toISOString()
            });
            
            updateQueueStatus();
        }

        async function processAnalysisQueue() {
            if (surveillanceState.isAnalyzing || surveillanceState.analysisQueue.length === 0) {
                return;
            }

            logDjinnEvent('analysis', 'Processing analysis queue - council members starting work');
            
            surveillanceState.isAnalyzing = true;
            updateCouncilStatus('ANALYZING');
            
            while (surveillanceState.analysisQueue.length > 0) {
                const analysis = surveillanceState.analysisQueue.shift();
                await performCouncilAnalysis(analysis);
                updateQueueStatus();
            }
            
            surveillanceState.isAnalyzing = false;
            updateCouncilStatus('READY');
        }

        async function performCouncilAnalysis(analysis) {
            console.log(`üîç Council analyzing: ${analysis.type}`);
            
            // Update UI
            document.getElementById('councilIndicator').className = 'indicator indicator-processing';
            
            try {
                // === COLLABORATIVE ITERATIVE ANALYSIS ===
                // Each stage builds on insights from previous stages

                // Stage 1: Initial reconnaissance - Pattern & Wisdom establish foundation
                console.log('üîç Stage 1: Foundation Analysis (Pattern & Wisdom)');
                const stage1 = await Promise.all([
                    queryCouncilMember('pattern', generateCouncilPrompts(analysis).pattern, analysis),
                    queryCouncilMember('wisdom', generateCouncilPrompts(analysis).wisdom, analysis)
                ]);

                await new Promise(resolve => setTimeout(resolve, 800));

                // Stage 2: Cross-pollinated analysis - Paradox & Boundaries build on Stage 1
                console.log('üîÑ Stage 2: Cross-Pollinated Analysis (incorporating Stage 1 insights)');
                const stage1Insights = extractKeyInsights(stage1);
                const enhancedParadoxPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).paradox,
                    stage1Insights,
                    'paradox'
                );
                const enhancedBoundariesPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).boundaries,
                    stage1Insights,
                    'boundaries'
                );

                const stage2 = await Promise.all([
                    queryCouncilMember('paradox', enhancedParadoxPrompt, analysis),
                    queryCouncilMember('boundaries', enhancedBoundariesPrompt, analysis)
                ]);

                await new Promise(resolve => setTimeout(resolve, 800));

                // Stage 3: Synthesis with full council context - Memory incorporates all insights
                console.log('üß† Stage 3: Comprehensive Memory Synthesis');
                const allPriorInsights = extractKeyInsights([...stage1, ...stage2]);
                const enhancedMemoryPrompt = enhancePromptWithInsights(
                    generateCouncilPrompts(analysis).memory,
                    allPriorInsights,
                    'memory'
                );

                const stage3 = await queryCouncilMember('memory', enhancedMemoryPrompt, analysis);

                // Collect all responses for consensus generation
                const responses = [...stage1, ...stage2, stage3];

                // Generate collaborative consensus using new memory system
                console.log('‚öñÔ∏è Generating Collaborative Consensus with Memory Context');
                const consensus = synthesizeConsensus(responses, analysis);

                // Store consensus in memory
                djinnCouncilMemory.consensusHistory.push({
                    timestamp: new Date().toISOString(),
                    sessionReport: djinnCouncilMemory.members.pattern.reports.length,
                    memberAnalyses: responses.reduce((acc, r) => {
                        acc[r.member] = r.response;
                        return acc;
                    }, {}),
                    crossReferences: analyzeConsensusPatterns(),
                    emergentPatterns: identifyEmergentThemes(),
                    systemRecommendations: generateStrategicRecommendations()
                });

                // Auto-save intelligence
                autoSaveIntelligence();

                // Generate AI-powered intelligence report using council consensus
                console.log('üìä Generating AI-Powered Intelligence Report');
                const intelligenceEntry = await generateIntelligenceEntry(analysis, consensus);

                // Store and display the AI-generated intelligence report
                storeIntelligence(intelligenceEntry);
                displayIntelligence(intelligenceEntry);
                
            } catch (error) {
                console.error('Council analysis error:', error);
                logSurveillance(`‚ùå Analysis failed: ${error.message}`, 'error');
            }
            
            // Update UI
            document.getElementById('councilIndicator').className = 'indicator indicator-idle';
            updateTimestamp();
        }

        function generateEmptyStatePrompts(timestamp) {
            const emptyContext = `EVENT: empty_canvas_state\nTIMESTAMP: ${timestamp}\nSTATUS: No canvas content detected\n\nINSTRUCTION: Report IDLE status and wait for actual user content before analysis.`;

            return {
                pattern: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                wisdom: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                paradox: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                boundaries: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`,
                memory: `EMPTY_STATE_REPORT\n${emptyContext}\n\nOutput: Status: IDLE - No content to analyze`
            };
        }

        function generateCouncilPrompts(analysis) {
            // Extract canvas content for analysis
            const canvasContent = analysis.data?.content || '';

            // Use the new referential memory system
            return {
                pattern: generateReferentialAnalysis('pattern', canvasContent),
                wisdom: generateReferentialAnalysis('wisdom', canvasContent),
                paradox: generateReferentialAnalysis('paradox', canvasContent),
                boundaries: generateReferentialAnalysis('boundaries', canvasContent),
                memory: generateReferentialAnalysis('memory', canvasContent)
            };
        }

        // Format council response with proper structure and line breaks
        function formatCouncilResponse(response) {
            if (!response) return 'No response generated';

            // Add timestamp header
            const timestamp = new Date().toLocaleTimeString();
            const timestampHeader = `<div class="intel-timestamp" style="color: #888; font-size: 11px; margin-bottom: 8px;">${timestamp} <span class="new-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">NEW</span></div>`;

            // If response already has proper structure, ensure line breaks are preserved
            if (response.includes('[METRICS]') && response.includes('[ANALYSIS]')) {
                // Extract sections
                const metricsMatch = response.match(/\[METRICS\](.*?)(?=\[ANALYSIS\]|$)/s);
                const analysisMatch = response.match(/\[ANALYSIS\](.*)$/s);

                let formatted = timestampHeader;

                if (metricsMatch) {
                    const metricsContent = metricsMatch[1].trim();
                    // Apply color coding to individual metrics
                    const colorCodedMetrics = applyMetricColorCoding(metricsContent);
                    formatted += `<div class="metrics-section">[METRICS]\n${colorCodedMetrics}</div>\n\n`;
                }

                if (analysisMatch) {
                    const analysisContent = analysisMatch[1].trim();
                    formatted += `<div class="analysis-section">[ANALYSIS]\n${analysisContent}</div>`;
                }

                return formatted.trim();
            }
            
            // Try to detect and format common patterns
            let formatted = response;
            
            // Look for metrics-like patterns and structure them
            const metricPatterns = [
                /knowledge depth:?\s*(\d+)/gi,
                /learning rate:?\s*([\d.]+)/gi,
                /recursive loops:?\s*(\d+)/gi,
                /information density:?\s*([\d.]+)/gi,
                /accumulation rate:?\s*(\d+)%/gi,
                /paradoxes detected:?\s*(\d+)/gi,
                /contradiction severity:?\s*(\w+)/gi,
                /logic conflicts:?\s*(\d+)/gi,
                /resolution probability:?\s*(\d+)%/gi,
                /creative tension:?\s*(\d+)/gi,
                /autonomy score:?\s*(\d+)%/gi,
                /system overrides:?\s*(\d+)/gi,
                /choice restrictions:?\s*(\d+)/gi,
                /boundary violations:?\s*(\d+)/gi,
                /freedom index:?\s*(\w+)/gi,
                /memory allocation:?\s*([\d.]+(?:\s*\w+)?)/gi,
                /retention rate:?\s*(\d+)%/gi,
                /fragmentation index:?\s*([\d.]+)/gi,
                /echo patterns:?\s*(\d+)/gi,
                /temporal continuity:?\s*(\d+)%/gi
            ];
            
            let metricsFound = [];
            metricPatterns.forEach(pattern => {
                const matches = formatted.match(pattern);
                if (matches) {
                    metricsFound.push(...matches);
                }
            });
            
            // If we found metrics, structure them properly
            if (metricsFound.length > 0) {
                let metricsSection = '[METRICS]\n';
                metricsFound.forEach(metric => {
                    // Capitalize first letter and ensure proper format
                    const formattedMetric = metric.charAt(0).toUpperCase() + metric.slice(1);
                    metricsSection += formattedMetric + '\n';
                });
                
                // Extract analysis part (everything after metrics)
                const analysisStart = formatted.toLowerCase().indexOf('analysis');
                let analysisSection = '[ANALYSIS]\n';
                if (analysisStart !== -1) {
                    analysisSection += formatted.substring(analysisStart + 8).trim();
                } else {
                    // If no analysis section found, put remaining content there
                    const metricsText = metricsFound.join(' ');
                    analysisSection += formatted.replace(new RegExp(metricsText, 'gi'), '').trim();
                }
                
                formatted = metricsSection + '\n' + analysisSection;
            } else {
                // No metrics found, just add basic structure
                formatted = '[ANALYSIS]\n' + formatted;
            }
            
            // Clean up excessive whitespace
            formatted = formatted.replace(/\n{3,}/g, '\n\n');
            formatted = formatted.trim();

            // Add timestamp for non-structured responses
            return timestampHeader + formatted;
        }

        // Apply color coding to individual metrics
        function applyMetricColorCoding(metricsText) {
            let colorCodedText = metricsText;

            // Process each line to apply color coding
            const lines = colorCodedText.split('\n');
            const colorCodedLines = lines.map(line => {
                const lowerLine = line.toLowerCase();

                // Find matching metric and apply color class
                for (const [metricName, colorClass] of Object.entries(metricColorMap)) {
                    if (lowerLine.includes(metricName)) {
                        // Wrap the metric line with color styling
                        return `<span class="${colorClass}" style="display: block; margin: 2px 0; padding: 2px 4px; border-radius: 2px; background: rgba(255,255,255,0.05);">${line}</span>`;
                    }
                }

                // Return line unchanged if no metric match
                return line;
            });

            return colorCodedLines.join('\n');
        }

        async function queryCouncilMember(memberKey, prompt, analysisContext = null) {
            const member = councilMembers[memberKey];
            
            // Update status
            document.getElementById(member.status).textContent = 'ANALYZING';
            document.getElementById(member.element).innerHTML = '<span class="thinking">Processing data...</span>';
            
            try {
                // Check cache first - updated for template format
                const cacheKey = `${memberKey}_template_${hashContent(prompt)}`;
                if (responseCache.has(cacheKey)) {
                    const cached = responseCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < DJINN_CONFIG.CACHE_DURATION) {
                        document.getElementById(member.element).textContent = cached.response;
                        document.getElementById(member.status).textContent = 'COMPLETE';
                        return { member: memberKey, response: cached.response };
                    }
                }
                
                // Query Ollama with AI validation layer
                console.log(`üîç Querying ${member.model} for ${memberKey} analysis with AI validation...`);
                const validationResult = await queryCouncilMemberWithValidation(memberKey, prompt, analysisContext);

                const response = validationResult.response;
                if (response && typeof response === 'string') {
                    console.log(`‚úÖ ${memberKey} response received${validationResult.corrected ? ' and corrected' : ''}:`, response.substring(0, 200) + '...');
                } else {
                    console.error(`‚ùå ${memberKey} received invalid response:`, response);
                    return;
                }
                
                // Cache response with validation metadata
                responseCache.set(cacheKey, {
                    response: response,
                    timestamp: Date.now(),
                    validated: validationResult.validated,
                    corrected: validationResult.corrected
                });
                
                // Display the actual AI response instead of generic [METRICS] template
                const memberElement = document.getElementById(member.element);

                // Always display the full AI response with proper formatting
                if (response && response.length > 50) {
                    // Process markdown-style formatting for better display
                    const formattedResponse = formatMarkdownResponse(response, memberKey);
                    const timestamp = new Date().toLocaleTimeString();

                    // Add validation indicators with iteration info and emergency status
                    let validationIndicator = '';
                    const iterations = validationResult.iterations || 1;

                    if (validationResult.critical_failure) {
                        validationIndicator = ' <span class="critical-failure-indicator" style="color: #ff0000; font-weight: bold; margin-left: 8px;">üí• CRITICAL FAILURE</span>';
                    } else if (validationResult.emergency_recovery) {
                        const recoveryStatus = validationResult.validated ? 'RECOVERED' : 'EMERGENCY';
                        const recoveryColor = validationResult.validated ? '#ff8800' : '#ff4444';
                        validationIndicator = ` <span class="recovery-indicator" style="color: ${recoveryColor}; font-weight: bold; margin-left: 8px;">üö® ${recoveryStatus}</span>`;
                    } else if (validationResult.validated && !validationResult.corrected && iterations === 1) {
                        validationIndicator = ' <span class="validated-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">‚úÖ VALIDATED</span>';
                    } else if (validationResult.validated && !validationResult.corrected && iterations > 1) {
                        validationIndicator = ` <span class="validated-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">‚úÖ REFINED (${iterations}x)</span>`;
                    } else if (validationResult.validated && validationResult.corrected) {
                        validationIndicator = ` <span class="corrected-indicator" style="color: #ffaa00; font-weight: bold; margin-left: 8px;">‚ö†Ô∏è AI-CORRECTED (${iterations}x)</span>`;
                    } else {
                        validationIndicator = ' <span class="unvalidated-indicator" style="color: #ff6b6b; font-weight: bold; margin-left: 8px;">‚ö†Ô∏è UNVALIDATED</span>';
                    }

                    const timestampHeader = `<div class="intel-timestamp" style="color: #888; font-size: 11px; margin-bottom: 8px;">${timestamp} <span class="new-indicator" style="color: #00ff88; font-weight: bold; margin-left: 8px;">NEW</span>${validationIndicator}</div>`;
                    memberElement.innerHTML = timestampHeader + formattedResponse;
                } else {
                    // Fall back to formatted response only if AI response is empty/invalid
                    const formattedResponse = formatCouncilResponse(response);
                    memberElement.innerHTML = formattedResponse;
                }
                
                // Color is now handled in formatMarkdownResponse function
                // if (memberKey === 'pattern') memberElement.style.color = '#00ff88';
                // else if (memberKey === 'wisdom') memberElement.style.color = '#ffaa00';
                // else if (memberKey === 'paradox') memberElement.style.color = '#ff6666';
                // else if (memberKey === 'boundaries') memberElement.style.color = '#00ccff';
                // else if (memberKey === 'memory') memberElement.style.color = '#ff88ff';
                
                document.getElementById(member.status).textContent = 'COMPLETE';

                // Store in council memory system with optimization
                storeCouncilMemberReportOptimized(memberKey, {
                    analysis: response,
                    metrics: extractMetricsFromAnalysis(response),
                    canvasData: analysisContext?.data?.content || ''
                });

                return { member: memberKey, response: response };
                
            } catch (error) {
                // No fallback - show the actual error
                console.error(`‚ùå ${memberKey} AI query failed:`, error.message);
                document.getElementById(member.element).innerHTML = `<div style="color: #ff6666; font-size: 12px;">
                    ‚ö†Ô∏è AI Analysis Unavailable<br>
                    Error: ${error.message}<br>
                    Check Ollama service status
                </div>`;
                document.getElementById(member.status).textContent = 'ERROR';
                return { member: memberKey, response: null, error: error.message };
            }
        }

        // Enforce proper report structure formatting
        function enforceReportStructure(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Check if response already has proper structure
            const hasSummary = response.includes('**SUMMARY**');
            const hasAnalysis = response.includes('**ANALYSIS**');
            const hasFindings = response.includes('**FINDINGS**');
            const hasMetrics = response.includes('**METRICS**');
            const hasConclusions = response.includes('**CONCLUSIONS**');
            const hasActions = response.includes('**ACTIONS**');

            // If all sections are present, return as-is
            if (hasSummary && hasAnalysis && hasFindings && hasMetrics && hasConclusions && hasActions) {
                return response;
            }

            // If structure is missing, try to parse and restructure the content
            return restructureUnformattedResponse(response);
        }


        function restructureUnformattedResponse(response) {
            // Try to extract meaningful content and structure it properly
            const lines = response.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            // Look for section-like content
            const sections = {
                summary: [],
                analysis: [],
                findings: [],
                metrics: [],
                conclusions: [],
                actions: []
            };

            let currentSection = 'summary';
            let inMetrics = false;
            let inActions = false;

            for (const line of lines) {
                const lowerLine = line.toLowerCase();
                
                // Detect section headers
                if (lowerLine.includes('summary') && !lowerLine.includes('findings')) {
                    currentSection = 'summary';
                    continue;
                } else if (lowerLine.includes('analysis') || lowerLine.includes('method')) {
                    currentSection = 'analysis';
                    continue;
                } else if (lowerLine.includes('finding') || lowerLine.includes('discovery') || lowerLine.includes('observation')) {
                    currentSection = 'findings';
                    continue;
                } else if (lowerLine.includes('metric') || lowerLine.includes('measurement') || lowerLine.includes('statistic')) {
                    currentSection = 'metrics';
                    inMetrics = true;
                    continue;
                } else if (lowerLine.includes('conclusion') || lowerLine.includes('result')) {
                    currentSection = 'conclusions';
                    inMetrics = false;
                    continue;
                } else if (lowerLine.includes('action') || lowerLine.includes('recommendation')) {
                    currentSection = 'actions';
                    inActions = true;
                    inMetrics = false;
                    continue;
                }

                // Add content to current section
                if (currentSection === 'metrics' && (line.includes(':') || line.includes('%') || /\d/.test(line))) {
                    sections.metrics.push(line.replace(/^[\-\*]\s*/, '- '));
                } else if (currentSection === 'actions' && (line.includes('recommend') || line.match(/^\d+\./))) {
                    sections.actions.push(line.replace(/^[\-\*]\s*/, '').replace(/^\d+\.\s*/, ''));
                } else if (!inMetrics && !inActions) {
                    sections[currentSection].push(line);
                }
            }

            // Build properly formatted response
            let structured = '';

            if (sections.summary.length > 0) {
                structured += '**SUMMARY**\n' + sections.summary.join(' ') + '\n\n';
            }

            if (sections.analysis.length > 0) {
                structured += '**ANALYSIS**\n' + sections.analysis.join(' ') + '\n\n';
            }

            if (sections.findings.length > 0) {
                structured += '**FINDINGS**\n';
                // Try to categorize findings
                const categorizedFindings = categorizeFindings(sections.findings);
                Object.entries(categorizedFindings).forEach(([category, findings]) => {
                    if (findings.length > 0) {
                        structured += `- **${category}:** ${findings.join(' ')}\n`;
                    }
                });
                structured += '\n';
            }

            if (sections.metrics.length > 0) {
                structured += '**METRICS**\n';
                sections.metrics.forEach(metric => {
                    structured += (metric.startsWith('-') ? metric : '- ' + metric) + '\n';
                });
                structured += '\n';
            }

            if (sections.conclusions.length > 0) {
                structured += '**CONCLUSIONS**\n' + sections.conclusions.join(' ') + '\n\n';
            }

            if (sections.actions.length > 0) {
                structured += '**ACTIONS**\n';
                sections.actions.forEach((action, index) => {
                    structured += `${index + 1}. ${action}\n`;
                });
            }

            return structured.trim() || response; // Return restructured or original if restructuring failed
        }

        function categorizeFindings(findings) {
            const categories = {
                'System Performance': [],
                'Content Evolution': [],
                'Pattern Recognition': [],
                'Risk Assessment': []
            };

            findings.forEach(finding => {
                const lowerFinding = finding.toLowerCase();
                if (lowerFinding.includes('system') || lowerFinding.includes('performance') || lowerFinding.includes('ai')) {
                    categories['System Performance'].push(finding);
                } else if (lowerFinding.includes('content') || lowerFinding.includes('evolution') || lowerFinding.includes('change')) {
                    categories['Content Evolution'].push(finding);
                } else if (lowerFinding.includes('pattern') || lowerFinding.includes('recognition') || lowerFinding.includes('anomaly')) {
                    categories['Pattern Recognition'].push(finding);
                } else if (lowerFinding.includes('risk') || lowerFinding.includes('stability') || lowerFinding.includes('concern')) {
                    categories['Risk Assessment'].push(finding);
                } else {
                    categories['System Performance'].push(finding); // Default category
                }
            });

            return categories;
        }

        // Format markdown-style response for better HTML display
        function formatMarkdownResponse(response, memberKey) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Get member-specific colors
            const memberColors = {
                pattern: '#00ff88',
                wisdom: '#ffaa00', 
                paradox: '#ff6666',
                boundaries: '#00ccff',
                memory: '#ff88ff'
            };

            const memberColor = memberColors[memberKey] || '#ffffff';

            let formatted = response;

            // Convert **bold** to <strong> with member color
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, `<strong style="color: ${memberColor} !important;">$1</strong>`);

            // Convert section headers to styled divs with member color
            const headerStyle = `color: ${memberColor} !important; border-bottom: 1px solid ${memberColor}; padding-bottom: 2px; margin-bottom: 8px; font-weight: bold;`;
            
            // Ensure proper spacing before headers (both with and without ** formatting)
            formatted = formatted.replace(/([^\n])\*\*SUMMARY\*\*/g, '$1\n\n**SUMMARY**');
            formatted = formatted.replace(/([^\n])\*\*ANALYSIS\*\*/g, '$1\n\n**ANALYSIS**');
            formatted = formatted.replace(/([^\n])\*\*FINDINGS\*\*/g, '$1\n\n**FINDINGS**');
            formatted = formatted.replace(/([^\n])\*\*METRICS\*\*/g, '$1\n\n**METRICS**');
            formatted = formatted.replace(/([^\n])\*\*CONCLUSIONS\*\*/g, '$1\n\n**CONCLUSIONS**');
            formatted = formatted.replace(/([^\n])\*\*ACTIONS\*\*/g, '$1\n\n**ACTIONS**');
            
            // Handle headers without ** formatting (AI sometimes generates plain text headers)
            formatted = formatted.replace(/([^\n])(SUMMARY)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(ANALYSIS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(FINDINGS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(METRICS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(CONCLUSIONS)(?!\*)/g, '$1\n\n$2');
            formatted = formatted.replace(/([^\n])(ACTIONS)(?!\*)/g, '$1\n\n$2');
            
            formatted = formatted.replace(/^(\*\*SUMMARY\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">SUMMARY</div>`);
            formatted = formatted.replace(/^(\*\*ANALYSIS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">ANALYSIS</div>`);
            formatted = formatted.replace(/^(\*\*FINDINGS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">FINDINGS</div>`);
            formatted = formatted.replace(/^(\*\*METRICS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">METRICS</div>`);
            formatted = formatted.replace(/^(\*\*CONCLUSIONS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">CONCLUSIONS</div>`);
            formatted = formatted.replace(/^(\*\*ACTIONS\*\*)/gm, `<div class="analysis-section" style="${headerStyle}">ACTIONS</div>`);
            
            // Handle plain text headers (without ** formatting)
            formatted = formatted.replace(/^(SUMMARY)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">SUMMARY</div>`);
            formatted = formatted.replace(/^(ANALYSIS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">ANALYSIS</div>`);
            formatted = formatted.replace(/^(FINDINGS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">FINDINGS</div>`);
            formatted = formatted.replace(/^(METRICS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">METRICS</div>`);
            formatted = formatted.replace(/^(CONCLUSIONS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">CONCLUSIONS</div>`);
            formatted = formatted.replace(/^(ACTIONS)(?!\*)/gm, `<div class="analysis-section" style="${headerStyle}">ACTIONS</div>`);

            // Clean up actions section - remove extra headers and ensure proper numbering
            formatted = formatted.replace(/\*\*SECOND RECOMMENDATION\*\*[\s\S]*?\n/g, '');
            formatted = formatted.replace(/\*\*THIRD RECOMMENDATION\*\*[\s\S]*?\n/g, '');

            // Convert bullet points to proper HTML lists with member color
            // First, identify sections and wrap their content appropriately
            const sections = formatted.split(/(<div class="analysis-section">.*?<\/div>)/);
            let currentSection = '';

            formatted = sections.map(section => {
                if (section.includes('analysis-section')) {
                    // Update current section based on header
                    if (section.includes('METRICS')) currentSection = 'metrics';
                    else if (section.includes('ACTIONS')) currentSection = 'actions';
                    else if (section.includes('FINDINGS')) currentSection = 'findings';
                    else currentSection = '';
                    return section; // Keep headers as-is
                }

                // Process content sections
                let content = section;

                // Handle metrics section (uses - bullets)
                if (currentSection === 'metrics') {
                    content = content.replace(/^- (.*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;">$1</li>`);
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ul style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ul>`);
                }

                // Handle actions section (uses numbered bullets)
                if (currentSection === 'actions') {
                    // Clean up any malformed numbering - remove all leading numbers and unwanted headers
                    content = content.replace(/SECOND RECOMMENDATION/gi, ''); // Remove unwanted headers
                    content = content.replace(/THIRD RECOMMENDATION/gi, ''); // Remove unwanted headers
                    
                    // Clean up malformed numbering patterns like "1. 1." by removing all leading numbers
                    content = content.replace(/^[\d\.\s]+(.*?)(?=\n|$)/gm, (match, text) => {
                        // Remove all leading numbers and dots/spaces to get clean action text
                        const cleanText = text.trim().replace(/^[\d\.\s]+/, '').trim();
                        return `<li style="color: ${memberColor} !important;">${cleanText}</li>`;
                    });
                    
                    // Handle any remaining lines that might not have been caught
                    content = content.replace(/^([^-<\d].*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;">$1</li>`);
                    
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ol style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ol>`);
                }

                // Handle findings section (may have sub-bullets)
                if (currentSection === 'findings') {
                    content = content.replace(/^- \*\*(.*?):\*\* (.*?)(?=\n|$)/gm, `<li style="color: ${memberColor} !important;"><strong style="color: ${memberColor} !important;">$1:</strong> $2</li>`);
                    content = content.replace(/(<li>.*?<\/li>)+/gs, `<ul style="margin: 4px 0; padding-left: 20px; color: ${memberColor} !important;">$&</ul>`);
                }

                return content;
            }).join('');

            // Preserve line breaks but clean up excessive whitespace
            formatted = formatted.replace(/\n{3,}/g, '\n\n');
            formatted = formatted.replace(/\n/g, '<br>');

            // Clean up list formatting
            formatted = formatted.replace(/<\/li><br>/g, '</li>');
            formatted = formatted.replace(/<br><li>/g, '<li>');
            formatted = formatted.replace(/<br><ul>/g, '<ul>');
            formatted = formatted.replace(/<\/ul><br>/g, '</ul>');

            // Wrap in a container with proper styling
            formatted = `<div style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; white-space: normal; color: ${memberColor} !important;">${formatted}</div>`;

            return formatted;
        }

        async function queryOllama(model, prompt) {
            console.log(`üöÄ Starting Ollama query for model: ${model}`);
            console.log(`üìù Prompt length: ${prompt.length} characters`);
            
            try {
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        system: "You are an expert AI analyst. Analyze the provided data and write a structured report. Start directly with **SUMMARY** and follow the exact format specified in the prompt. Do not include any introductory text or copy the prompt structure - generate your own analysis content. In the ACTIONS section, provide exactly 3 numbered recommendations without any sub-headers like 'SECOND RECOMMENDATION'.",
                        prompt: prompt,
                        stream: false,
                        options: {
                            temperature: 0.7,  // Natural creativity for fluid AI responses
                            top_p: 0.5,
                            num_predict: 8192,  // Maximum token output for complete analysis
                            seed: Date.now()  // Add randomness to avoid cached responses
                        }
                    })
                });
                
                console.log(`üì° Ollama HTTP response status: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`Ollama HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                let rawResponse = data.response || '';

                // Log the raw response for debugging
                console.log('Raw Ollama response:', rawResponse);

                // Evaluate template literals in the response
                let evaluatedResponse = evaluateTemplateLiterals(rawResponse);
                
                // Strip any conversational text before the report structure
                const summaryIndex = evaluatedResponse.indexOf('**SUMMARY**');
                if (summaryIndex > 0) {
                    evaluatedResponse = evaluatedResponse.substring(summaryIndex);
                }
                
                // Enforce proper report structure formatting
                evaluatedResponse = enforceReportStructure(evaluatedResponse);
                
                console.log('Template evaluation result:', evaluatedResponse.substring(0, 200) + '...');
                
                return evaluatedResponse;
            } catch (error) {
                // No fallback - re-throw the error to be handled upstream
                console.error('Ollama query failed:', error.message);
                throw error;
            }
        }

        // ========================================
        // AI-POWERED VALIDATION LAYER
        // ========================================

        async function validateWithAI(originalResponse, canvasContent, memberName) {
            const canvasLength = canvasContent ? canvasContent.length : 0;
            const canvasWordCount = canvasContent ? canvasContent.split(/\s+/).length : 0;
            const canvasLineCount = canvasContent ? canvasContent.split('\n').length : 0;

            const validationPrompt = `
VALIDATION TASK: You are a fact-checker AI. Verify the analysis below against the actual data provided.

=== ACTUAL CANVAS DATA ===
Content Length: ${canvasLength} characters
Word Count: ${canvasWordCount} words
Line Count: ${canvasLineCount} lines
Canvas Content: "${canvasContent.substring(0, 500)}${canvasContent.length > 500 ? '...' : ''}"

=== ANALYSIS TO VALIDATE ===
${originalResponse}

=== YOUR VALIDATION JOB ===
Check if the analysis makes claims about:
1. AI systems (NARRA, NAZAR, WHALE, DJINN, WATCHTOWER) without actual data
2. Specific performance percentages without basis
3. System metrics that aren't calculable from the provided data
4. Memory states or interactions not present in the canvas content

OUTPUT FORMAT:
**VALIDATION RESULT:** [VALID/NEEDS_CORRECTION]

**CORRECTED ANALYSIS:**
[If NEEDS_CORRECTION: Provide the corrected version with "Data not available" replacing fabricated claims]
[If VALID: Return "Analysis is factually grounded"]

**VALIDATION NOTES:**
- [List any corrections made or confirm data accuracy]

CRITICAL: Only approve claims that can be verified from the actual canvas content and data provided above.
`;

            try {
                const validationResponse = await queryOllama('gemma3:1b', validationPrompt);
                console.log(`üîç AI validation completed for ${memberName}`);

                // Parse validation response
                if (validationResponse.includes('NEEDS_CORRECTION')) {
                    console.warn(`‚ö†Ô∏è ${memberName} response corrected by AI validator`);

                    // Extract corrected analysis
                    const correctedMatch = validationResponse.match(/\*\*CORRECTED ANALYSIS:\*\*\s*([\s\S]*?)(?=\*\*VALIDATION NOTES|$)/);
                    if (correctedMatch && correctedMatch[1].trim() !== 'Analysis is factually grounded') {
                        return {
                            validated: true,
                            corrected: true,
                            response: correctedMatch[1].trim(),
                            notes: validationResponse
                        };
                    }
                }

                console.log(`‚úÖ ${memberName} response validated as factually grounded`);
                return {
                    validated: true,
                    corrected: false,
                    response: originalResponse,
                    notes: validationResponse
                };

            } catch (error) {
                console.error('AI validation failed, using original response:', error);
                return {
                    validated: false,
                    corrected: false,
                    response: originalResponse,
                    notes: 'Validation failed'
                };
            }
        }

        // Enhanced council member query with AI validation and feedback loop
        async function queryCouncilMemberWithValidation(memberKey, prompt, analysis) {
            const startTime = Date.now(); // Performance tracking

            try {
                const member = councilMembers[memberKey];
                const canvasContent = analysis?.data?.content || '';
                const maxIterations = 3; // Limit feedback loops to prevent endless iterations
                let iteration = 1;
                let currentPrompt = prompt;
                let finalResponse = null;
                let validationHistory = [];

                if (!member) {
                    throw new Error(`Council member ${memberKey} not found`);
                }

                while (iteration <= maxIterations) {
                    console.log(`üîç Querying ${member.model} for ${memberKey} analysis (attempt ${iteration}/${maxIterations})...`);
                    const response = await queryOllama(member.model, currentPrompt);

                    // PATTERN RECOGNITION: Analyze report before validation
                    let patternAnalysis = null;
                    if (iteration === 1) { // Only on first attempt to avoid overhead
                        patternAnalysis = await patternRecognitionEngine.prescreenAndRoute(memberKey, response);
                        console.log(`üéØ Pattern prediction for ${memberKey}: ${patternAnalysis.failureProbability}/10 failure risk`);
                    }

                    console.log(`üîç AI-validating ${memberKey} response (iteration ${iteration})...`);
                    const validationResult = await validateWithAI(response, canvasContent, memberKey);

                    validationHistory.push({
                        iteration: iteration,
                        response: response,
                        validation: validationResult
                    });

                    // Record validation in specialist memory
                    validationSpecialist.recordValidation(memberKey, response, validationResult, iteration);

                    // TRIANGULATED VALIDATION: Get refinement specialist coaching
                    const coachingAnalysis = await refinementSpecialist.analyzeValidationInteraction(
                        memberKey, response, validationResult.notes, iteration
                    );

                    // If validation passed without correction, we have a good report
                    if (validationResult.validated && !validationResult.corrected) {
                        console.log(`‚úÖ ${memberKey} produced validated report on iteration ${iteration}`);

                        // Update pattern recognition accuracy if we had a prediction
                        if (patternAnalysis) {
                            patternRecognitionEngine.updatePatternAccuracy(memberKey, patternAnalysis.failureProbability, validationResult);
                        }

                        finalResponse = {
                            member: memberKey,
                            response: response,
                            validated: true,
                            corrected: false,
                            validationNotes: validationResult.notes,
                            iterations: iteration,
                            history: validationHistory
                        };
                        break;
                    }

                    // If this is the last iteration, escalate to Recovery Agent
                    if (iteration === maxIterations) {
                        console.log(`üö® ${memberKey} CRITICAL: Triangulated validation failed - escalating to Recovery Agent`);

                        try {
                            // Emergency intervention by Recovery Agent
                            const recoveryAnalysis = await recoveryAgent.performEmergencyIntervention(
                                memberKey, validationHistory, coachingAnalysis ? 1 : 0
                            );

                            console.log(`üÜò Recovery Agent diagnosis: ${recoveryAnalysis.systemFailureType}`);

                            // Attempt emergency recovery
                            const emergencyResponse = await recoveryAgent.applyEmergencyRecovery(
                                memberKey, recoveryAnalysis, prompt, canvasContent
                            );

                            // Validate the emergency response
                            const emergencyValidation = await validateWithAI(emergencyResponse, canvasContent, memberKey);

                            // Record recovery outcome
                            const recoveryOutcome = emergencyValidation.validated ? 'successful' : 'failed';
                            recoveryAgent.recordRecoveryAttempt(memberKey, recoveryAnalysis, emergencyResponse, recoveryOutcome);

                            finalResponse = {
                                member: memberKey,
                                response: emergencyResponse,
                                validated: emergencyValidation.validated,
                                corrected: emergencyValidation.corrected,
                                validationNotes: emergencyValidation.notes,
                                iterations: iteration,
                                history: validationHistory,
                                emergency_recovery: true,
                                recovery_analysis: recoveryAnalysis
                            };

                            console.log(`üö® Recovery Agent ${recoveryOutcome}: ${memberKey} emergency intervention complete`);

                        } catch (error) {
                            console.error(`üí• Recovery Agent failed for ${memberKey}:`, error);

                            finalResponse = {
                                member: memberKey,
                                response: recoveryAgent.generateFinalFailsafe(memberKey),
                                validated: false,
                                corrected: false,
                                validationNotes: 'Critical system failure - manual intervention required',
                                iterations: iteration,
                                history: validationHistory,
                                critical_failure: true
                            };
                        }
                        break;
                    }

                    // Create enhanced feedback prompt with triangulated coaching
                    console.log(`üîÑ ${memberKey} needs improvement, applying triangulated coaching for iteration ${iteration + 1}`);
                    currentPrompt = createTriangulatedFeedbackPrompt(prompt, response, validationResult, coachingAnalysis, canvasContent, memberKey, iteration);
                    iteration++;

                    // Brief delay between iterations
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                // Record performance metrics for efficiency optimization
                const endTime = Date.now();
                efficiencyOptimizer.recordPerformanceMetrics(memberKey, startTime, endTime, iteration, finalResponse);

                // Track validator performance for QA monitoring
                qualityAssuranceMonitor.trackValidatorPerformance(memberKey, finalResponse, endTime - startTime);

                return finalResponse;

            } catch (error) {
                console.error(`Council member ${memberKey} analysis failed:`, error);
                // Record failed performance metrics
                const endTime = Date.now();
                efficiencyOptimizer.recordPerformanceMetrics(memberKey, startTime, endTime, iteration, { validated: false });
                throw error;
            }
        }

        // Create triangulated feedback prompt with refinement specialist coaching
        function createTriangulatedFeedbackPrompt(originalPrompt, previousResponse, validationResult, coachingAnalysis, canvasContent, memberKey, iteration) {
            const member = councilMembers[memberKey];
            const memberName = member.name;

            return `${originalPrompt}

========== TRIANGULATED VALIDATION COACHING (Iteration ${iteration}) ==========

Your response has been analyzed by both our Primary Validator and Refinement Specialist for comprehensive improvement guidance.

PREVIOUS RESPONSE:
${previousResponse.substring(0, 600)}${previousResponse.length > 600 ? '...[truncated]' : ''}

=== PRIMARY VALIDATOR FEEDBACK ===
${validationResult.notes}

=== REFINEMENT SPECIALIST COACHING ===

COMMUNICATION ISSUE IDENTIFIED:
${coachingAnalysis.communicationGap}

SPECIFIC GUIDANCE FOR YOU:
${coachingAnalysis.memberCoaching}

RECOMMENDED INTERVENTION STRATEGY:
${coachingAnalysis.interventionStrategy}

PATTERN ANALYSIS:
${coachingAnalysis.patternRecognition}

=== TRIANGULATED IMPROVEMENT APPROACH ===

1. **Address Core Validation Issues**: ${validationResult.corrected ? 'Focus on factual accuracy over speculation' : 'Maintain current quality while enhancing depth'}

2. **Apply Specialist Coaching**: Follow the specific guidance above to improve your analytical approach

3. **Canvas Data Foundation**:
   - Content Length: ${canvasContent.length} characters
   - Word Count: ${canvasContent.split(/\s+/).length} words
   - Line Count: ${canvasContent.split('\n').length} lines

As ${memberName}, use this triangulated feedback to craft a response that satisfies both validation requirements and demonstrates improvement based on the refinement specialist's insights.

CRITICAL: This iteration includes expert coaching analysis. Apply the specific recommendations to pass validation.`;
        }

        // Legacy feedback function (fallback)
        function createFeedbackPrompt(originalPrompt, previousResponse, validationResult, canvasContent, memberKey, iteration) {
            return createTriangulatedFeedbackPrompt(originalPrompt, previousResponse, validationResult, {
                communicationGap: 'Standard validation feedback',
                memberCoaching: 'Focus on factual accuracy and specific evidence',
                interventionStrategy: 'Apply standard validation requirements',
                patternRecognition: 'Standard iterative improvement process'
            }, canvasContent, memberKey, iteration);
        }

        // ========================================
        // ENHANCED RESPONSE PARSING PIPELINE
        // ========================================

        // Advanced response processor with content preservation
        const enhancedResponseProcessor = {
            processingStats: {
                totalResponses: 0,
                contentPreserved: 0,
                structureImproved: 0,
                avgProcessingTime: 0
            },

            // Main processing pipeline
            process: function(rawResponse, memberKey = 'unknown') {
                const startTime = Date.now();
                this.processingStats.totalResponses++;

                try {
                    console.log(`üî¨ Enhanced processing for ${memberKey} response (${rawResponse.length} chars)`);

                    // Stage 1: Content preservation and analysis
                    const contentAnalysis = this.analyzeContent(rawResponse);

                    // Stage 2: Intelligent structure detection
                    const structureMap = this.detectStructure(rawResponse);

                    // Stage 3: Content-aware restructuring
                    const restructured = this.smartRestructure(rawResponse, structureMap, contentAnalysis);

                    // Stage 4: Quality enhancement
                    const enhanced = this.enhanceQuality(restructured, contentAnalysis);

                    // Stage 5: Validation and metrics
                    const validated = this.validateAndMeasure(enhanced, rawResponse);

                    const processingTime = Date.now() - startTime;
                    this.processingStats.avgProcessingTime =
                        (this.processingStats.avgProcessingTime + processingTime) / 2;

                    console.log(`‚úÖ Enhanced processing complete: ${validated.length}/${rawResponse.length} chars preserved (${processingTime}ms)`);

                    return validated;

                } catch (error) {
                    console.error('‚ùå Enhanced processing failed:', error);
                    // Fallback to original response
                    return rawResponse;
                }
            },

            // Analyze content characteristics
            analyzeContent: function(response) {
                return {
                    length: response.length,
                    lines: response.split('\n').length,
                    words: response.split(/\s+/).filter(w => w.length > 0).length,
                    sections: this.countSections(response),
                    formatting: this.detectFormatting(response),
                    quality: this.assessQuality(response),
                    structure: this.analyzeStructure(response)
                };
            },

            // Count existing sections
            countSections: function(response) {
                const sections = ['SUMMARY', 'ANALYSIS', 'FINDINGS', 'METRICS', 'CONCLUSIONS', 'ACTIONS'];
                const counts = {};

                sections.forEach(section => {
                    const regex = new RegExp(`\\*\\*${section}\\*\\*`, 'gi');
                    counts[section.toLowerCase()] = (response.match(regex) || []).length;
                });

                return counts;
            },

            // Detect formatting patterns
            detectFormatting: function(response) {
                return {
                    hasBold: response.includes('**') || response.includes('__'),
                    hasLists: response.includes('- ') || response.includes('* ') || /^\d+\./.test(response),
                    hasHeaders: /^\*+.*$/m.test(response),
                    hasTables: response.includes('|'),
                    hasCode: response.includes('```') || response.includes('`'),
                    hasLinks: response.includes('[') && response.includes('](')
                };
            },

            // Assess content quality
            assessQuality: function(response) {
                let score = 0;
                const words = response.split(/\s+/).filter(w => w.length > 0);

                // Length appropriateness
                if (response.length > 100) score += 20;
                if (response.length > 500) score += 20;

                // Vocabulary richness
                const uniqueWords = new Set(words.map(w => w.toLowerCase()));
                const richness = uniqueWords.size / words.length;
                score += Math.min(20, richness * 100);

                // Structure presence
                const sections = this.countSections(response);
                const sectionCount = Object.values(sections).reduce((a, b) => a + b, 0);
                score += Math.min(20, sectionCount * 5);

                // Formatting quality
                const formatting = this.detectFormatting(response);
                const formatScore = Object.values(formatting).filter(Boolean).length;
                score += Math.min(20, formatScore * 5);

                return Math.min(100, score);
            },

            // Analyze structural patterns
            analyzeStructure: function(response) {
                const lines = response.split('\n');
                const structure = {
                    headers: [],
                    paragraphs: [],
                    lists: [],
                    tables: [],
                    codeBlocks: []
                };

                let inCodeBlock = false;
                let currentParagraph = [];

                lines.forEach((line, index) => {
                    const trimmed = line.trim();

                    // Code blocks
                    if (trimmed.startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        if (inCodeBlock) structure.codeBlocks.push(index);
                        return;
                    }

                    if (inCodeBlock) return;

                    // Headers
                    if (/^#{1,6}\s/.test(trimmed) || /^\*+.*\*+$/.test(trimmed)) {
                        structure.headers.push({ line: index, content: trimmed });
                        if (currentParagraph.length > 0) {
                            structure.paragraphs.push(currentParagraph);
                            currentParagraph = [];
                        }
                    }
                    // Lists
                    else if (/^[\-\*]\s/.test(trimmed) || /^\d+\./.test(trimmed)) {
                        structure.lists.push({ line: index, content: trimmed });
                        if (currentParagraph.length > 0) {
                            structure.paragraphs.push(currentParagraph);
                            currentParagraph = [];
                        }
                    }
                    // Tables
                    else if (trimmed.includes('|') && trimmed.split('|').length > 2) {
                        structure.tables.push({ line: index, content: trimmed });
                    }
                    // Paragraph content
                    else if (trimmed.length > 0) {
                        currentParagraph.push(trimmed);
                    }
                    // Empty lines (paragraph breaks)
                    else if (currentParagraph.length > 0) {
                        structure.paragraphs.push(currentParagraph);
                        currentParagraph = [];
                    }
                });

                if (currentParagraph.length > 0) {
                    structure.paragraphs.push(currentParagraph);
                }

                return structure;
            },

            // Intelligent structure detection
            detectStructure: function(response) {
                const structureMap = {
                    sections: {},
                    boundaries: [],
                    confidence: 0
                };

                // Look for explicit section markers
                const sectionPatterns = [
                    { name: 'summary', patterns: ['**SUMMARY**', '## SUMMARY', 'SUMMARY:', 'Summary:'] },
                    { name: 'analysis', patterns: ['**ANALYSIS**', '## ANALYSIS', 'ANALYSIS:', 'Analysis:'] },
                    { name: 'findings', patterns: ['**FINDINGS**', '## FINDINGS', 'FINDINGS:', 'Findings:'] },
                    { name: 'metrics', patterns: ['**METRICS**', '## METRICS', 'METRICS:', 'Metrics:'] },
                    { name: 'conclusions', patterns: ['**CONCLUSIONS**', '## CONCLUSIONS', 'CONCLUSIONS:', 'Conclusions:'] },
                    { name: 'actions', patterns: ['**ACTIONS**', '## ACTIONS', 'ACTIONS:', 'Actions:', 'Recommendations:'] }
                ];

                sectionPatterns.forEach(section => {
                    section.patterns.forEach(pattern => {
                        const index = response.indexOf(pattern);
                        if (index !== -1) {
                            structureMap.sections[section.name] = structureMap.sections[section.name] || [];
                            structureMap.sections[section.name].push({
                                start: index,
                                marker: pattern,
                                confidence: 1.0
                            });
                        }
                    });
                });

                // Look for implicit section boundaries
                const lines = response.split('\n');
                lines.forEach((line, index) => {
                    const trimmed = line.trim().toLowerCase();

                    // Look for section-like headers
                    if (trimmed.length > 0 && trimmed.length < 50 &&
                        !trimmed.includes('.') && !trimmed.includes('?') &&
                        (trimmed.includes('analysis') || trimmed.includes('finding') ||
                         trimmed.includes('metric') || trimmed.includes('conclusion'))) {
                        structureMap.boundaries.push({
                            line: index,
                            content: line.trim(),
                            confidence: 0.7
                        });
                    }
                });

                // Calculate overall structure confidence
                const explicitSections = Object.keys(structureMap.sections).length;
                const implicitBoundaries = structureMap.boundaries.length;
                structureMap.confidence = Math.min(1.0, (explicitSections * 0.3) + (implicitBoundaries * 0.1));

                return structureMap;
            },

            // Smart restructuring with content preservation
            smartRestructure: function(response, structureMap, contentAnalysis) {
                // If structure is already good, preserve it
                if (structureMap.confidence > 0.8) {
                    return this.preserveExistingStructure(response, structureMap);
                }

                // If structure needs work but content is good, enhance it
                if (contentAnalysis.quality > 70) {
                    return this.enhanceStructure(response, structureMap, contentAnalysis);
                }

                // If both need work, reconstruct carefully
                return this.reconstructStructure(response, contentAnalysis);
            },

            // Preserve existing good structure
            preserveExistingStructure: function(response, structureMap) {
                // Find the best instance of each section
                const sections = {};
                Object.entries(structureMap.sections).forEach(([sectionName, markers]) => {
                    if (markers.length > 0) {
                        // Use the first (highest confidence) marker
                        const marker = markers[0];
                        const nextSectionStart = this.findNextSectionStart(response, marker.start, structureMap);

                        sections[sectionName] = {
                            content: response.substring(marker.start, nextSectionStart),
                            originalStart: marker.start
                        };
                    }
                });

                // Rebuild with preserved content
                return this.rebuildWithSections(sections, response);
            },

            // Enhance existing structure
            enhanceStructure: function(response, structureMap, contentAnalysis) {
                let enhanced = response;

                // Add missing section headers
                const missingSections = this.identifyMissingSections(structureMap);
                missingSections.forEach(section => {
                    enhanced = this.addSectionHeader(enhanced, section, contentAnalysis);
                });

                // Improve formatting
                enhanced = this.improveFormatting(enhanced, contentAnalysis);

                return enhanced;
            },

            // Reconstruct structure for poorly formatted content
            reconstructStructure: function(response, contentAnalysis) {
                const lines = response.split('\n');
                const reconstructed = {
                    summary: [],
                    analysis: [],
                    findings: [],
                    metrics: [],
                    conclusions: [],
                    actions: []
                };

                let currentSection = 'summary';
                let inList = false;

                lines.forEach((line, index) => {
                    const trimmed = line.trim();
                    if (!trimmed) return;

                    // Detect section changes based on content patterns
                    const lowerLine = trimmed.toLowerCase();

                    if (lowerLine.includes('analysis') && !lowerLine.includes('findings')) {
                        currentSection = 'analysis';
                    } else if (lowerLine.includes('finding') || lowerLine.includes('observation')) {
                        currentSection = 'findings';
                    } else if (lowerLine.includes('metric') || (trimmed.includes(':') && /\d/.test(trimmed))) {
                        currentSection = 'metrics';
                    } else if (lowerLine.includes('conclusion') || lowerLine.includes('result')) {
                        currentSection = 'conclusions';
                    } else if (lowerLine.includes('action') || lowerLine.includes('recommend')) {
                        currentSection = 'actions';
                    } else {
                        // Add content to current section
                        reconstructed[currentSection].push(trimmed);
                    }
                });

                // Build structured output
                let result = '';
                Object.entries(reconstructed).forEach(([section, content]) => {
                    if (content.length > 0) {
                        result += `**${section.toUpperCase()}**\n${content.join('\n')}\n\n`;
                    }
                });

                return result.trim();
            },

            // Quality enhancement
            enhanceQuality: function(response, contentAnalysis) {
                let enhanced = response;

                // Improve formatting consistency
                enhanced = this.consistentFormatting(enhanced);

                // Enhance readability
                enhanced = this.improveReadability(enhanced);

                // Add missing context where helpful
                enhanced = this.addContextualEnhancements(enhanced, contentAnalysis);

                return enhanced;
            },

            // Validation and measurement
            validateAndMeasure: function(processed, original) {
                const preservationRate = (processed.length / original.length) * 100;
                this.processingStats.contentPreserved =
                    (this.processingStats.contentPreserved + preservationRate) / 2;

                // Ensure minimum quality standards
                if (processed.length < 100) {
                    console.warn('‚ö†Ô∏è Processed response too short, may have lost content');
                }

                // Validate structure
                const hasBasicStructure = /\*\*.*\*\*/.test(processed);
                if (!hasBasicStructure && original.length > 200) {
                    console.warn('‚ö†Ô∏è Processed response lacks expected structure');
                }

                return processed;
            },

            // Helper methods
            findNextSectionStart: function(response, currentPos, structureMap) {
                let nextPos = response.length;

                Object.values(structureMap.sections).forEach(markers => {
                    markers.forEach(marker => {
                        if (marker.start > currentPos && marker.start < nextPos) {
                            nextPos = marker.start;
                        }
                    });
                });

                return nextPos;
            },

            rebuildWithSections: function(sections, original) {
                const orderedSections = ['summary', 'analysis', 'findings', 'metrics', 'conclusions', 'actions'];
                let result = '';

                orderedSections.forEach(section => {
                    if (sections[section]) {
                        result += sections[section].content + '\n\n';
                    }
                });

                return result.trim() || original;
            },

            identifyMissingSections: function(structureMap) {
                const expectedSections = ['summary', 'analysis', 'findings', 'metrics', 'conclusions'];
                const presentSections = Object.keys(structureMap.sections);

                return expectedSections.filter(section => !presentSections.includes(section));
            },

            addSectionHeader: function(response, section, contentAnalysis) {
                // Intelligent header insertion based on content analysis
                const header = `**${section.toUpperCase()}**`;

                // Find appropriate insertion point
                const lines = response.split('\n');
                let insertIndex = Math.floor(lines.length / 2); // Default to middle

                // Look for contextual clues
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].toLowerCase();
                    if (section === 'metrics' && (line.includes('number') || line.includes('percent'))) {
                        insertIndex = i;
                        break;
                    }
                    if (section === 'findings' && (line.includes('found') || line.includes('observed'))) {
                        insertIndex = i;
                        break;
                    }
                }

                lines.splice(insertIndex, 0, '', header, '');
                return lines.join('\n');
            },

            improveFormatting: function(response, contentAnalysis) {
                let improved = response;

                // Ensure consistent bullet points
                improved = improved.replace(/^[\-\*]\s*/gm, '- ');

                // Fix spacing around headers
                improved = improved.replace(/(\*\*.*?\*\*)\n([^\n])/g, '$1\n\n$2');

                // Clean up excessive whitespace
                improved = improved.replace(/\n{3,}/g, '\n\n');

                return improved;
            },

            consistentFormatting: function(response) {
                // Ensure consistent header formatting
                let consistent = response.replace(/\*{1,2}(.*?)\*{1,2}/g, '**$1**');

                // Consistent list formatting
                consistent = consistent.replace(/^[\-\*]\s*/gm, '- ');

                // Consistent spacing
                consistent = consistent.replace(/\n{3,}/g, '\n\n');

                return consistent;
            },

            improveReadability: function(response) {
                // Break up long paragraphs
                const sentences = response.split(/[.!?]+/);
                let readable = '';

                let paragraph = '';
                sentences.forEach(sentence => {
                    paragraph += sentence.trim() + '. ';
                    if (paragraph.length > 200) {
                        readable += paragraph.trim() + '\n\n';
                        paragraph = '';
                    }
                });

                if (paragraph) {
                    readable += paragraph.trim();
                }

                return readable || response;
            },

            addContextualEnhancements: function(response, contentAnalysis) {
                // Add subtle enhancements based on content analysis
                let enhanced = response;

                // Add quality indicators
                if (contentAnalysis.quality > 80) {
                    enhanced = 'üü¢ High Quality Analysis\n\n' + enhanced;
                } else if (contentAnalysis.quality < 50) {
                    enhanced = 'üü° Processing Enhanced\n\n' + enhanced;
                }

                return enhanced;
            }
        };

        // ========================================
        // UPDATED RESPONSE PROCESSING
        // ========================================

        // Replace the old enforceReportStructure with enhanced processing
        function enforceReportStructure(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            // Use enhanced processor for better content preservation
            return enhancedResponseProcessor.process(response, 'council_member');
        }

        function evaluateTemplateLiterals(response) {
            if (!response || typeof response !== 'string') {
                return response;
            }

            console.log('üîß Evaluating template literals in response...');
            
            // Get current context data for template substitution
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const changeCount = surveillanceState.changeCount || 0;
            const timestamp = new Date().toLocaleTimeString();
            const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
            const feedCount = aiFeeds.length;
            const memoryData = localStorage.getItem('ai_memory_state') || '{}';
            const memoryItems = Object.keys(JSON.parse(memoryData)).length;

            console.log(`üìä Context data - changeCount: ${changeCount}, canvasLength: ${canvasContent.length}, feedCount: ${feedCount}`);

            // Create evaluation context with all available data
            const context = {
                changeCount: changeCount,
                canvasContent: canvasContent,
                canvasLength: canvasContent.length,
                timestamp: timestamp,
                feedCount: feedCount,
                memoryItems: memoryItems,
                wordCount: canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length,
                lineCount: canvasContent.split('\n').length,
                activityLevel: calculateActivityLevel(canvasContent, feedCount, canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length),
                dataDensity: (canvasContent.split('\n').length > 0) ? (canvasContent.trim().split(/\s+/).filter(w => w.length > 0).length / canvasContent.split('\n').length).toFixed(1) : '0.0'
            };

            try {
                // Replace template literals with actual values
                let evaluatedResponse = response;

                // Check if response contains template literals
                const hasTemplates = /\$\{[^}]+\}/.test(evaluatedResponse);
                console.log(`üîç Response contains template literals: ${hasTemplates}`);

                // Handle common template patterns
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount\}/g, context.changeCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{canvasContent\.length\}/g, context.canvasLength);
                evaluatedResponse = evaluatedResponse.replace(/\$\{timestamp\}/g, context.timestamp);
                evaluatedResponse = evaluatedResponse.replace(/\$\{feedCount\}/g, context.feedCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{memoryItems\}/g, context.memoryItems);
                evaluatedResponse = evaluatedResponse.replace(/\$\{wordCount\}/g, context.wordCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{lineCount\}/g, context.lineCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{activityLevel\}/g, context.activityLevel);
                evaluatedResponse = evaluatedResponse.replace(/\$\{dataDensity\}/g, context.dataDensity);

                // Handle conditional template expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount > 5 \? 'high' : 'moderate'\}/g, context.changeCount > 5 ? 'high' : 'moderate');
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount > 10 \? 'mature' : changeCount > 5 \? 'growing' : 'initial'\}/g, context.changeCount > 10 ? 'mature' : context.changeCount > 5 ? 'growing' : 'initial');
                evaluatedResponse = evaluatedResponse.replace(/\$\{canvasLength > 1000 \? 'complex' : 'emerging'\}/g, context.canvasLength > 1000 ? 'complex' : 'emerging');
                evaluatedResponse = evaluatedResponse.replace(/\$\{text\.includes\('governance'\) \? 'specific rules' : 'overall strategy'\}/g, canvasContent.toLowerCase().includes('governance') ? 'specific rules' : 'overall strategy');
                evaluatedResponse = evaluatedResponse.replace(/\$\{feedCount > 0 \? 'ACTIVE' : 'IDLE'\}/g, context.feedCount > 0 ? 'ACTIVE' : 'IDLE');
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(changeCount \* 15, 100\)\}/g, Math.min(context.changeCount * 15, 100));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(changeCount, 10\)\}/g, Math.min(context.changeCount, 10));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(canvasLength \/ 100, 100\)\}/g, Math.min(context.canvasLength / 100, 100));
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.min\(wordCount \/ 10, 100\)\}/g, Math.min(context.wordCount / 10, 100));

                // Handle more complex expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{changeCount \* 10 \% 100\}/g, (context.changeCount * 10) % 100);
                evaluatedResponse = evaluatedResponse.replace(/\$\{Math\.abs\(canvasLength - \d+\)\}/g, (match) => {
                    const targetLength = parseInt(match.match(/\d+/)[0]);
                    return Math.abs(context.canvasLength - targetLength);
                });

                // Handle array length expressions
                evaluatedResponse = evaluatedResponse.replace(/\$\{aiFeeds\.length\}/g, context.feedCount);
                evaluatedResponse = evaluatedResponse.replace(/\$\{Array\.isArray\(analysis\.data\) \? analysis\.data\.length : 'N\/A'\}/g, 'N/A'); // Default to N/A for unknown data

                return evaluatedResponse;
            } catch (error) {
                console.warn('Template literal evaluation failed:', error);
                return response; // Return original response if evaluation fails
            }
        }

        // ========================================
        // COUNCIL MEMORY SYSTEM
        // ========================================

        const councilMemories = {
            pattern: [],
            wisdom: [],
            paradox: [],
            boundaries: [],
            memory: []
        };

        function initializeCouncilMemories() {
            // Initialize fresh memories each session for optimal analysis
            updateCouncilStatusDisplay();
        }

        function storeCouncilMemory(memberKey, analysis, context) {
            const memory = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                analysis: analysis,
                context: context,
                eventType: context.type || 'unknown',
                canvasLength: context.canvasLength || 0,
                insights: extractInsightsFromAnalysis(analysis)
            };

            councilMemories[memberKey].push(memory);

            // Keep last 50 memories per member
            if (councilMemories[memberKey].length > 50) {
                councilMemories[memberKey] = councilMemories[memberKey].slice(-50);
            }

            // Session-only memories - no persistence for fresh analysis each session
            updateCouncilStatusDisplay();
        }

        function extractInsightsFromAnalysis(analysis) {
            const insights = [];

            // Extract key patterns from analysis
            const patterns = analysis.match(/(?:pattern|trend|behavior|issue|concern|opportunity|risk)[\w\s]{10,50}/gi) || [];
            insights.push(...patterns.slice(0, 3));

            // Extract metrics
            const metrics = analysis.match(/\d+[%]?|\b(?:high|low|critical|normal)\b/gi) || [];
            insights.push(...metrics.slice(0, 3));

            return insights;
        }

        function getRelevantMemories(memberKey, currentContext) {
            const memories = councilMemories[memberKey] || [];
            if (memories.length < 3) return []; // Don't use memories until we have some history

            // Only find memories if there's a strong contextual match
            const relevantMemories = memories.filter(memory => {
                // Same event type
                if (currentContext.type && memory.eventType === currentContext.type) return true;

                // Similar content size (major changes only)
                if (currentContext.canvasLength && memory.canvasLength > 0) {
                    const sizeDiff = Math.abs(memory.canvasLength - currentContext.canvasLength);
                    if (sizeDiff < 500 && currentContext.canvasLength > 2000) return true; // Similar substantial content
                }

                // Look for recurring insights/patterns
                if (memory.insights && memory.insights.length > 0) {
                    const currentAnalysis = currentContext.analysis || '';
                    const hasMatchingInsight = memory.insights.some(insight =>
                        currentAnalysis.toLowerCase().includes(insight.toLowerCase().substring(0, 20))
                    );
                    if (hasMatchingInsight) return true;
                }

                return false;
            });

            // Only return memories if we found genuinely relevant ones
            if (relevantMemories.length === 0) return [];

            return relevantMemories
                .slice(-5) // Maximum 5 relevant memories
                .map(memory => ({
                    timestamp: new Date(memory.timestamp).toLocaleTimeString(),
                    analysis: memory.analysis.substring(0, 150),
                    insights: memory.insights.slice(0, 2),
                    relevance: memory.eventType === currentContext.type ? 'high' : 'medium'
                }));
        }

        function shouldUseMemories(memberKey, currentContext) {
            const relevantMemories = getRelevantMemories(memberKey, currentContext);
            return relevantMemories.length > 0;
        }

        function updateCouncilStatusDisplay() {
            const statusElement = document.getElementById('councilMemberStatus');
            if (!statusElement) return;

            const statusHTML = [
                `PATTERN: ‚úÖ (${councilMemories.pattern.length} memories)`,
                `WISDOM: ‚úÖ (${councilMemories.wisdom.length} memories)`,
                `PARADOX: ‚úÖ (${councilMemories.paradox.length} memories)`,
                `BOUNDARIES: ‚úÖ (${councilMemories.boundaries.length} memories)`,
                `MEMORY: ‚úÖ (${councilMemories.memory.length} memories)`
            ].join('<br>');

            statusElement.innerHTML = statusHTML;
        }

        // ========================================
        // COLLABORATIVE ANALYSIS HELPERS
        // ========================================

        function extractKeyInsights(responses) {
            const insights = {
                patterns: [],
                metrics: [],
                concerns: [],
                recommendations: [],
                crossReferences: []
            };

            responses.forEach(response => {
                if (!response || response.error) return;

                const text = response.response || '';
                const memberType = response.member || 'unknown';

                // Extract metrics (numbers, percentages, specific measurements)
                const metricMatches = text.match(/\d+[%]?|\b(?:high|low|critical|normal|optimal|severe)\b/gi) || [];
                insights.metrics.push(...metricMatches.map(m => `${memberType}: ${m}`));

                // Extract pattern keywords
                const patternMatches = text.match(/(?:pattern|trend|behavior|cycle|routine|structure|framework|system|model|approach|method)\s+[a-z\s]{5,30}/gi) || [];
                insights.patterns.push(...patternMatches.map(m => `${memberType}: ${m.trim()}`));

                // Extract concerns and issues
                const concernMatches = text.match(/(?:concern|issue|problem|risk|threat|vulnerability|challenge|limitation|gap|error|failure)\s+[a-z\s]{5,40}/gi) || [];
                insights.concerns.push(...concernMatches.map(m => `${memberType}: ${m.trim()}`));

                // Extract recommendations and actions
                const actionMatches = text.match(/(?:recommend|suggest|propose|should|must|need to|implement|consider|improve|optimize|enhance|address)\s+[a-z\s]{5,50}/gi) || [];
                insights.recommendations.push(...actionMatches.map(m => `${memberType}: ${m.trim()}`));

                // Look for cross-references to other systems or concepts
                const crossRefMatches = text.match(/(?:connects to|relates to|correlates with|links to|impacts|influences|depends on|affects)\s+[a-z\s]{5,30}/gi) || [];
                insights.crossReferences.push(...crossRefMatches.map(m => `${memberType}: ${m.trim()}`));
            });

            // Remove duplicates and limit size
            Object.keys(insights).forEach(key => {
                insights[key] = [...new Set(insights[key])].slice(0, 5);
            });

            return insights;
        }

        function enhancePromptWithInsights(basePrompt, priorInsights, memberType) {
            const relevantInsights = filterInsightsForMember(priorInsights, memberType);

            if (relevantInsights.length === 0) {
                return basePrompt;
            }

            const insightContext = `\n\n=== COUNCIL COLLABORATION CONTEXT ===\nPrior analysis from other council members revealed:\n${relevantInsights.join('\n')}\n\nBuild upon these insights in your analysis. Look for correlations, contradictions, or complementary perspectives. Your unique ${memberType} perspective should enhance and connect with these findings.\n========================\n\n`;

            return basePrompt + insightContext;
        }

        function filterInsightsForMember(insights, memberType) {
            const relevantInsights = [];

            // Each member type gets different types of insights to build upon
            switch(memberType) {
                case 'paradox':
                    // Paradox looks for contradictions and tensions
                    relevantInsights.push(...insights.patterns);
                    relevantInsights.push(...insights.concerns);
                    break;

                case 'boundaries':
                    // Boundaries examines limits and constraints
                    relevantInsights.push(...insights.metrics);
                    relevantInsights.push(...insights.recommendations);
                    break;

                case 'memory':
                    // Memory synthesizes all insights
                    relevantInsights.push(...insights.patterns);
                    relevantInsights.push(...insights.crossReferences);
                    relevantInsights.push(...insights.concerns);
                    break;

                default:
                    // Default gets a mix
                    relevantInsights.push(...insights.patterns.slice(0, 2));
                    relevantInsights.push(...insights.metrics.slice(0, 2));
                    break;
            }

            return relevantInsights.slice(0, 6); // Limit to prevent prompt bloat
        }

        function synthesizeCollaborativeConsensus(responses, analysis, insightHistory) {
            // First get standard consensus
            const baseConsensus = synthesizeConsensus(responses, analysis);

            // Enhance with cross-pollination analysis
            const collaborationMetrics = analyzeCollaboration(insightHistory);

            // Add collaboration insights to consensus
            baseConsensus.collaborationScore = collaborationMetrics.score;
            baseConsensus.crossPollination = collaborationMetrics.connections;
            baseConsensus.emergentInsights = collaborationMetrics.emergentPatterns;

            return baseConsensus;
        }

        function analyzeCollaboration(insightHistory) {
            const connections = [];
            let score = 0;
            const emergentPatterns = [];

            // Analyze how insights evolved across stages
            if (insightHistory.stage1Insights && insightHistory.stage2Insights) {
                // Look for build-up patterns
                const stage1Patterns = new Set(insightHistory.stage1Insights.patterns);
                const stage2Patterns = new Set(insightHistory.stage2Insights.patterns);

                // Find connections
                stage1Patterns.forEach(pattern => {
                    if ([...stage2Patterns].some(p2 => p2.includes(pattern.split(':')[1]?.trim()))) {
                        connections.push(`Pattern evolution: ${pattern}`);
                        score += 10;
                    }
                });

                // Look for emergent insights (unique to later stages)
                const stage2Unique = [...stage2Patterns].filter(p =>
                    ![...stage1Patterns].some(p1 => p.includes(p1.split(':')[1]?.trim()))
                );
                emergentPatterns.push(...stage2Unique.slice(0, 3));
            }

            // Calculate collaboration effectiveness
            score += connections.length * 5;
            score += emergentPatterns.length * 8;
            score = Math.min(score, 100); // Cap at 100

            return {
                score,
                connections,
                emergentPatterns
            };
        }

        async function synthesizeConsensus(responses, analysis) {
            const validResponses = responses.filter(r => !r.error);

            if (validResponses.length === 0) {
                return {
                    status: 'FAILED',
                    summary: 'Council analysis failed - no valid responses',
                    confidence: 0
                };
            }

            // Create AI-powered consensus synthesis prompt
            const consensusPrompt = `DJINN COUNCIL CONSENSUS SYNTHESIS
SESSION: ${djinnCouncilMemory.sessionId}

COUNCIL ANALYSES (${validResponses.length} members):
${validResponses.map(r => `
[${councilMembers[r.member].name.toUpperCase()}]
${r.response.substring(0, 500)}${r.response.length > 500 ? '...' : ''}
`).join('\n')}

CRITICAL REQUIREMENTS:
- SYNTHESIZE new insights from member analyses (do not repeat member content)
- Identify PATTERNS ACROSS all members (not individual findings)
- Create COLLABORATIVE conclusions that emerge from cross-pollination
- Focus on SYSTEMIC themes, not individual member observations

Output concise synthesis (max 600 words):

**SYNTHESIS OVERVIEW**
[2-3 sentences synthesizing collective insights - what emerges when all members' perspectives are combined?]

**CROSS-MEMBER PATTERNS**
‚Ä¢ [Pattern that appears across multiple members]
‚Ä¢ [Systemic theme identified in the collective analysis]
‚Ä¢ [Collaborative insight that emerges from cross-pollination]

**EMERGENT INSIGHTS**
‚Ä¢ [New insight that emerges from combining member perspectives]
‚Ä¢ [Collaborative conclusion not present in individual analyses]
‚Ä¢ [Systemic pattern revealed through council integration]

**RISK ASSESSMENT**
[Synthesized risk evaluation considering all member perspectives together]

**STRATEGIC RECOMMENDATIONS**
1. [Recommendation based on collective council wisdom]
2. [Cross-member optimization strategy]
3. [Systemic improvement derived from council synthesis]

**CONFIDENCE LEVEL**
[High/Medium/Low with justification based on consensus strength]

Keep under 600 words. Focus on SYNTHESIS, not repetition. Create NEW insights from COLLABORATION.`;

            try {
                // Use gemma3:1b for consensus synthesis
                const consensusResponse = await queryOllama('gemma3:1b', consensusPrompt);

                // Parse the AI-generated consensus
                const synthesisMatch = consensusResponse.match(/\*\*SYNTHESIS OVERVIEW\*\*(.*?)(?=\*\*CROSS-MEMBER PATTERNS\*\*|$)/s);
                const patternsMatch = consensusResponse.match(/\*\*CROSS-MEMBER PATTERNS\*\*(.*?)(?=\*\*EMERGENT INSIGHTS\*\*|$)/s);
                const insightsMatch = consensusResponse.match(/\*\*EMERGENT INSIGHTS\*\*(.*?)(?=\*\*RISK ASSESSMENT\*\*|$)/s);
                const riskMatch = consensusResponse.match(/\*\*RISK ASSESSMENT\*\*(.*?)(?=\*\*STRATEGIC RECOMMENDATIONS\*\*|$)/s);
                const recommendationsMatch = consensusResponse.match(/\*\*STRATEGIC RECOMMENDATIONS\*\*(.*?)(?=\*\*CONFIDENCE LEVEL\*\*|$)/s);
                const confidenceMatch = consensusResponse.match(/\*\*CONFIDENCE LEVEL\*\*(.*)$/s);

                const synthesis = synthesisMatch ? synthesisMatch[1].trim() : 'Consensus synthesis completed';
                const patterns = patternsMatch ? patternsMatch[1].trim() : 'Cross-member analysis completed';
                const insights = insightsMatch ? insightsMatch[1].trim() : 'Emergent insights identified';
                const riskAssessment = riskMatch ? riskMatch[1].trim() : 'Risk assessment completed';
                const recommendations = recommendationsMatch ? recommendationsMatch[1].trim() : 'Strategic recommendations provided';
                const confidence = confidenceMatch ? confidenceMatch[1].trim() : 'High';

                // Calculate confidence score from AI response
                let confidenceScore = 0.7; // Default medium confidence
                if (confidence.toLowerCase().includes('high')) confidenceScore = 0.9;
                else if (confidence.toLowerCase().includes('low')) confidenceScore = 0.4;

                // Extract key insights from each member response for display
                const memberInsights = validResponses.map(r => {
                    const memberName = councilMembers[r.member].name;
                    const response = r.response;

                    // Parse metrics more intelligently with better fallbacks
                    let formattedMetrics = '';
                    let formattedAnalysis = '';

                    // Try multiple patterns to extract metrics
                    let metricsMatch = response.match(/\*\*METRICS\*\*(.*?)(?=\*\*ANALYSIS\*\*|\*\*CONCLUSIONS\*\*|\*\*ACTIONS\*\*|$)/s) ||
                                     response.match(/\*METRICS\*(.*?)(?=\*ANALYSIS\*|\*CONCLUSIONS\*|\*ACTIONS\*|$)/s) ||
                                     response.match(/METRICS:(.*?)(?=ANALYSIS:|CONCLUSIONS:|ACTIONS:|$)/s);

                    if (metricsMatch) {
                        const metricsText = metricsMatch[1].trim();
                        const metricLines = metricsText.split('\n').filter(line => line.trim() && !line.includes('**') && !line.includes('['));

                        // Parse each metric line into structured format
                        const parsedMetrics = metricLines.map(line => {
                            // Handle metric lines with values and justifications
                            const valueMatch = line.match(/^([^:]+):\s*([^,]+)(?:,\s*Justification:\s*(.+))?$/);
                            if (valueMatch) {
                                const metricName = valueMatch[1].trim();
                                const metricValue = valueMatch[2].trim();
                                const justification = valueMatch[3] ? valueMatch[3].trim() : null;

                                if (justification) {
                                    return `<div style="margin: 2px 0;"><strong>${metricName}:</strong> <span style="color: #ffff00;">${metricValue}</span><br><small style="color: #cccccc;">${justification}</small></div>`;
                                } else {
                                    return `<strong>${metricName}:</strong> <span style="color: #ffff00;">${metricValue}</span>`;
                                }
                            }

                            // Fallback for other formats
                            const colonMatch = line.match(/^([^:]+):\s*(.+)$/);
                            if (colonMatch) {
                                const key = colonMatch[1].trim();
                                const value = colonMatch[2].trim();
                                return `<strong>${key}:</strong> ${value}`;
                            }
                            return line.trim();
                        }).filter(metric => metric.length > 0);

                        formattedMetrics = parsedMetrics.join('<br>') || `Processing ${memberName} data...`;
                    } else {
                        // Extract any numerical patterns as fallback metrics
                        const numberMatches = response.match(/\d+\.?\d*%|\d+\/\d+|\d+\s*(systems?|items?|reports?)/gi);
                        if (numberMatches) {
                            formattedMetrics = numberMatches.slice(0, 3).join(' ‚Ä¢ ');
                        } else {
                            formattedMetrics = `${memberName} analysis in progress`;
                        }
                    }

                    // Extract analysis section with multiple fallback patterns
                    let analysisMatch = response.match(/\*\*ANALYSIS\*\*(.*?)(?=\*\*FINDINGS\*\*|\*\*CONCLUSIONS\*\*|\*\*ACTIONS\*\*|$)/s) ||
                                      response.match(/\*ANALYSIS\*(.*?)(?=\*FINDINGS\*|\*CONCLUSIONS\*|\*ACTIONS\*|$)/s) ||
                                      response.match(/ANALYSIS:(.*?)(?=FINDINGS:|CONCLUSIONS:|ACTIONS:|$)/s);

                    if (analysisMatch) {
                        let analysisText = analysisMatch[1].trim();
                        // Clean up the analysis text more thoroughly
                        analysisText = analysisText
                            .replace(/\*\*CONCLUSIONS\*\*.*/s, '')
                            .replace(/\*\*ACTIONS\*\*.*/s, '')
                            .replace(/^\s*[-‚Ä¢*]\s*/gm, '')
                            .replace(/\s+/g, ' ')
                            .replace(/\*\*.*?\*\*/g, '')
                            .trim();

                        formattedAnalysis = analysisText || `${memberName} synthesis complete`;
                    } else {
                        // Use first meaningful paragraph as fallback
                        const paragraphs = response.split('\n').filter(p => p.trim().length > 50);
                        if (paragraphs.length > 0) {
                            formattedAnalysis = paragraphs[0].trim().substring(0, 200) + '...';
                        } else {
                            formattedAnalysis = `${memberName} specialized analysis complete`;
                        }
                    }

                    return `<div style="margin: 6px 0; padding: 6px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                        <strong>${memberName}:</strong><br>
                        <div style="margin: 4px 0; color: #00ff88; font-size: 10px;">${formattedMetrics}</div>
                        <div style="margin: 4px 0; color: #ffffff; font-size: 11px; line-height: 1.3;">${formattedAnalysis}</div>
                    </div>`;
                }).join('');

                // Build AI-powered consensus object
                const consensusResult = {
                    status: 'APPROVED',
                    summary: synthesis,
                    confidence: confidenceScore,
                    theme: 'ai_synthesized_consensus',
                    responses: validResponses,
                    crossMemberPatterns: patterns,
                    emergentInsights: insights,
                    riskAssessment: { overall: riskAssessment },
                    recommendations: recommendations.split('\n').filter(line => line.trim().startsWith('1.') || line.trim().startsWith('2.') || line.trim().startsWith('3.')).map(line => line.trim().substring(3).trim()),
                    collaborationScore: Math.round(confidenceScore * 100),
                    crossPollination: patterns.split('‚Ä¢').filter(item => item.trim()).slice(0, 3).map(item => item.trim()),
                    emergentInsights: insights.split('‚Ä¢').filter(item => item.trim()).slice(0, 2).map(item => item.trim())
                };

                // Add collaboration metrics
                const collaborationSection = `
                    <strong>üîÑ AI-POWERED COLLABORATIVE SYNTHESIS</strong><br>
                    <div style="margin: 8px 0; padding: 8px; background: rgba(0, 170, 255, 0.1); border-left: 3px solid #00aaff; border-radius: 4px;">
                        <div style="color: #00ff88; font-weight: bold;">AI Synthesis Confidence: ${Math.round(confidenceScore * 100)}%</div>
                        <div style="margin-top: 4px; font-size: 10px;">Cross-Member Patterns: ${consensusResult.crossPollination?.length || 0} identified</div>
                        <div style="margin-top: 4px; font-size: 10px; color: #ff88ff;">Emergent Insights: ${consensusResult.emergentInsights?.length || 0} synthesized</div>
                    </div>`;

                // Update consensus display with AI-synthesized insights
                const consensusHTML = `
                    <div class="intel-entry intel-insight">
                        <div class="intel-timestamp">${new Date().toLocaleTimeString()}</div>
                        <strong>üß† AI-SYNTHESIZED COUNCIL CONSENSUS</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(204, 136, 204, 0.1); border-left: 3px solid #cc88cc; border-radius: 4px;">
                            ${synthesis}
                        </div>
                        <strong>üîç MEMBER ANALYSES</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(0, 255, 136, 0.1); border-left: 3px solid #00ff88; border-radius: 4px;">
                            ${memberInsights}
                        </div>
                        ${collaborationSection}
                        <strong>üéØ AI RISK ASSESSMENT</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255, 170, 0, 0.1); border-left: 3px solid #ffaa00; border-radius: 4px;">
                            ${riskAssessment}
                        </div>
                        <strong>üìã AI STRATEGIC RECOMMENDATIONS</strong><br>
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255, 136, 255, 0.1); border-left: 3px solid #ff88ff; border-radius: 4px;">
                            ${recommendations}
                        </div>
                    </div>
                `;

                document.getElementById('consensusFeed').innerHTML = consensusHTML + document.getElementById('consensusFeed').innerHTML;

                return consensusResult;

            } catch (error) {
                console.error('AI consensus synthesis failed:', error);

                // Fallback to basic consensus if AI fails
                const themes = {
                    governance_gap: 0,
                    performance_issue: 0,
                    innovation_opportunity: 0,
                    sovereignty_concern: 0,
                    memory_anomaly: 0
                };

                validResponses.forEach(r => {
                    const text = r.response.toLowerCase();
                    if (text.includes('governance') || text.includes('authority')) themes.governance_gap++;
                    if (text.includes('performance') || text.includes('efficiency')) themes.performance_issue++;
                    if (text.includes('innovation') || text.includes('opportunity')) themes.innovation_opportunity++;
                    if (text.includes('autonomy') || text.includes('sovereignty')) themes.sovereignty_concern++;
                    if (text.includes('memory') || text.includes('retention')) themes.memory_anomaly++;
                });

                const primaryTheme = Object.entries(themes).sort((a, b) => b[1] - a[1])[0][0];
                const confidence = validResponses.length / 5;

                const summary = `AI synthesis failed - using basic consensus. Primary concern: ${primaryTheme.replace('_', ' ')}. Confidence: ${(confidence * 100).toFixed(0)}%.`;

                return {
                    status: 'DEGRADED',
                    summary: summary,
                    confidence: confidence,
                    theme: primaryTheme,
                    responses: validResponses,
                    error: 'AI synthesis unavailable'
                };
            }
        }

        // ========================================
        // INTELLIGENCE MANAGEMENT
        // ========================================

        async function generateIntelligenceEntry(analysis, consensus) {
            const severity = consensus.confidence > 0.8 ? 'critical' :
                           consensus.confidence > 0.6 ? 'warning' : 'insight';

            // Generate unified AI-powered intelligence report
            let intelligenceReport;
            try {
                intelligenceReport = await generateUnifiedIntelligence(analysis, consensus);
            } catch (error) {
                console.error('Intelligence generation failed:', error);
                intelligenceReport = {
                    actionable: ['Intelligence synthesis failed', 'Manual analysis required', 'Check system logs'],
                    correlations: 'Analysis failed due to AI synthesis error',
                    recommendations: 'Manual intelligence assessment needed',
                    risk_assessment: 'Unable to assess risks automatically',
                    strategic_implications: 'Strategic analysis unavailable'
                };
            }

            return {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                type: analysis.type || 'intelligence_report',
                severity: severity,
                theme: consensus.theme || 'intelligence_synthesis',
                summary: consensus.summary || 'AI-powered intelligence analysis completed',
                data: analysis.data,
                consensus: consensus,
                actionable: intelligenceReport.actionable,
                correlations: intelligenceReport.correlations,
                recommendations: intelligenceReport.recommendations,
                risk_assessment: intelligenceReport.risk_assessment,
                strategic_implications: intelligenceReport.strategic_implications
            };
        }

        async function generateUnifiedIntelligence(analysis, consensus) {
            // Use the validation specialist to synthesize intelligence reports
            return await validationSpecialist.synthesizeIntelligenceReport(analysis, consensus);
        }

        // Add intelligence synthesis capability to validation specialist
        validationSpecialist.synthesizeIntelligenceReport = async function(analysis, consensus) {
            const hasConsensus = consensus && consensus.responses && consensus.responses.length > 0;

            if (hasConsensus) {
                try {
                    const allResponses = consensus.responses || [];
                    const responseTexts = allResponses.map(r => `${councilMembers[r.member].name}: ${r.response}`).join('\n\n');

                    // Get intelligence package data
                    const intelligencePackage = generateIntelligencePackage();

                    // Build validation specialist context from memory
                    const validationContext = this.buildValidationContext();

                    const specialistPrompt = `INTELLIGENCE SYNTHESIS - VALIDATION SPECIALIST ANALYSIS

You are the DJINN Council's Chief Validation Specialist with deep expertise in critiquing and synthesizing intelligence. Your role is to craft masterful intelligence documents from council deliberations.

=== YOUR ACCUMULATED EXPERTISE ===
Validations Performed: ${this.memory.validationHistory.length}
Council Sessions Analyzed: ${Object.keys(this.memory.councilInsights).length}
${validationContext}

=== CURRENT SESSION ANALYSIS ===

COUNCIL DELIBERATIONS:
${responseTexts}

FACTUAL DATA FOUNDATION:
‚Ä¢ Content Length: ${analysis.data?.content?.length || 0} characters
‚Ä¢ Session Duration: ${Math.round(intelligencePackage.sessionMetadata.duration / 60000)} minutes
‚Ä¢ Council Reports Generated: ${intelligencePackage.sessionMetadata.totalReports}

DOCUMENT EVOLUTION:
${analysis.data.documentEvolution ? JSON.stringify(analysis.data.documentEvolution).substring(0, 600) : 'Static analysis - no recent content changes'}

=== INTELLIGENCE SYNTHESIS DIRECTIVE ===

As the validation specialist, synthesize this council session into a structured intelligence document. Apply your critical analysis expertise to ensure factual accuracy and actionable insights.

Provide structured analysis in these exact sections:

[EXECUTIVE_SUMMARY]
Single paragraph distilling core intelligence findings

[FACTUAL_ASSESSMENT]
Concrete observations from council analysis, verified against source data

[STRATEGIC_CORRELATIONS]
Cross-council insights showing analytical convergence/divergence

[RISK_EVALUATION]
Specific risks with severity assessment (Critical/High/Medium/Low)

[ACTIONABLE_INTELLIGENCE]
‚Ä¢ Immediate actions (24-48 hours)
‚Ä¢ Strategic initiatives (1-2 weeks)
‚Ä¢ Long-term considerations (1+ months)

[VALIDATION_CONFIDENCE]
Your assessment of analytical certainty and data limitations

CRITICAL: Apply your validation expertise - reject speculation, demand factual grounding, ensure actionability. This intelligence document must meet your quality standards.`;

                    // Query validation specialist AI for intelligence synthesis
                    const intelligenceResponse = await queryOllama('gemma3:1b', specialistPrompt);

                    // Parse structured response using validation specialist expertise
                    const sections = {
                        executive: this.extractSection(intelligenceResponse, 'EXECUTIVE_SUMMARY'),
                        factual: this.extractSection(intelligenceResponse, 'FACTUAL_ASSESSMENT'),
                        correlations: this.extractSection(intelligenceResponse, 'STRATEGIC_CORRELATIONS'),
                        risks: this.extractSection(intelligenceResponse, 'RISK_EVALUATION'),
                        actionable: this.extractSection(intelligenceResponse, 'ACTIONABLE_INTELLIGENCE'),
                        confidence: this.extractSection(intelligenceResponse, 'VALIDATION_CONFIDENCE')
                    };

                    // Record this synthesis in memory for learning
                    this.recordIntelligenceSynthesis(analysis, consensus, sections);

                    // Format actionable items
                    const actionableItems = sections.actionable.split('\n')
                        .filter(line => line.trim().startsWith('‚Ä¢'))
                        .map(line => line.trim().substring(1).trim())
                        .filter(item => item.length > 0);

                    return {
                        actionable: actionableItems.length > 0 ? actionableItems : ['Conduct follow-up analysis', 'Monitor system behavior', 'Review validation findings'],
                        correlations: sections.correlations,
                        recommendations: sections.actionable,
                        risk_assessment: sections.risks,
                        strategic_implications: `${sections.executive}\n\nConfidence Assessment: ${sections.confidence}`,
                        synthesis_quality: 'validation_specialist_crafted'
                    };

                } catch (error) {
                    console.error('Validation specialist intelligence synthesis failed:', error);
                    return this.generateFailsafeIntelligence(error);
                }
            } else {
                // Standalone analysis without council consensus
                return this.generateStandaloneIntelligence(analysis);
            }
        };

        // Add context building method to validation specialist
        validationSpecialist.buildValidationContext = function() {
            if (this.memory.validationHistory.length === 0) {
                return "Fresh validation specialist - building expertise from this session";
            }

            const recentValidations = this.memory.validationHistory.slice(0, 10);
            const commonIssues = {};

            recentValidations.forEach(v => {
                v.issues.forEach(issue => {
                    commonIssues[issue] = (commonIssues[issue] || 0) + 1;
                });
            });

            const topIssues = Object.entries(commonIssues)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 3)
                .map(([issue, count]) => `${issue} (${count}x)`);

            return `
Recent Validation Patterns:
‚Ä¢ Common Quality Issues: ${topIssues.join(', ')}
‚Ä¢ Council Members Analyzed: ${Object.keys(this.memory.councilInsights).join(', ')}
‚Ä¢ Expertise Level: ${this.memory.validationHistory.length < 20 ? 'Building' : this.memory.validationHistory.length < 50 ? 'Experienced' : 'Expert'}`;
        };

        // Add section extraction method
        validationSpecialist.extractSection = function(text, sectionName) {
            const regex = new RegExp(`\\[${sectionName}\\](.*?)(?=\\[|$)`, 's');
            const match = text.match(regex);
            return match ? match[1].trim() : `${sectionName.replace('_', ' ').toLowerCase()} analysis pending`;
        };

        // Record intelligence synthesis for learning
        validationSpecialist.recordIntelligenceSynthesis = function(analysis, consensus, sections) {
            const synthesis = {
                timestamp: new Date().toISOString(),
                analysisType: analysis.type,
                councilMembers: consensus.responses ? consensus.responses.map(r => r.member) : [],
                qualityMetrics: {
                    sectionsCompleted: Object.values(sections).filter(s => s.length > 50).length,
                    confidenceLevel: sections.confidence.length > 20 ? 'high' : 'low'
                }
            };

            this.memory.synthesisExpertise.unshift(synthesis);

            // Limit synthesis memory
            if (this.memory.synthesisExpertise.length > 50) {
                this.memory.synthesisExpertise = this.memory.synthesisExpertise.slice(0, 50);
            }

            this.saveMemory();
        };

        // Failsafe intelligence generation
        validationSpecialist.generateFailsafeIntelligence = function(error) {
            return {
                actionable: ['Intelligence synthesis failed - manual analysis required', 'Review system logs for errors', 'Validate council member responses manually'],
                correlations: `Validation specialist encountered synthesis error: ${error.message}`,
                recommendations: 'System requires manual intelligence assessment due to AI synthesis failure',
                risk_assessment: 'Unable to assess risks automatically - manual validation needed',
                strategic_implications: 'Strategic analysis unavailable due to synthesis system error',
                synthesis_quality: 'failsafe_generated'
            };
        };

        // Standalone analysis for cases without council consensus
        validationSpecialist.generateStandaloneIntelligence = function(analysis) {
            return {
                actionable: ['Generate council consensus before intelligence synthesis', 'Trigger full council analysis', 'Ensure adequate data for synthesis'],
                correlations: 'No council consensus available for correlation analysis',
                recommendations: 'Council deliberation required before intelligence document generation',
                risk_assessment: 'Risk assessment requires council member analysis',
                strategic_implications: 'Strategic implications pending council consensus',
                synthesis_quality: 'standalone_limited'
            };
        };

        // Refinement Specialist AI Agent - Triangulated Validation Partner
        const refinementSpecialist = {
            sessionId: `refinement_${Date.now()}`,
            memory: {
                coachingHistory: [],      // All coaching sessions performed
                communicationPatterns: {}, // What works for each validator-member pair
                interventionTechniques: [], // Successful coaching methods
                difficultyAnalysis: {},    // Analysis of why reports fail
                triangulationResults: []   // Outcomes of 3-way validation
            },

            // Load existing memory
            loadMemory() {
                try {
                    const stored = localStorage.getItem('refinement_specialist_memory');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.memory = { ...this.memory, ...data };
                        console.log(`üîß Refinement Specialist loaded ${this.memory.coachingHistory.length} coaching memories`);
                    }
                } catch (error) {
                    console.error('Failed to load refinement specialist memory:', error);
                }
            },

            // Save memory to localStorage
            saveMemory() {
                try {
                    localStorage.setItem('refinement_specialist_memory', JSON.stringify(this.memory));
                } catch (error) {
                    console.error('Failed to save refinement specialist memory:', error);
                }
            },

            // Analyze validation interaction for coaching opportunities
            async analyzeValidationInteraction(memberKey, originalResponse, validationFeedback, attempt) {
                const analysisPrompt = `REFINEMENT COACHING ANALYSIS

You are a Refinement Specialist AI - an expert in improving AI-to-AI communication and report quality. Your role is to analyze validation interactions and provide coaching to both the validator and council member.

=== YOUR EXPERTISE ===
Coaching Sessions: ${this.memory.coachingHistory.length}
Communication Patterns Known: ${Object.keys(this.memory.communicationPatterns).length}
Successful Interventions: ${this.memory.interventionTechniques.length}

=== CURRENT SITUATION ===
Council Member: ${councilMembers[memberKey].name}
Attempt Number: ${attempt}
Original Response Length: ${originalResponse.length} characters

COUNCIL MEMBER RESPONSE:
${originalResponse.substring(0, 800)}

VALIDATOR FEEDBACK:
${validationFeedback}

=== COACHING ANALYSIS NEEDED ===

[COMMUNICATION_GAP_ANALYSIS]
What specific communication disconnect exists between validator and council member?

[VALIDATOR_COACHING]
How can the validator better guide this specific council member? What approach would be more effective?

[MEMBER_COACHING]
What does this council member need to understand about the validation requirements? What's the core issue?

[INTERVENTION_STRATEGY]
What specific coaching intervention would resolve this validation failure?

[PATTERN_RECOGNITION]
Is this a recurring pattern? What similar cases have you seen?

Provide detailed coaching analysis to improve both parties' performance.`;

                try {
                    const coachingAnalysis = await queryOllama('gemma3:1b', analysisPrompt);

                    // Record this coaching session
                    this.recordCoachingSession(memberKey, originalResponse, validationFeedback, coachingAnalysis, attempt);

                    return this.parseCoachingAnalysis(coachingAnalysis);
                } catch (error) {
                    console.error('Refinement specialist analysis failed:', error);
                    return this.generateFallbackCoaching(memberKey, validationFeedback);
                }
            },

            // Record coaching session for learning
            recordCoachingSession(memberKey, originalResponse, validationFeedback, coachingAnalysis, attempt) {
                const session = {
                    timestamp: new Date().toISOString(),
                    member: memberKey,
                    attempt: attempt,
                    originalLength: originalResponse.length,
                    validationIssues: this.extractValidationIssues(validationFeedback),
                    coachingProvided: coachingAnalysis.substring(0, 500),
                    sessionType: 'triangulated_validation'
                };

                this.memory.coachingHistory.unshift(session);

                // Update communication patterns
                if (!this.memory.communicationPatterns[memberKey]) {
                    this.memory.communicationPatterns[memberKey] = {
                        commonIssues: [],
                        effectiveApproaches: [],
                        difficultyLevel: 'unknown'
                    };
                }

                // Limit memory size
                if (this.memory.coachingHistory.length > 100) {
                    this.memory.coachingHistory = this.memory.coachingHistory.slice(0, 100);
                }

                this.saveMemory();
            },

            // Parse coaching analysis into actionable guidance
            parseCoachingAnalysis(analysis) {
                return {
                    communicationGap: this.extractSection(analysis, 'COMMUNICATION_GAP_ANALYSIS'),
                    validatorCoaching: this.extractSection(analysis, 'VALIDATOR_COACHING'),
                    memberCoaching: this.extractSection(analysis, 'MEMBER_COACHING'),
                    interventionStrategy: this.extractSection(analysis, 'INTERVENTION_STRATEGY'),
                    patternRecognition: this.extractSection(analysis, 'PATTERN_RECOGNITION')
                };
            },

            // Extract sections from coaching analysis
            extractSection(text, sectionName) {
                const regex = new RegExp(`\\[${sectionName}\\](.*?)(?=\\[|$)`, 's');
                const match = text.match(regex);
                return match ? match[1].trim() : `${sectionName} analysis pending`;
            },

            // Extract validation issues for pattern tracking
            extractValidationIssues(feedback) {
                const issues = [];
                if (feedback.includes('fabricated') || feedback.includes('invented')) issues.push('data_fabrication');
                if (feedback.includes('speculation') || feedback.includes('assumption')) issues.push('speculation');
                if (feedback.includes('unsupported') || feedback.includes('no evidence')) issues.push('unsupported_claims');
                if (feedback.includes('generic') || feedback.includes('vague')) issues.push('lack_specificity');
                if (feedback.includes('format') || feedback.includes('structure')) issues.push('formatting_issues');
                return issues;
            },

            // Generate fallback coaching if AI analysis fails
            generateFallbackCoaching(memberKey, validationFeedback) {
                return {
                    communicationGap: 'Analysis temporarily unavailable - using pattern-based coaching',
                    validatorCoaching: 'Provide more specific, actionable feedback with concrete examples',
                    memberCoaching: 'Focus on factual accuracy and specific evidence from provided data',
                    interventionStrategy: 'Simplify requirements and provide step-by-step guidance',
                    patternRecognition: 'Fallback coaching applied due to analysis system unavailability'
                };
            }
        };

        // Recovery Agent - Emergency Validation Response System
        const recoveryAgent = {
            sessionId: `recovery_${Date.now()}`,
            memory: {
                extremeCases: [],           // Most difficult validation failures
                interventionTechniques: {}, // Emergency procedures that worked
                systemicFailures: [],       // Patterns indicating deeper issues
                emergencyProtocols: {},     // Step-by-step recovery procedures
                modelLimitations: [],       // Cases where AI model was the issue
                successfulRecoveries: []    // Documentation of extreme case resolutions
            },

            // Load recovery agent memory
            loadMemory() {
                try {
                    const stored = localStorage.getItem('recovery_agent_memory');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.memory = { ...this.memory, ...data };
                        console.log(`üö® Recovery Agent loaded ${this.memory.extremeCases.length} extreme case memories`);
                    }
                } catch (error) {
                    console.error('Failed to load recovery agent memory:', error);
                }
            },

            // Save recovery agent memory
            saveMemory() {
                try {
                    localStorage.setItem('recovery_agent_memory', JSON.stringify(this.memory));
                } catch (error) {
                    console.error('Failed to save recovery agent memory:', error);
                }
            },

            // Emergency intervention for extreme validation failures
            async performEmergencyIntervention(memberKey, validationHistory, refinementAttempts) {
                const diagnosisPrompt = `EMERGENCY VALIDATION RECOVERY ANALYSIS

You are the Recovery Agent - the trauma surgeon of the validation system. You handle extreme cases where normal validation and refinement have failed completely.

=== YOUR EMERGENCY EXPERTISE ===
Extreme Cases Handled: ${this.memory.extremeCases.length}
Successful Recoveries: ${this.memory.successfulRecoveries.length}
Emergency Protocols Available: ${Object.keys(this.memory.emergencyProtocols).length}

=== CRISIS SITUATION ===
Council Member: ${councilMembers[memberKey].name}
Validation Attempts: ${validationHistory.length}
Refinement Coaching Attempts: ${refinementAttempts || 0}
Status: CRITICAL - Multiple system failure

VALIDATION HISTORY:
${validationHistory.map((h, i) => `
Attempt ${i+1}:
- Response Length: ${h.response.length} chars
- Issues: ${h.validation.corrected ? 'Required AI correction' : 'Failed validation'}
- Notes: ${h.validation.notes.substring(0, 200)}...
`).join('\n')}

=== EMERGENCY DIAGNOSIS REQUIRED ===

[ROOT_CAUSE_ANALYSIS]
What is the fundamental issue preventing this council member from producing valid reports?

[SYSTEM_FAILURE_TYPE]
Is this: Model limitation, Prompt engineering failure, Data quality issue, Communication breakdown, or Systemic AI behavior?

[EMERGENCY_PROTOCOL]
What emergency intervention is needed? Prompt surgery, Context injection, Method override, or Model switch?

[RECOVERY_STRATEGY]
Step-by-step emergency procedure to resolve this extreme case.

[PROGNOSIS]
Can this case be recovered, or does it indicate a fundamental system limitation?

Provide comprehensive emergency analysis for immediate intervention.`;

                try {
                    const emergencyAnalysis = await queryOllama('gemma3:1b', diagnosisPrompt);

                    // Record this extreme case
                    this.recordExtremeCase(memberKey, validationHistory, emergencyAnalysis);

                    return this.parseEmergencyAnalysis(emergencyAnalysis);
                } catch (error) {
                    console.error('Recovery agent emergency analysis failed:', error);
                    return this.generateCriticalFailsafe(memberKey, validationHistory);
                }
            },

            // Apply emergency recovery procedure
            async applyEmergencyRecovery(memberKey, recoveryStrategy, originalPrompt, canvasContent) {
                const emergencyPrompt = `EMERGENCY RECOVERY PROCEDURE

${recoveryStrategy.protocol}

=== EMERGENCY CONTEXT INJECTION ===
Council Member: ${councilMembers[memberKey].name}
Recovery Strategy: ${recoveryStrategy.strategy}
Root Cause: ${recoveryStrategy.rootCause}

=== ORIGINAL TASK (SIMPLIFIED) ===
${originalPrompt.substring(0, 500)}...

=== EMERGENCY GUIDANCE ===
${recoveryStrategy.emergencyGuidance}

=== CANVAS DATA (FACTUAL BASIS) ===
Length: ${canvasContent.length} characters
Word Count: ${canvasContent.split(/\s+/).length} words

CRITICAL RECOVERY INSTRUCTION:
This is an emergency recovery attempt. Focus ONLY on:
1. Basic factual observations from the canvas data
2. Simple, measurable metrics
3. No speculation or creative interpretation
4. Direct, concrete statements only

Provide the most basic, factual analysis possible to pass validation.`;

                try {
                    const recoveryResponse = await queryOllama('gemma3:1b', emergencyPrompt);

                    // Record successful recovery attempt
                    this.recordRecoveryAttempt(memberKey, recoveryStrategy, recoveryResponse, 'attempted');

                    return recoveryResponse;
                } catch (error) {
                    console.error('Emergency recovery procedure failed:', error);
                    return this.generateFinalFailsafe(memberKey);
                }
            },

            // Record extreme case for learning
            recordExtremeCase(memberKey, validationHistory, emergencyAnalysis) {
                const extremeCase = {
                    timestamp: new Date().toISOString(),
                    member: memberKey,
                    attemptCount: validationHistory.length,
                    failurePattern: this.analyzeFailurePattern(validationHistory),
                    emergencyDiagnosis: emergencyAnalysis.substring(0, 1000),
                    caseType: 'validation_system_failure'
                };

                this.memory.extremeCases.unshift(extremeCase);

                // Limit extreme case memory
                if (this.memory.extremeCases.length > 50) {
                    this.memory.extremeCases = this.memory.extremeCases.slice(0, 50);
                }

                this.saveMemory();
            },

            // Record recovery attempt outcome
            recordRecoveryAttempt(memberKey, strategy, response, outcome) {
                const recovery = {
                    timestamp: new Date().toISOString(),
                    member: memberKey,
                    strategy: strategy.strategy,
                    rootCause: strategy.rootCause,
                    responseLength: response.length,
                    outcome: outcome,
                    technique: strategy.protocol
                };

                if (outcome === 'successful') {
                    this.memory.successfulRecoveries.unshift(recovery);
                }

                // Update emergency protocols with what works
                const protocolKey = `${memberKey}_${strategy.rootCause}`;
                if (!this.memory.emergencyProtocols[protocolKey]) {
                    this.memory.emergencyProtocols[protocolKey] = [];
                }
                this.memory.emergencyProtocols[protocolKey].push(recovery);

                this.saveMemory();
            },

            // Parse emergency analysis
            parseEmergencyAnalysis(analysis) {
                return {
                    rootCause: this.extractSection(analysis, 'ROOT_CAUSE_ANALYSIS'),
                    systemFailureType: this.extractSection(analysis, 'SYSTEM_FAILURE_TYPE'),
                    protocol: this.extractSection(analysis, 'EMERGENCY_PROTOCOL'),
                    strategy: this.extractSection(analysis, 'RECOVERY_STRATEGY'),
                    prognosis: this.extractSection(analysis, 'PROGNOSIS'),
                    emergencyGuidance: 'Emergency simplification protocol activated'
                };
            },

            // Extract sections from analysis
            extractSection(text, sectionName) {
                const regex = new RegExp(`\\[${sectionName}\\](.*?)(?=\\[|$)`, 's');
                const match = text.match(regex);
                return match ? match[1].trim() : `${sectionName} analysis pending`;
            },

            // Analyze failure patterns
            analyzeFailurePattern(validationHistory) {
                const issues = [];
                validationHistory.forEach(h => {
                    if (h.validation.notes.includes('fabricated')) issues.push('fabrication');
                    if (h.validation.notes.includes('speculation')) issues.push('speculation');
                    if (h.validation.notes.includes('generic')) issues.push('generic_responses');
                    if (h.validation.corrected) issues.push('ai_correction_required');
                });
                return issues;
            },

            // Critical failsafe when even recovery analysis fails
            generateCriticalFailsafe(memberKey, validationHistory) {
                return {
                    rootCause: 'Recovery system unavailable - critical system failure',
                    systemFailureType: 'Multiple system cascade failure',
                    protocol: 'Manual intervention required',
                    strategy: 'Escalate to system administrator',
                    prognosis: 'System requires manual diagnosis',
                    emergencyGuidance: 'Use most basic factual statements only'
                };
            },

            // Final failsafe response when all else fails
            generateFinalFailsafe(memberKey) {
                return `Emergency analysis mode activated.

Basic observation: Content analysis attempted but validation systems experienced cascading failures.

Factual status: ${councilMembers[memberKey].name} analysis requires manual system intervention.

Data metrics: Analysis system unavailable due to technical limitations.

Recommendation: System administrator review required for this council member configuration.`;
            }
        };

        // Pattern Recognition Engine - Predictive Validation Intelligence
        const patternRecognitionEngine = {
            sessionId: `pattern_${Date.now()}`,
            memory: {
                validationPatterns: {},      // Success/failure patterns by member
                routingDecisions: [],        // Optimal validator routing history
                predictiveModels: {},        // Learned prediction models
                earlyWarningSignals: [],     // Indicators of likely failure
                optimalPathways: {}          // Most efficient validation routes
            },

            // Load pattern recognition memory
            loadMemory() {
                try {
                    const stored = localStorage.getItem('pattern_recognition_memory');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.memory = { ...this.memory, ...data };
                        console.log(`üîç Pattern Engine loaded ${Object.keys(this.memory.validationPatterns).length} member patterns`);
                    }
                } catch (error) {
                    console.error('Failed to load pattern recognition memory:', error);
                }
            },

            // Save pattern recognition memory
            saveMemory() {
                try {
                    localStorage.setItem('pattern_recognition_memory', JSON.stringify(this.memory));
                } catch (error) {
                    console.error('Failed to save pattern recognition memory:', error);
                }
            },

            // Analyze report for early warning signals
            async analyzeReportPatterns(memberKey, reportContent) {
                const patternPrompt = `PATTERN RECOGNITION ANALYSIS

You are a Pattern Recognition Engine that predicts validation outcomes before they happen. Analyze this report for early warning signals.

=== PATTERN EXPERTISE ===
Member Patterns Learned: ${Object.keys(this.memory.validationPatterns).length}
Routing Decisions Made: ${this.memory.routingDecisions.length}
Early Warning Signals Known: ${this.memory.earlyWarningSignals.length}

=== REPORT ANALYSIS ===
Council Member: ${councilMembers[memberKey].name}
Report Length: ${reportContent.length} characters
Content Preview: ${reportContent.substring(0, 400)}...

=== PATTERN RECOGNITION TASKS ===

[EARLY_WARNING_SIGNALS]
What patterns in this report suggest potential validation issues?

[FAILURE_PROBABILITY]
Rate the likelihood of validation failure (1-10 scale) based on content patterns.

[OPTIMAL_VALIDATOR_ROUTE]
Which validation approach would be most effective for this specific report?

[PREDICTED_ISSUES]
What specific validation problems are most likely to occur?

[PREVENTION_STRATEGY]
How can potential issues be prevented before validation begins?

Provide detailed pattern analysis for predictive optimization.`;

                try {
                    const patternAnalysis = await queryOllama('gemma3:1b', patternPrompt);

                    // Record pattern analysis
                    this.recordPatternAnalysis(memberKey, reportContent, patternAnalysis);

                    return this.parsePatternAnalysis(patternAnalysis);
                } catch (error) {
                    console.error('Pattern recognition failed:', error);
                    return this.generateFallbackPattern(memberKey, reportContent);
                }
            },

            // Pre-screen report and route to optimal validation path
            async prescreenAndRoute(memberKey, reportContent) {
                const patterns = await this.analyzeReportPatterns(memberKey, reportContent);

                const routingRecommendation = {
                    memberKey: memberKey,
                    failureProbability: patterns.failureProbability,
                    recommendedPath: patterns.optimalRoute,
                    earlyWarnings: patterns.earlyWarnings,
                    preventionStrategy: patterns.preventionStrategy,
                    timestamp: new Date().toISOString()
                };

                // Record routing decision
                this.memory.routingDecisions.unshift(routingRecommendation);

                // Limit routing history
                if (this.memory.routingDecisions.length > 100) {
                    this.memory.routingDecisions = this.memory.routingDecisions.slice(0, 100);
                }

                this.saveMemory();
                return routingRecommendation;
            },

            // Record pattern analysis for learning
            recordPatternAnalysis(memberKey, reportContent, analysis) {
                if (!this.memory.validationPatterns[memberKey]) {
                    this.memory.validationPatterns[memberKey] = {
                        reports: [],
                        successPatterns: [],
                        failurePatterns: [],
                        predictiveAccuracy: 0
                    };
                }

                const pattern = {
                    timestamp: new Date().toISOString(),
                    contentLength: reportContent.length,
                    wordCount: reportContent.split(/\s+/).length,
                    analysisResult: analysis.substring(0, 500),
                    earlyWarnings: this.extractWarnings(analysis)
                };

                this.memory.validationPatterns[memberKey].reports.unshift(pattern);

                // Limit pattern history per member
                if (this.memory.validationPatterns[memberKey].reports.length > 20) {
                    this.memory.validationPatterns[memberKey].reports = this.memory.validationPatterns[memberKey].reports.slice(0, 20);
                }

                this.saveMemory();
            },

            // Update pattern accuracy based on actual validation outcome
            updatePatternAccuracy(memberKey, predictedProbability, actualOutcome) {
                if (this.memory.validationPatterns[memberKey]) {
                    const wasCorrect = (predictedProbability > 5 && !actualOutcome.validated) ||
                                     (predictedProbability <= 5 && actualOutcome.validated);

                    const currentAccuracy = this.memory.validationPatterns[memberKey].predictiveAccuracy || 0;
                    const newAccuracy = wasCorrect ?
                        Math.min(currentAccuracy + 0.1, 1.0) :
                        Math.max(currentAccuracy - 0.05, 0.0);

                    this.memory.validationPatterns[memberKey].predictiveAccuracy = newAccuracy;

                    console.log(`üéØ Pattern accuracy for ${memberKey}: ${(newAccuracy * 100).toFixed(1)}%`);
                    this.saveMemory();
                }
            },

            // Parse pattern analysis
            parsePatternAnalysis(analysis) {
                return {
                    earlyWarnings: this.extractSection(analysis, 'EARLY_WARNING_SIGNALS'),
                    failureProbability: this.extractFailureProbability(analysis),
                    optimalRoute: this.extractSection(analysis, 'OPTIMAL_VALIDATOR_ROUTE'),
                    predictedIssues: this.extractSection(analysis, 'PREDICTED_ISSUES'),
                    preventionStrategy: this.extractSection(analysis, 'PREVENTION_STRATEGY')
                };
            },

            // Extract failure probability score
            extractFailureProbability(analysis) {
                const match = analysis.match(/\[FAILURE_PROBABILITY\].*?(\d+)/s);
                return match ? parseInt(match[1]) : 5; // Default to medium risk
            },

            // Extract early warning signals
            extractWarnings(analysis) {
                const warnings = [];
                if (analysis.includes('speculation') || analysis.includes('speculative')) warnings.push('speculation_risk');
                if (analysis.includes('generic') || analysis.includes('vague')) warnings.push('specificity_risk');
                if (analysis.includes('fabrication') || analysis.includes('invention')) warnings.push('accuracy_risk');
                if (analysis.includes('formatting') || analysis.includes('structure')) warnings.push('format_risk');
                return warnings;
            },

            // Extract sections from analysis
            extractSection(text, sectionName) {
                const regex = new RegExp(`\\[${sectionName}\\](.*?)(?=\\[|$)`, 's');
                const match = text.match(regex);
                return match ? match[1].trim() : `${sectionName} analysis pending`;
            },

            // Generate fallback pattern when AI analysis fails
            generateFallbackPattern(memberKey, reportContent) {
                const contentLength = reportContent.length;
                const wordCount = reportContent.split(/\s+/).length;

                // Simple heuristic-based pattern
                const failureProbability = contentLength < 100 ? 8 : contentLength > 1000 ? 3 : 5;

                return {
                    earlyWarnings: contentLength < 100 ? 'Report may be too brief' : 'Standard length analysis',
                    failureProbability: failureProbability,
                    optimalRoute: 'Standard triangulated validation recommended',
                    predictedIssues: contentLength < 100 ? 'Potential lack of detail' : 'Standard validation expected',
                    preventionStrategy: 'Apply standard validation protocols'
                };
            }
        };

        // Efficiency Optimizer - Validation Workload and Performance Management
        const efficiencyOptimizer = {
            sessionId: `efficiency_${Date.now()}`,
            memory: {
                performanceMetrics: {},         // Processing times and resource usage
                bottleneckAnalysis: [],         // Identified system bottlenecks
                workloadDistribution: {},       // Optimal workload patterns
                resourceUtilization: [],        // Memory and processing efficiency
                optimizationHistory: []         // Successful optimization strategies
            },

            // Load efficiency optimizer memory
            loadMemory() {
                try {
                    const stored = localStorage.getItem('efficiency_optimizer_memory');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.memory = { ...this.memory, ...data };
                        console.log(`‚ö° Efficiency Optimizer loaded ${this.memory.optimizationHistory.length} optimization records`);
                    }
                } catch (error) {
                    console.error('Failed to load efficiency optimizer memory:', error);
                }
            },

            // Save efficiency optimizer memory
            saveMemory() {
                try {
                    localStorage.setItem('efficiency_optimizer_memory', JSON.stringify(this.memory));
                } catch (error) {
                    console.error('Failed to save efficiency optimizer memory:', error);
                }
            },

            // Monitor and optimize validation workload
            async optimizeValidationWorkload(activeValidations) {
                const optimizationPrompt = `EFFICIENCY OPTIMIZATION ANALYSIS

You are an Efficiency Optimizer managing validation system workload and performance. Your role is to prevent bottlenecks and optimize resource utilization.

=== PERFORMANCE EXPERTISE ===
Optimization Records: ${this.memory.optimizationHistory.length}
Bottlenecks Resolved: ${this.memory.bottleneckAnalysis.length}
Performance Metrics Available: ${Object.keys(this.memory.performanceMetrics).length}

=== CURRENT WORKLOAD STATUS ===
Active Validations: ${activeValidations.length}
System Load: ${this.calculateSystemLoad()}
Memory Usage: ${this.estimateMemoryUsage()}%

VALIDATION QUEUE:
${activeValidations.map(v => `- ${v.memberKey}: ${v.status} (${v.timeElapsed}ms)`).join('\n')}

=== OPTIMIZATION ANALYSIS ===

[BOTTLENECK_IDENTIFICATION]
What are the current system bottlenecks and resource constraints?

[WORKLOAD_PRIORITIZATION]
How should validation tasks be prioritized for optimal throughput?

[RESOURCE_OPTIMIZATION]
What optimizations would improve system efficiency?

[PERFORMANCE_PREDICTION]
What performance issues are likely to develop if current patterns continue?

[OPTIMIZATION_STRATEGY]
What specific steps should be taken to optimize validation efficiency?

Provide comprehensive efficiency analysis for workload optimization.`;

                try {
                    const optimizationAnalysis = await queryOllama('gemma3:1b', optimizationPrompt);

                    // Record optimization analysis
                    this.recordOptimization(activeValidations, optimizationAnalysis);

                    return this.parseOptimizationAnalysis(optimizationAnalysis);
                } catch (error) {
                    console.error('Efficiency optimization failed:', error);
                    return this.generateFallbackOptimization(activeValidations);
                }
            },

            // Smart batching for validation efficiency
            optimizeBatchProcessing(pendingValidations) {
                const batchSize = this.calculateOptimalBatchSize(pendingValidations.length);
                const priorityBatches = [];

                // Group by priority and member patterns
                const highPriority = pendingValidations.filter(v => v.failureProbability > 7);
                const mediumPriority = pendingValidations.filter(v => v.failureProbability >= 4 && v.failureProbability <= 7);
                const lowPriority = pendingValidations.filter(v => v.failureProbability < 4);

                // Create optimized batches
                if (highPriority.length > 0) {
                    priorityBatches.push({
                        priority: 'high',
                        validations: highPriority.slice(0, Math.max(1, Math.floor(batchSize * 0.6))),
                        processingOrder: 1
                    });
                }

                if (mediumPriority.length > 0) {
                    priorityBatches.push({
                        priority: 'medium',
                        validations: mediumPriority.slice(0, Math.max(1, Math.floor(batchSize * 0.3))),
                        processingOrder: 2
                    });
                }

                if (lowPriority.length > 0) {
                    priorityBatches.push({
                        priority: 'low',
                        validations: lowPriority.slice(0, Math.max(1, Math.floor(batchSize * 0.1))),
                        processingOrder: 3
                    });
                }

                return priorityBatches;
            },

            // Calculate optimal batch size based on system performance
            calculateOptimalBatchSize(queueLength) {
                const baseSize = 3; // DJINN_CONFIG.MAX_CONCURRENT_OLLAMA
                const systemLoad = this.calculateSystemLoad();

                if (systemLoad > 80) return Math.max(1, baseSize - 1); // Reduce load
                if (systemLoad < 30) return Math.min(queueLength, baseSize + 1); // Increase throughput
                return Math.min(queueLength, baseSize);
            },

            // Monitor system performance metrics
            recordPerformanceMetrics(memberKey, startTime, endTime, iterations, outcome) {
                const processingTime = endTime - startTime;
                const efficiency = iterations > 1 ? (1 / iterations) : 1;

                if (!this.memory.performanceMetrics[memberKey]) {
                    this.memory.performanceMetrics[memberKey] = {
                        averageTime: 0,
                        totalProcessed: 0,
                        averageIterations: 0,
                        successRate: 0,
                        efficiency: 0
                    };
                }

                const metrics = this.memory.performanceMetrics[memberKey];
                const total = metrics.totalProcessed;

                // Update rolling averages
                metrics.averageTime = ((metrics.averageTime * total) + processingTime) / (total + 1);
                metrics.averageIterations = ((metrics.averageIterations * total) + iterations) / (total + 1);
                metrics.efficiency = ((metrics.efficiency * total) + efficiency) / (total + 1);
                metrics.totalProcessed += 1;

                // Update success rate
                const wasSuccessful = outcome.validated ? 1 : 0;
                metrics.successRate = ((metrics.successRate * total) + wasSuccessful) / (total + 1);

                this.saveMemory();
            },

            // Estimate current memory usage
            estimateMemoryUsage() {
                try {
                    const memoryKeys = [
                        'validation_specialist_memory',
                        'refinement_specialist_memory',
                        'recovery_agent_memory',
                        'pattern_recognition_memory',
                        'efficiency_optimizer_memory'
                    ];

                    let totalSize = 0;
                    memoryKeys.forEach(key => {
                        const stored = localStorage.getItem(key);
                        if (stored) totalSize += stored.length;
                    });

                    // Estimate as percentage of 5MB localStorage limit
                    return Math.min(100, (totalSize / (5 * 1024 * 1024)) * 100);
                } catch (error) {
                    return 50; // Conservative estimate if calculation fails
                }
            },

            // Calculate current system load
            calculateSystemLoad() {
                const activeProcesses = Object.keys(this.memory.performanceMetrics).length;
                const recentBottlenecks = this.memory.bottleneckAnalysis.filter(b =>
                    Date.now() - new Date(b.timestamp).getTime() < 300000 // Last 5 minutes
                ).length;

                return Math.min(100, (activeProcesses * 10) + (recentBottlenecks * 20));
            },

            // Record optimization attempt
            recordOptimization(validations, analysis) {
                const optimization = {
                    timestamp: new Date().toISOString(),
                    activeValidations: validations.length,
                    systemLoad: this.calculateSystemLoad(),
                    memoryUsage: this.estimateMemoryUsage(),
                    optimizationApplied: analysis.substring(0, 500),
                    outcome: 'applied'
                };

                this.memory.optimizationHistory.unshift(optimization);

                // Limit optimization history
                if (this.memory.optimizationHistory.length > 50) {
                    this.memory.optimizationHistory = this.memory.optimizationHistory.slice(0, 50);
                }

                this.saveMemory();
            },

            // Parse optimization analysis
            parseOptimizationAnalysis(analysis) {
                return {
                    bottlenecks: this.extractSection(analysis, 'BOTTLENECK_IDENTIFICATION'),
                    prioritization: this.extractSection(analysis, 'WORKLOAD_PRIORITIZATION'),
                    resourceOptimization: this.extractSection(analysis, 'RESOURCE_OPTIMIZATION'),
                    performancePrediction: this.extractSection(analysis, 'PERFORMANCE_PREDICTION'),
                    strategy: this.extractSection(analysis, 'OPTIMIZATION_STRATEGY')
                };
            },

            // Extract sections from analysis
            extractSection(text, sectionName) {
                const regex = new RegExp(`\\[${sectionName}\\](.*?)(?=\\[|$)`, 's');
                const match = text.match(regex);
                return match ? match[1].trim() : `${sectionName} analysis pending`;
            },

            // Generate fallback optimization when AI analysis fails
            generateFallbackOptimization(validations) {
                const load = this.calculateSystemLoad();

                return {
                    bottlenecks: load > 70 ? 'High system load detected' : 'System load within normal parameters',
                    prioritization: 'Process high-risk validations first, then medium, then low risk',
                    resourceOptimization: load > 70 ? 'Reduce concurrent validations' : 'Maintain current processing levels',
                    performancePrediction: 'Performance tracking available for optimization',
                    strategy: 'Apply standard workload management protocols'
                };
            }
        };

        // Quality Assurance Monitor - Meta-Validation System
        const qualityAssuranceMonitor = {
            sessionId: `qa_${Date.now()}`,
            memory: {
                validatorPerformance: {},       // How well validators are performing
                systemHealthMetrics: [],        // Overall system health tracking
                qualityTrends: {},             // Quality improvement/degradation patterns
                alertHistory: [],              // Quality alerts and responses
                benchmarkStandards: {}         // Quality benchmarks for comparison
            },

            // Load QA monitor memory
            loadMemory() {
                try {
                    const stored = localStorage.getItem('qa_monitor_memory');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.memory = { ...this.memory, ...data };
                        console.log(`üìä QA Monitor loaded ${this.memory.alertHistory.length} quality alerts`);
                    }
                } catch (error) {
                    console.error('Failed to load QA monitor memory:', error);
                }
            },

            // Save QA monitor memory
            saveMemory() {
                try {
                    localStorage.setItem('qa_monitor_memory', JSON.stringify(this.memory));
                } catch (error) {
                    console.error('Failed to save QA monitor memory:', error);
                }
            },

            // Meta-validation: Monitor the validation system itself
            async performMetaValidation(validationOutcomes) {
                const metaPrompt = `QUALITY ASSURANCE META-ANALYSIS

You are a Quality Assurance Monitor that watches the validation system itself. Your role is to ensure the validators are maintaining high standards and identify system-wide quality issues.

=== QA EXPERTISE ===
System Health Metrics: ${this.memory.systemHealthMetrics.length}
Quality Alerts Issued: ${this.memory.alertHistory.length}
Validator Performance Records: ${Object.keys(this.memory.validatorPerformance).length}

=== VALIDATION SYSTEM ANALYSIS ===
Recent Validation Outcomes: ${validationOutcomes.length} sessions

VALIDATION PERFORMANCE DATA:
${validationOutcomes.map(v => `
Member: ${v.member}
Validated: ${v.validated}
Corrected: ${v.corrected}
Iterations: ${v.iterations}
Emergency Recovery: ${v.emergency_recovery || false}
`).join('')}

=== META-VALIDATION ANALYSIS ===

[VALIDATOR_QUALITY_ASSESSMENT]
How effectively are the validators performing their quality control function?

[SYSTEM_RELIABILITY]
Are there patterns indicating systemic issues in the validation process?

[QUALITY_CONSISTENCY]
Is validation quality consistent across different council members and scenarios?

[IMPROVEMENT_OPPORTUNITIES]
What specific improvements would enhance overall validation system quality?

[ALERT_RECOMMENDATIONS]
What quality alerts or system adjustments should be implemented?

Provide comprehensive meta-analysis of validation system quality.`;

                try {
                    const metaAnalysis = await queryOllama('gemma3:1b', metaPrompt);

                    // Record meta-validation analysis
                    this.recordMetaValidation(validationOutcomes, metaAnalysis);

                    return this.parseMetaAnalysis(metaAnalysis);
                } catch (error) {
                    console.error('Meta-validation failed:', error);
                    return this.generateFallbackMetaAnalysis(validationOutcomes);
                }
            },

            // Monitor validator performance trends
            trackValidatorPerformance(memberKey, validationResult, processingTime) {
                if (!this.memory.validatorPerformance[memberKey]) {
                    this.memory.validatorPerformance[memberKey] = {
                        totalValidations: 0,
                        successRate: 0,
                        averageIterations: 0,
                        emergencyEscalations: 0,
                        averageTime: 0,
                        qualityTrend: 'stable'
                    };
                }

                const perf = this.memory.validatorPerformance[memberKey];
                const total = perf.totalValidations;

                // Update performance metrics
                perf.totalValidations += 1;
                perf.successRate = ((perf.successRate * total) + (validationResult.validated ? 1 : 0)) / (total + 1);
                perf.averageIterations = ((perf.averageIterations * total) + validationResult.iterations) / (total + 1);
                perf.averageTime = ((perf.averageTime * total) + processingTime) / (total + 1);

                if (validationResult.emergency_recovery) {
                    perf.emergencyEscalations += 1;
                }

                // Determine quality trend
                if (perf.successRate > 0.85 && perf.averageIterations < 2) {
                    perf.qualityTrend = 'improving';
                } else if (perf.successRate < 0.6 || perf.emergencyEscalations > (total * 0.1)) {
                    perf.qualityTrend = 'degrading';
                } else {
                    perf.qualityTrend = 'stable';
                }

                this.saveMemory();
            },

            // Generate system health report
            generateSystemHealthReport() {
                const members = Object.keys(this.memory.validatorPerformance);
                const overallHealth = {
                    timestamp: new Date().toISOString(),
                    totalValidators: members.length,
                    averageSuccessRate: 0,
                    emergencyEscalations: 0,
                    systemStatus: 'healthy',
                    alerts: []
                };

                if (members.length === 0) {
                    overallHealth.systemStatus = 'no_data';
                    return overallHealth;
                }

                // Calculate system-wide metrics
                let totalSuccessRate = 0;
                let totalEscalations = 0;
                let degradingValidators = 0;

                members.forEach(memberKey => {
                    const perf = this.memory.validatorPerformance[memberKey];
                    totalSuccessRate += perf.successRate;
                    totalEscalations += perf.emergencyEscalations;

                    if (perf.qualityTrend === 'degrading') {
                        degradingValidators++;
                        overallHealth.alerts.push(`${memberKey}: Quality degrading (${(perf.successRate * 100).toFixed(1)}% success rate)`);
                    }
                });

                overallHealth.averageSuccessRate = totalSuccessRate / members.length;
                overallHealth.emergencyEscalations = totalEscalations;

                // Determine overall system status
                if (overallHealth.averageSuccessRate < 0.7 || degradingValidators > (members.length * 0.3)) {
                    overallHealth.systemStatus = 'degraded';
                } else if (overallHealth.averageSuccessRate > 0.9 && degradingValidators === 0) {
                    overallHealth.systemStatus = 'excellent';
                } else {
                    overallHealth.systemStatus = 'healthy';
                }

                // Record health metrics
                this.memory.systemHealthMetrics.unshift(overallHealth);

                // Limit health history
                if (this.memory.systemHealthMetrics.length > 100) {
                    this.memory.systemHealthMetrics = this.memory.systemHealthMetrics.slice(0, 100);
                }

                this.saveMemory();
                return overallHealth;
            },

            // Issue quality alerts
            issueQualityAlert(alertType, message, severity = 'medium') {
                const alert = {
                    timestamp: new Date().toISOString(),
                    type: alertType,
                    message: message,
                    severity: severity,
                    status: 'active'
                };

                this.memory.alertHistory.unshift(alert);

                console.log(`üö® QA Alert [${severity.toUpperCase()}]: ${message}`);

                // Limit alert history
                if (this.memory.alertHistory.length > 50) {
                    this.memory.alertHistory = this.memory.alertHistory.slice(0, 50);
                }

                this.saveMemory();
                return alert;
            },

            // Record meta-validation analysis
            recordMetaValidation(outcomes, analysis) {
                const metaRecord = {
                    timestamp: new Date().toISOString(),
                    outcomesAnalyzed: outcomes.length,
                    systemAssessment: analysis.substring(0, 500),
                    qualityScore: this.calculateQualityScore(outcomes)
                };

                // Store in quality trends
                const dateKey = new Date().toISOString().split('T')[0];
                this.memory.qualityTrends[dateKey] = metaRecord;

                this.saveMemory();
            },

            // Calculate overall system quality score
            calculateQualityScore(outcomes) {
                if (outcomes.length === 0) return 50;

                let score = 0;
                outcomes.forEach(outcome => {
                    if (outcome.validated && !outcome.corrected && outcome.iterations === 1) {
                        score += 100; // Perfect validation
                    } else if (outcome.validated && !outcome.corrected) {
                        score += 80; // Good after refinement
                    } else if (outcome.validated && outcome.corrected) {
                        score += 60; // Required correction
                    } else if (outcome.emergency_recovery && outcome.validated) {
                        score += 40; // Emergency recovery successful
                    } else {
                        score += 10; // Failed validation
                    }
                });

                return Math.round(score / outcomes.length);
            },

            // Parse meta-analysis
            parseMetaAnalysis(analysis) {
                return {
                    validatorQuality: this.extractSection(analysis, 'VALIDATOR_QUALITY_ASSESSMENT'),
                    systemReliability: this.extractSection(analysis, 'SYSTEM_RELIABILITY'),
                    qualityConsistency: this.extractSection(analysis, 'QUALITY_CONSISTENCY'),
                    improvements: this.extractSection(analysis, 'IMPROVEMENT_OPPORTUNITIES'),
                    alerts: this.extractSection(analysis, 'ALERT_RECOMMENDATIONS')
                };
            },

            // Extract sections from analysis
            extractSection(text, sectionName) {
                const regex = new RegExp(`\\[${sectionName}\\](.*?)(?=\\[|$)`, 's');
                const match = text.match(regex);
                return match ? match[1].trim() : `${sectionName} analysis pending`;
            },

            // Generate fallback meta-analysis
            generateFallbackMetaAnalysis(outcomes) {
                const score = this.calculateQualityScore(outcomes);

                return {
                    validatorQuality: score > 80 ? 'Validators performing well' : score > 60 ? 'Validators need improvement' : 'Validators require attention',
                    systemReliability: 'Meta-analysis system available for quality monitoring',
                    qualityConsistency: `Quality score: ${score}/100 across ${outcomes.length} validations`,
                    improvements: 'Continue monitoring validation patterns for optimization opportunities',
                    alerts: score < 70 ? 'Consider system review due to low quality scores' : 'System operating within acceptable quality parameters'
                };
            }
        };

        // Initialize validation specialist memory when system starts
        document.addEventListener('DOMContentLoaded', function() {
            validationSpecialist.loadMemory();
            refinementSpecialist.loadMemory();
            recoveryAgent.loadMemory();
            patternRecognitionEngine.loadMemory();
            efficiencyOptimizer.loadMemory();
            qualityAssuranceMonitor.loadMemory();
            console.log('üîç Validation Specialist initialized with memory system');
            console.log('üîß Refinement Specialist initialized with coaching expertise');
            console.log('üö® Recovery Agent initialized with emergency response protocols');
            console.log('üéØ Pattern Recognition Engine initialized with predictive intelligence');
            console.log('‚ö° Efficiency Optimizer initialized with performance management');
            console.log('üìä Quality Assurance Monitor initialized with meta-validation system');
        });

        // Canvas Integration - Trigger canvas cycle after intelligence completion
        function triggerCanvasUpdate() {
            try {
                // Method 1: Try postMessage to canvas window if available
                const canvasWindows = [];
                // Look for canvas window references
                if (window.canvasWindow && !window.canvasWindow.closed) {
                    canvasWindows.push(window.canvasWindow);
                }

                // Method 2: Use localStorage trigger for cross-window communication
                localStorage.setItem('djinn_intelligence_trigger', Date.now().toString());
                console.log('üîó Triggered canvas update via localStorage');

                // Method 3: Try postMessage to parent/opener if available
                if (window.opener && !window.opener.closed) {
                    window.opener.postMessage({
                        type: 'council_intelligence_complete',
                        timestamp: Date.now()
                    }, '*');
                    console.log('üîó Triggered canvas update via opener postMessage');
                }

            } catch (error) {
                console.log('üì° Canvas trigger attempted (standalone mode or no canvas connection)');
            }
        }

        // ========================================
        // INTELLIGENCE REPORTING FUNCTIONS
        // ========================================

        function storeIntelligence(report) {
            surveillanceState.intelligenceReports.unshift(report);
            
            // Limit storage
            if (surveillanceState.intelligenceReports.length > DJINN_CONFIG.MEMORY_LIMIT) {
                surveillanceState.intelligenceReports.pop();
            }
            
            surveillanceState.reportCount++;
            document.getElementById('reportCount').textContent = surveillanceState.reportCount;
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('djinn_intelligence', JSON.stringify(surveillanceState.intelligenceReports));
            } catch (error) {
                console.error('Failed to store intelligence:', error);
            }
        }

        function displayIntelligence(report) {
            // Handle legacy reports that might not have all properties
            const severity = report.severity || 'insight';
            const reportType = report.type || 'unknown';
            const summary = report.summary || 'No summary available';
            const timestamp = report.timestamp || new Date().toISOString();
            
            const severityClass = `intel-${severity}`;
            const html = `
                <div class="intel-entry ${severityClass}">
                    <div class="intel-timestamp">${new Date(timestamp).toLocaleTimeString()}</div>
                    <div style="margin-bottom: 12px; font-weight: bold; font-size: 12px;">
                        [${severity.toUpperCase()}] ${reportType}
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Consensus</div>
                        <div class="intel-content">${summary}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Intelligence Assessment</div>
                        <div class="intel-content">${report.correlations || 'Analysis in progress'}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Risk Evaluation</div>
                        <div class="intel-content">${report.risk_assessment || 'Risk assessment pending'}</div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Actionable Recommendations</div>
                        <div class="intel-content">
                            ${Array.isArray(report.actionable) ?
                                `<ul class="intel-recommendations">${report.actionable.map(a => `<li>${a}</li>`).join('')}</ul>` :
                                (report.actionable || 'No recommendations available')
                            }
                        </div>
                    </div>

                    <div class="intel-section">
                        <div class="intel-section-title">Strategic Implications</div>
                        <div class="intel-content">${report.strategic_implications || 'Strategic analysis pending'}</div>
                    </div>
                </div>
            `;

            const feed = document.getElementById('intelligenceFeed');
            feed.innerHTML = html + feed.innerHTML;

            // Limit display
            const entries = feed.querySelectorAll('.intel-entry');
            if (entries.length > 20) {
                entries[entries.length - 1].remove();
            }
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================

        function updateCanvasPreview(canvasContent) {
            // Update statistics
            const length = canvasContent.length;
            const words = canvasContent.split(/\s+/).filter(w => w.length > 0).length;
            const lines = canvasContent.split('\n').length;
            const modified = length > 0 ? new Date().toLocaleTimeString() : 'Never';
            
            document.getElementById('canvasLength').textContent = length.toLocaleString();
            document.getElementById('canvasWords').textContent = words.toLocaleString();
            document.getElementById('canvasLines').textContent = lines.toLocaleString();
            document.getElementById('canvasModified').textContent = modified;
            
            // Update content preview - show full canvas content
            let preview = '';
            if (canvasContent.length > 0) {
                // Try to extract meaningful content, avoiding HTML/script tags
                let cleanContent = canvasContent;
                
                // Remove script tags and their content
                cleanContent = cleanContent.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
                
                // Remove HTML tags but keep text
                cleanContent = cleanContent.replace(/<[^>]*>/g, ' ');
                
                // Remove multiple spaces and clean up
                cleanContent = cleanContent.replace(/\s+/g, ' ').trim();
                
                // Show full cleaned content
                preview = cleanContent;
                
                // If we still have no meaningful content, show raw content
                if (preview.trim().length === 0) {
                    preview = canvasContent;
                }
            } else {
                preview = 'No canvas content detected yet. Start typing in the Canvas to see content here.';
            }
            
            document.getElementById('canvasContentPreview').textContent = preview;
            
            // Update monitor status based on content
            const statusEl = document.getElementById('canvasMonitorStatus');
            if (length > 0) {
                statusEl.textContent = 'ACTIVE';
                statusEl.style.background = 'rgba(0, 255, 136, 0.2)';
                statusEl.style.color = '#00ff88';
            } else {
                statusEl.textContent = 'WAITING';
                statusEl.style.background = 'rgba(255, 170, 0, 0.2)';
                statusEl.style.color = '#ffaa00';
            }
        }

        function generateLocalAnalysis(model, prompt) {
            // This function should never be called - all analysis must come from Ollama
            throw new Error('Local analysis disabled. Only real Ollama AI responses are allowed.');
        }

        function hashContent(content) {
            let hash = 0;
            if (!content || content.length === 0) return hash;
            for (let i = 0; i < content.length; i++) {
                const char = content.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        function logSurveillance(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const feed = document.getElementById('surveillanceFeed');
            
            const color = type === 'error' ? '#ff6666' : 
                         type === 'change' ? '#00ff88' :
                         type === 'memory' ? '#ffaa00' : '#9999ff';
            
            const html = `<div style="margin-bottom: 4px; color: ${color};">[${timestamp}] ${message}</div>`;
            feed.innerHTML = html + feed.innerHTML;
            
            // Limit log entries
            const logs = feed.children;
            if (logs.length > 50) {
                feed.removeChild(logs[logs.length - 1]);
            }
        }

        function updateTimestamp() {
            document.getElementById('lastAnalysis').textContent = new Date().toLocaleTimeString();
        }

        function updateCouncilStatus(status) {
            document.getElementById('councilStatus').textContent = status;
            if (status === 'ANALYZING') {
                document.getElementById('canvasStatus').textContent = 'ANALYZING';
            } else {
                document.getElementById('canvasStatus').textContent = 'ACTIVE';
            }
        }

        function updateQueueStatus() {
            document.getElementById('queueStatus').textContent = surveillanceState.analysisQueue.length;
        }

        function startPolling() {
            document.getElementById('pollingStatus').textContent = `${DJINN_CONFIG.POLLING_INTERVAL / 1000}s`;
        }

        // ========================================
        // USER CONTROLS
        // ========================================

        async function triggerCouncilAnalysis() {
            logDjinnEvent('council', 'Manual council analysis triggered - 3-stage collaborative process initiated');
            console.log('Manual analysis triggered');
            
            // Force a fresh analysis
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
            
            queueAnalysis('manual_analysis', {
                content: canvasContent,
                memory: aiMemory,
                type: 'manual',
                timestamp: new Date().toISOString()
            });
            
            await processAnalysisQueue();
        }

        async function generateIntelReport() {
            console.log('Generating AI-powered intelligence report...');

            // Get current canvas data and AI memory
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
            const currentAnalysis = {
                type: 'intelligence_report_generation',
                data: {
                    content: canvasContent,
                    memory: aiMemory,
                    timestamp: new Date().toISOString()
                }
            };

            try {
                // Generate AI-powered intelligence report using current data
                const intelligenceEntry = await generateIntelligenceEntry(currentAnalysis, {
                    responses: [], // Will be populated by AI analysis
                    theme: 'intelligence_synthesis',
                    confidence: 0.8,
                    summary: 'AI-powered intelligence synthesis in progress'
                });

                // Display the AI-generated intelligence report
                displayIntelligence(intelligenceEntry);

                // Trigger canvas cycle if in council-integrated mode
                triggerCanvasUpdate();

                // Show success message
                alert(`AI-Powered Intelligence Report Generated!\n\n` +
                      `Report ID: ${intelligenceEntry.id}\n` +
                      `Severity: ${intelligenceEntry.severity}\n` +
                      `Theme: ${intelligenceEntry.theme}\n\n` +
                      `Check the Intelligence Report panel for the AI-synthesized analysis.`);

            } catch (error) {
                console.error('AI intelligence report generation failed:', error);
                alert('AI intelligence report generation failed. Check console for details.');
            }
        }

        function clearIntelligence() {
            if (confirm('Clear all intelligence data and response cache? This cannot be undone.')) {
                surveillanceState.intelligenceReports = [];
                surveillanceState.reportCount = 0;
                document.getElementById('reportCount').textContent = '0';
                document.getElementById('intelligenceFeed').innerHTML = '<div style="color: #666; font-style: italic;">Intelligence cleared</div>';
                document.getElementById('consensusFeed').innerHTML = '<div style="color: #666; font-style: italic;">Consensus cleared</div>';
                localStorage.removeItem('djinn_intelligence');
                
                // Also clear response cache to force fresh AI responses
                responseCache.clear();
                console.log('Response cache cleared for fresh AI responses');
            }
        }


        function exportIntelligence() {
            // Show export selection popup instead of immediate export
            showExportSelectionModal();
        }

        function showExportSelectionModal() {
            const modal = document.getElementById('exportSelectionModal');
            const reportsList = document.getElementById('exportReportsList');

            // Populate reports list
            reportsList.innerHTML = generateReportsListHTML();

            // Show modal
            modal.style.display = 'block';
        }

        function generateReportsListHTML() {
            let html = '';

            // Consensus Reports
            if (djinnCouncilMemory.consensusHistory && djinnCouncilMemory.consensusHistory.length > 0) {
                html += '<div style="margin-bottom: 15px;"><strong style="color: #4ecdc4;">üìã Consensus Reports (' + djinnCouncilMemory.consensusHistory.length + '):</strong></div>';

                djinnCouncilMemory.consensusHistory.forEach((consensus, index) => {
                    const timestamp = new Date(consensus.timestamp).toLocaleString();
                    const memberCount = Object.keys(consensus.memberAnalyses || {}).length;
                    html += `
                        <div style="margin-bottom: 10px; padding: 8px; background: rgba(78, 205, 196, 0.05); border-left: 3px solid #4ecdc4;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" class="export-checkbox" data-type="consensus" data-index="${index}" style="margin-right: 8px;" checked>
                                <div>
                                    <strong>Round ${consensus.round || (index + 1)}</strong> - ${timestamp}
                                    <div style="font-size: 11px; color: #aaa;">${memberCount} members ‚Ä¢ ${consensus.synthesis ? consensus.synthesis.substring(0, 100) + '...' : 'No synthesis'}</div>
                                </div>
                            </label>
                        </div>
                    `;
                });
            }

            // Intelligence Reports
            if (djinnCouncilMemory.intelligenceReports && djinnCouncilMemory.intelligenceReports.length > 0) {
                html += '<div style="margin-bottom: 15px; margin-top: 20px;"><strong style="color: #4ecdc4;">üß† Intelligence Reports (' + djinnCouncilMemory.intelligenceReports.length + '):</strong></div>';

                djinnCouncilMemory.intelligenceReports.forEach((report, index) => {
                    const timestamp = new Date(report.timestamp).toLocaleString();
                    html += `
                        <div style="margin-bottom: 10px; padding: 8px; background: rgba(78, 205, 196, 0.05); border-left: 3px solid #4ecdc4;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" class="export-checkbox" data-type="intelligence" data-index="${index}" style="margin-right: 8px;" checked>
                                <div>
                                    <strong>Intelligence Package ${index + 1}</strong> - ${timestamp}
                                    <div style="font-size: 11px; color: #aaa;">Session: ${report.sessionMetadata?.sessionId || 'Unknown'} ‚Ä¢ ${report.memberAnalytics?.length || 0} member analytics</div>
                                </div>
                            </label>
                        </div>
                    `;
                });
            }

            // Individual Member Reports
            let totalMemberReports = 0;
            Object.keys(djinnCouncilMemory.members || {}).forEach(memberName => {
                const member = djinnCouncilMemory.members[memberName];
                totalMemberReports += member.reports?.length || 0;
            });

            if (totalMemberReports > 0) {
                html += '<div style="margin-bottom: 15px; margin-top: 20px;"><strong style="color: #4ecdc4;">üë• Individual Member Reports (' + totalMemberReports + '):</strong></div>';

                Object.keys(djinnCouncilMemory.members || {}).forEach(memberName => {
                    const member = djinnCouncilMemory.members[memberName];
                    if (member.reports && member.reports.length > 0) {
                        html += `
                            <div style="margin-bottom: 10px; padding: 8px; background: rgba(78, 205, 196, 0.05); border-left: 3px solid #4ecdc4;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" class="export-checkbox" data-type="member" data-member="${memberName}" style="margin-right: 8px;" checked>
                                    <div>
                                        <strong>${member.name || memberName}</strong> (${member.reports.length} reports)
                                        <div style="font-size: 11px; color: #aaa;">${member.specialization || 'No specialization'}</div>
                                    </div>
                                </label>
                            </div>
                        `;
                    }
                });
            }

            if (html === '') {
                html = '<div style="text-align: center; color: #666; padding: 20px;">No reports available for export</div>';
            }

            return html;
        }

        function selectAllReports() {
            const checkboxes = document.querySelectorAll('.export-checkbox');
            checkboxes.forEach(cb => cb.checked = true);
        }

        function deselectAllReports() {
            const checkboxes = document.querySelectorAll('.export-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
        }

        function closeExportModal() {
            document.getElementById('exportSelectionModal').style.display = 'none';
        }

        function performExport() {
            const selectedReports = getSelectedReports();

            if (Object.keys(selectedReports).length === 0) {
                alert('Please select at least one report to export.');
                return;
            }

            const data = {
                timestamp: new Date().toISOString(),
                system: 'DJINN_COUNCIL_DOCUMENT_SURVEILLANCE',
                exportSelection: selectedReports,
                fullMemory: djinnCouncilMemory
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `djinn_selected_reports_${new Date().toISOString().replace(/:/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            closeExportModal();
        }

        function getSelectedReports() {
            const selected = {
                consensusReports: [],
                intelligenceReports: [],
                memberReports: {}
            };

            const checkboxes = document.querySelectorAll('.export-checkbox:checked');

            checkboxes.forEach(cb => {
                const type = cb.dataset.type;
                const index = cb.dataset.index;
                const member = cb.dataset.member;

                if (type === 'consensus' && djinnCouncilMemory.consensusHistory) {
                    selected.consensusReports.push(djinnCouncilMemory.consensusHistory[parseInt(index)]);
                } else if (type === 'intelligence' && djinnCouncilMemory.intelligenceReports) {
                    selected.intelligenceReports.push(djinnCouncilMemory.intelligenceReports[parseInt(index)]);
                } else if (type === 'member' && djinnCouncilMemory.members[member]) {
                    selected.memberReports[member] = djinnCouncilMemory.members[member];
                }
            });

            return selected;
        }

        // DJINN Council Event Logging System
        let djinnEventHistory = [];
        const MAX_EVENT_HISTORY = 100;

        function logDjinnEvent(type, message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const event = {
                timestamp: timestamp,
                type: type,
                message: message,
                data: data
            };

            djinnEventHistory.unshift(event); // Add to beginning
            if (djinnEventHistory.length > MAX_EVENT_HISTORY) {
                djinnEventHistory = djinnEventHistory.slice(0, MAX_EVENT_HISTORY);
            }

            updateEventLogDisplay();
            updateActivityPanels();
        }

        function updateEventLogDisplay() {
            const logElement = document.getElementById('djinnEventLog');
            if (!logElement) return;

            const displayEvents = djinnEventHistory.slice(0, 20); // Show last 20 events
            const logHTML = displayEvents.map(event => {
                const typeIcon = getEventTypeIcon(event.type);
                return `[${event.timestamp}] ${typeIcon} ${event.message}`;
            }).join('\n');

            logElement.textContent = logHTML || '[System Initialized] DJINN Council Document Surveillance Analysis ready';
            logElement.scrollTop = 0; // Scroll to top to show newest events
        }

        function getEventTypeIcon(type) {
            const icons = {
                'council': 'üßû‚Äç‚ôÇÔ∏è',
                'analysis': 'üîç',
                'consensus': 'ü§ù',
                'member': 'üë§',
                'document': 'üìÑ',
                'export': 'üíæ',
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
                'success': '‚úÖ',
                'system': '‚öôÔ∏è'
            };
            return icons[type] || 'üìã';
        }

        function updateActivityPanels() {
            // Update Council Activity Panel
            const activeMemberCount = Object.keys(djinnCouncilMemory.members || {}).filter(memberName => {
                const member = djinnCouncilMemory.members[memberName];
                return member.reports && member.reports.length > 0;
            }).length;

            const analysisQueueCount = surveillanceState.analysisQueue ? surveillanceState.analysisQueue.length : 0;

            const lastConsensus = djinnCouncilMemory.consensusHistory && djinnCouncilMemory.consensusHistory.length > 0
                ? new Date(djinnCouncilMemory.consensusHistory[djinnCouncilMemory.consensusHistory.length - 1].timestamp).toLocaleTimeString()
                : 'Never';

            const activeMemberEl = document.getElementById('activeMemberCount');
            const queueEl = document.getElementById('analysisQueueCount');
            const consensusEl = document.getElementById('lastConsensusTime');

            if (activeMemberEl) activeMemberEl.textContent = activeMemberCount;
            if (queueEl) queueEl.textContent = analysisQueueCount;
            if (consensusEl) consensusEl.textContent = lastConsensus;

            // Update Document Analysis Panel
            const totalRounds = djinnCouncilMemory.consensusHistory ? djinnCouncilMemory.consensusHistory.length : 0;
            const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
            const evolutionRate = canvasContent.length > 0 ? Math.min(100, (canvasContent.length / 1000) * 10) : 0;

            const docEvolutionEl = document.getElementById('docEvolutionRate');
            const aiCollabEl = document.getElementById('aiCollabImpact');
            const analysisRoundsEl = document.getElementById('analysisRounds');

            if (docEvolutionEl) docEvolutionEl.textContent = evolutionRate.toFixed(1) + '%';
            if (aiCollabEl) aiCollabEl.textContent = activeMemberCount > 0 ? 'Active' : 'Idle';
            if (analysisRoundsEl) analysisRoundsEl.textContent = totalRounds;
        }

        function clearEventLog() {
            djinnEventHistory = [];
            updateEventLogDisplay();
            logDjinnEvent('system', 'Event log cleared by user');
        }

        // Initialize event logging
        setTimeout(() => {
            logDjinnEvent('system', 'DJINN Council surveillance system initialized');
            updateActivityPanels();
        }, 1000);

        async function emergencyAnalysis() {
            try {
                logDjinnEvent('council', 'Emergency analysis initiated - all members activating');
                console.log('üö® Emergency analysis initiated');
                
                // Clear queue and force immediate analysis
                surveillanceState.analysisQueue = [];
                
                // Get all current data
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const aiMemory = localStorage.getItem('ai_memory_state') || '{}';
                const aiFeeds = JSON.parse(localStorage.getItem('ai_feeds') || '[]');
                
                queueAnalysis('emergency_analysis', {
                    content: canvasContent,
                    memory: aiMemory,
                    feeds: aiFeeds,
                    type: 'emergency',
                    timestamp: new Date().toISOString()
                });
                
                // Process immediately
                await processAnalysisQueue();
                
                // Generate report
                generateIntelReport();
            } catch (error) {
                console.error('Emergency analysis failed:', error);
                alert('Emergency analysis encountered an error. Check console for details.');
            }
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        // Load stored intelligence on startup
        function loadStoredIntelligence() {
            try {
                const stored = localStorage.getItem('djinn_intelligence');
                if (stored) {
                    const parsedReports = JSON.parse(stored);
                    
                    // Filter out any corrupted or incomplete reports
                    surveillanceState.intelligenceReports = parsedReports.filter(report => {
                        return report && typeof report === 'object' && report.timestamp;
                    });
                    
                    surveillanceState.reportCount = surveillanceState.intelligenceReports.length;
                    document.getElementById('reportCount').textContent = surveillanceState.reportCount;
                    
                    // Save cleaned data back to localStorage
                    localStorage.setItem('djinn_intelligence', JSON.stringify(surveillanceState.intelligenceReports));
                    
                    // Display recent reports
                    surveillanceState.intelligenceReports.slice(0, 5).forEach(report => {
                        displayIntelligence(report);
                    });
                }
            } catch (error) {
                console.error('Failed to load stored intelligence:', error);
                // Clear corrupted data
                localStorage.removeItem('djinn_intelligence');
                surveillanceState.intelligenceReports = [];
                surveillanceState.reportCount = 0;
                document.getElementById('reportCount').textContent = '0';
            }
        }

        // Start surveillance when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üßû‚Äç‚ôÇÔ∏è DJINN Council Shadow Governance System v1.0');
            console.log('Accessing shared localStorage at:', window.location.origin);
            
            // Clear old cached responses to force fresh analysis with improved prompts
            responseCache.clear();
            console.log('Cache cleared - improved analysis prompts enabled');

            // Auto-analysis disabled - event-driven only
            // setTimeout(() => {
            //     triggerCouncilAnalysis();
            // }, 2000);
            
            loadStoredIntelligence();
            initializeSurveillance();

            // Add maximize functionality
            addMaximizeFeature();

            // Set up scroll detection for advanced analysis panel
            const extendedAnalysisEl = document.getElementById('extendedAnalysisContent');
            if (extendedAnalysisEl) {
                extendedAnalysisEl.addEventListener('scroll', function() {
                    userScrolling = true;
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        userScrolling = false;
                        console.log('‚úã User finished scrolling - updates resumed');
                    }, 2000); // Resume updates 2 seconds after scrolling stops
                });
                console.log('üìú Scroll protection enabled for advanced analysis panel');
            }
            
            // Reset member statuses
            Object.values(councilMembers).forEach(member => {
                document.getElementById(member.status).textContent = 'READY';
            });

            // Initialize fixed header tooltip system
            initializeHeaderTooltips();

            // Initialize council memory system
            initializeDjinnCouncilMemory();
            addMemoryControls();
        });

        // ========================================
        // FIXED HEADER TOOLTIP SYSTEM
        // ========================================

        function initializeHeaderTooltips() {
            const tooltipDisplay = document.getElementById('tooltip-display');
            const tooltipElements = document.querySelectorAll('[data-tooltip]');

            tooltipElements.forEach(element => {
                element.addEventListener('mouseenter', function() {
                    const tooltipText = this.getAttribute('data-tooltip');
                    if (tooltipText) {
                        showTooltip(tooltipText);
                    }
                });

                element.addEventListener('mouseleave', function() {
                    hideTooltip();
                });
            });
        }

        function showTooltip(text) {
            const tooltipDisplay = document.getElementById('tooltip-display');
            tooltipDisplay.textContent = text;
            tooltipDisplay.classList.add('visible');
        }

        function hideTooltip() {
            const tooltipDisplay = document.getElementById('tooltip-display');
            tooltipDisplay.classList.remove('visible');
        }

        // ========================================
        // PREDICTIVE ANALYTICS FRAMEWORK
        // ========================================

        // Advanced predictive analytics for canvas and AI system behavior
        const predictiveAnalyticsFramework = {
            // Prediction models
            models: {
                canvasEvolution: null,
                aiPerformance: null,
                systemHarmony: null,
                memoryUsage: null
            },

            // Prediction history and accuracy tracking
            predictions: {
                made: [],
                accuracy: [],
                confidence: []
            },

            // Forecasting data
            forecastData: {
                canvas: [],
                aiSystems: [],
                correlations: [],
                memory: []
            },

            // Initialize predictive analytics
            initialize: function() {
                console.log('üîÆ Initializing Predictive Analytics Framework');
                this.buildPredictionModels();
                this.schedulePredictions();
                this.loadHistoricalData();
            },

            // Build prediction models from historical data
            buildPredictionModels: function() {
                // Canvas evolution model
                this.models.canvasEvolution = {
                    trend: 'analyzing',
                    velocity: 0,
                    confidence: 0,
                    nextPrediction: null
                };

                // AI performance model
                this.models.aiPerformance = {
                    systems: new Map(),
                    overallTrend: 'stable',
                    confidence: 0
                };

                // System harmony model
                this.models.systemHarmony = {
                    currentLevel: 0,
                    trend: 'stable',
                    predictions: []
                };

                // Memory usage model
                this.models.memoryUsage = {
                    currentUsage: 0,
                    growthRate: 0,
                    predictions: []
                };

                console.log('üîÆ Prediction models initialized');
            },

            // Load historical data for model training
            loadHistoricalData: function() {
                // Load canvas evolution history
                if (canvasEvolutionTracker && canvasEvolutionTracker.history) {
                    this.forecastData.canvas = canvasEvolutionTracker.history.slice(-50); // Last 50 snapshots
                }

                // Load correlation history
                if (crossSystemCorrelationEngine && crossSystemCorrelationEngine.correlationHistory) {
                    this.forecastData.correlations = crossSystemCorrelationEngine.correlationHistory.slice(-20); // Last 20 analyses
                }

                // Load memory analytics
                if (advancedMemoryOrchestrator && advancedMemoryOrchestrator.analytics) {
                    this.forecastData.memory = [{
                        timestamp: Date.now(),
                        efficiency: advancedMemoryOrchestrator.analytics.compressionRatio,
                        savings: advancedMemoryOrchestrator.analytics.deduplicationSavings
                    }];
                }

                console.log('üîÆ Loaded historical data:', {
                    canvas: this.forecastData.canvas.length,
                    correlations: this.forecastData.correlations.length,
                    memory: this.forecastData.memory.length
                });
            },

            // Generate canvas evolution predictions
            predictCanvasEvolution: function() {
                if (this.forecastData.canvas.length < 3) {
                    return {
                        prediction: 'insufficient_data',
                        confidence: 0,
                        timeHorizon: 'unknown'
                    };
                }

                const recent = this.forecastData.canvas.slice(-5);
                const changes = recent.filter(s => s.changes).map(s => ({
                    netChange: s.changes.netChange,
                    velocity: parseFloat(s.changes.velocity),
                    timeDelta: s.changes.timeDelta
                }));

                if (changes.length === 0) {
                    return {
                        prediction: 'no_recent_changes',
                        confidence: 0.5,
                        timeHorizon: '5_minutes'
                    };
                }

                // Calculate trend
                const avgChange = changes.reduce((sum, c) => sum + c.netChange, 0) / changes.length;
                const avgVelocity = changes.reduce((sum, c) => sum + c.velocity, 0) / changes.length;

                // Predict next change
                const trend = avgChange > 10 ? 'expanding' :
                             avgChange < -10 ? 'contracting' : 'stable';

                // Calculate confidence based on trend consistency
                const velocities = changes.map(c => c.velocity);
                const velocityVariance = this.calculateVariance(velocities);
                const confidence = Math.max(0.1, Math.min(1.0, 1 - (velocityVariance / 1000)));

                // Predict future state
                const currentLength = recent[recent.length - 1].metrics.characters;
                const predictedLength = Math.max(0, currentLength + (avgChange * 3)); // 3-step prediction
                const changePercentage = ((predictedLength - currentLength) / Math.max(currentLength, 1)) * 100;

                return {
                    prediction: trend,
                    confidence: confidence,
                    timeHorizon: '15_minutes',
                    predictedLength: Math.round(predictedLength),
                    expectedChange: Math.round(avgChange * 3),
                    changePercentage: changePercentage.toFixed(1) + '%',
                    velocity: avgVelocity.toFixed(1) + ' chars/min'
                };
            },

            // Predict AI system performance
            predictAISystemPerformance: function() {
                if (this.forecastData.correlations.length < 2) {
                    return {
                        prediction: 'analyzing',
                        confidence: 0,
                        systems: {}
                    };
                }

                const recent = this.forecastData.correlations.slice(-3);
                const systemTrends = {};

                // Analyze each AI system's performance trend
                ['narra', 'nazar', 'whale', 'djinn', 'watchtower'].forEach(system => {
                    const systemData = recent.map(c => {
                        const sysData = c.crossCorrelations.find(corr => corr.system === system);
                        return sysData ? sysData.correlation : 0;
                    }).filter(val => val > 0);

                    if (systemData.length > 0) {
                        const avgCorrelation = systemData.reduce((a, b) => a + b, 0) / systemData.length;
                        const trend = avgCorrelation > 0.6 ? 'improving' :
                                     avgCorrelation > 0.4 ? 'stable' : 'declining';

                        systemTrends[system] = {
                            trend: trend,
                            correlation: avgCorrelation.toFixed(3),
                            confidence: Math.min(1.0, systemData.length / 3)
                        };
                    }
                });

                // Overall AI performance prediction
                const avgCorrelations = Object.values(systemTrends)
                    .map(s => parseFloat(s.correlation))
                    .filter(c => !isNaN(c));

                const overallTrend = avgCorrelations.length > 0 ?
                    (avgCorrelations.reduce((a, b) => a + b, 0) / avgCorrelations.length > 0.5 ? 'improving' : 'stable') :
                    'analyzing';

                return {
                    prediction: overallTrend,
                    confidence: avgCorrelations.length > 0 ? 0.7 : 0.3,
                    systems: systemTrends,
                    averageCorrelation: avgCorrelations.length > 0 ?
                        (avgCorrelations.reduce((a, b) => a + b, 0) / avgCorrelations.length).toFixed(3) : '0.000'
                };
            },

            // Predict system harmony evolution
            predictSystemHarmony: function() {
                if (this.forecastData.correlations.length < 3) {
                    return {
                        prediction: 'analyzing',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                const recent = this.forecastData.correlations.slice(-5);
                const harmonyScores = recent.map(c => crossSystemCorrelationEngine.calculateSystemHarmony(c));

                if (harmonyScores.length === 0) {
                    return {
                        prediction: 'no_data',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                // Calculate harmony trend
                const avgHarmony = harmonyScores.reduce((a, b) => a + b, 0) / harmonyScores.length;
                const trend = avgHarmony > 70 ? 'harmonious' :
                             avgHarmony > 50 ? 'balanced' :
                             avgHarmony > 30 ? 'challenging' : 'conflicted';

                // Predict future harmony
                const slope = this.calculateSlope(harmonyScores);
                const predictedHarmony = Math.max(0, Math.min(100, avgHarmony + (slope * 3)));

                return {
                    prediction: trend,
                    confidence: Math.min(1.0, harmonyScores.length / 5),
                    currentHarmony: avgHarmony.toFixed(1) + '%',
                    predictedHarmony: predictedHarmony.toFixed(1) + '%',
                    trend: slope > 2 ? 'improving' : slope < -2 ? 'declining' : 'stable',
                    slope: slope.toFixed(2)
                };
            },

            // Predict memory usage patterns
            predictMemoryUsage: function() {
                if (this.forecastData.memory.length < 2) {
                    return {
                        prediction: 'analyzing',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                const recent = this.forecastData.memory.slice(-5);
                const efficiencies = recent.map(m => m.efficiency || 0);
                const savings = recent.map(m => m.savings || 0);

                if (efficiencies.length === 0) {
                    return {
                        prediction: 'no_data',
                        confidence: 0,
                        trend: 'unknown'
                    };
                }

                // Calculate memory efficiency trend
                const avgEfficiency = efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length;
                const avgSavings = savings.reduce((a, b) => a + b, 0) / savings.length;

                const efficiencySlope = this.calculateSlope(efficiencies);
                const trend = efficiencySlope > 0.01 ? 'improving' :
                             efficiencySlope < -0.01 ? 'declining' : 'stable';

                // Predict future efficiency
                const predictedEfficiency = Math.max(0, Math.min(1, avgEfficiency + (efficiencySlope * 5)));

                return {
                    prediction: trend,
                    confidence: Math.min(1.0, efficiencies.length / 5),
                    currentEfficiency: (avgEfficiency * 100).toFixed(1) + '%',
                    predictedEfficiency: (predictedEfficiency * 100).toFixed(1) + '%',
                    averageSavings: Math.round(avgSavings) + ' bytes',
                    trend: trend,
                    slope: efficiencySlope.toFixed(4)
                };
            },

            // Calculate variance for confidence metrics
            calculateVariance: function(values) {
                if (values.length < 2) return 0;

                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const squareDiffs = values.map(value => Math.pow(value - mean, 2));
                return squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
            },

            // Calculate slope for trend analysis
            calculateSlope: function(values) {
                if (values.length < 2) return 0;

                const n = values.length;
                const sumX = (n * (n - 1)) / 2;
                const sumY = values.reduce((a, b) => a + b, 0);
                const sumXY = values.reduce((sum, y, x) => sum + (x * y), 0);
                const sumXX = (n * (n - 1) * (2 * n - 1)) / 6;

                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                return isNaN(slope) ? 0 : slope;
            },

            // Generate comprehensive predictions
            generatePredictions: function() {
                const predictions = {
                    timestamp: Date.now(),
                    canvas: this.predictCanvasEvolution(),
                    aiSystems: this.predictAISystemPerformance(),
                    harmony: this.predictSystemHarmony(),
                    memory: this.predictMemoryUsage(),
                    overall: this.generateOverallAssessment()
                };

                // Store prediction for accuracy tracking
                this.predictions.made.push(predictions);

                // Keep only last 50 predictions
                if (this.predictions.made.length > 50) {
                    this.predictions.made.shift();
                }

                return predictions;
            },

            // Generate overall system assessment
            generateOverallAssessment: function() {
                const canvas = this.predictCanvasEvolution();
                const ai = this.predictAISystemPerformance();
                const harmony = this.predictSystemHarmony();
                const memory = this.predictMemoryUsage();

                // Calculate overall system health
                const confidences = [canvas.confidence, ai.confidence, harmony.confidence, memory.confidence];
                const avgConfidence = confidences.reduce((a, b) => a + b, 0) / confidences.length;

                // Determine overall status
                let status = 'analyzing';
                let concerns = [];
                let opportunities = [];

                // Canvas evolution assessment
                if (canvas.prediction === 'expanding') {
                    opportunities.push('Canvas content is growing - good for analysis depth');
                } else if (canvas.prediction === 'contracting') {
                    concerns.push('Canvas content is shrinking - monitor for data loss');
                }

                // AI performance assessment
                if (ai.prediction === 'improving') {
                    opportunities.push('AI system performance is improving');
                } else if (ai.prediction === 'stable') {
                    status = 'stable';
                }

                // Harmony assessment
                if (harmony.prediction === 'harmonious') {
                    opportunities.push('High system harmony detected');
                } else if (harmony.prediction === 'conflicted') {
                    concerns.push('System conflicts detected - review correlations');
                }

                // Memory assessment
                if (memory.prediction === 'improving') {
                    opportunities.push('Memory efficiency is improving');
                } else if (memory.prediction === 'declining') {
                    concerns.push('Memory efficiency declining - consider optimization');
                }

                // Overall status determination
                if (concerns.length === 0 && opportunities.length > 0) {
                    status = 'excellent';
                } else if (concerns.length <= opportunities.length) {
                    status = 'good';
                } else if (concerns.length > 0) {
                    status = 'needs_attention';
                }

                return {
                    status: status,
                    confidence: avgConfidence,
                    concerns: concerns,
                    opportunities: opportunities,
                    recommendations: this.generateRecommendations(concerns, opportunities)
                };
            },

            // Generate recommendations based on assessment
            generateRecommendations: function(concerns, opportunities) {
                const recommendations = [];

                if (concerns.includes('Canvas content is shrinking - monitor for data loss')) {
                    recommendations.push('Consider increasing canvas content generation or review AI system prompts');
                }

                if (concerns.includes('System conflicts detected - review correlations')) {
                    recommendations.push('Review AI system correlations and consider adjusting analysis parameters');
                }

                if (concerns.includes('Memory efficiency declining - consider optimization')) {
                    recommendations.push('Run memory defragmentation and review storage policies');
                }

                if (opportunities.includes('Canvas content is growing - good for analysis depth')) {
                    recommendations.push('Leverage increased content for deeper analysis and pattern recognition');
                }

                if (opportunities.includes('AI system performance is improving')) {
                    recommendations.push('Consider increasing analysis complexity or expanding system capabilities');
                }

                if (opportunities.includes('High system harmony detected')) {
                    recommendations.push('System is well-balanced - maintain current operational parameters');
                }

                return recommendations;
            },

            // Schedule prediction generation
            schedulePredictions: function() {
                // Generate predictions every 10 minutes
                setInterval(() => {
                    this.generatePredictions();
                }, 10 * 60 * 1000);

                // Update forecast data every 2 minutes
                setInterval(() => {
                    this.loadHistoricalData();
                }, 2 * 60 * 1000);
            },

            // Get current predictions
            getCurrentPredictions: function() {
                const latest = this.predictions.made[this.predictions.made.length - 1];
                if (!latest) return null;

                return {
                    canvas: {
                        trend: latest.canvas.prediction,
                        confidence: (latest.canvas.confidence * 100).toFixed(1) + '%',
                        nextChange: latest.canvas.expectedChange || 'unknown'
                    },
                    aiSystems: {
                        trend: latest.aiSystems.prediction,
                        confidence: (latest.aiSystems.confidence * 100).toFixed(1) + '%',
                        avgCorrelation: latest.aiSystems.averageCorrelation
                    },
                    harmony: {
                        status: latest.harmony.prediction,
                        confidence: (latest.harmony.confidence * 100).toFixed(1) + '%',
                        level: latest.harmony.currentHarmony
                    },
                    memory: {
                        trend: latest.memory.prediction,
                        confidence: (latest.memory.confidence * 100).toFixed(1) + '%',
                        efficiency: latest.memory.currentEfficiency
                    },
                    overall: {
                        status: latest.overall.status,
                        confidence: (latest.overall.confidence * 100).toFixed(1) + '%',
                        concerns: latest.overall.concerns.length,
                        opportunities: latest.overall.opportunities.length
                    },
                    lastUpdate: new Date(latest.timestamp).toLocaleTimeString()
                };
            }
        };

        // Initialize predictive analytics framework
        predictiveAnalyticsFramework.initialize();

        // Update predictive analytics display
        function updatePredictiveAnalytics() {
            const predictions = predictiveAnalyticsFramework.getCurrentPredictions();
            if (!predictions) {
                document.getElementById('predictiveFeed').innerHTML = `
                    <div style="color: #666; font-style: italic;">Generating initial predictions...</div>
                `;
                return;
            }

            const statusColor = predictions.overall.status === 'excellent' ? '#00ff88' :
                               predictions.overall.status === 'good' ? '#ffaa00' :
                               predictions.overall.status === 'needs_attention' ? '#ff6666' : '#666';

            document.getElementById('predictiveFeed').innerHTML = `
                <div style="margin-bottom: 12px;">
                    <strong style="color: #ffaa00;">üìä Overall Status:</strong>
                    <span style="color: ${statusColor}; margin-left: 8px; font-weight: bold;">
                        ${predictions.overall.status.toUpperCase()}
                    </span>
                    <span style="color: #666; margin-left: 8px;">
                        (${predictions.overall.confidence}% confidence)
                    </span>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #6666ff;">üìú Canvas Evolution:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Trend: <span style="color: #cc88cc;">${predictions.canvas.trend}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.canvas.confidence}</span></div>
                        <div>Next Change: <span style="color: #cc88cc;">${predictions.canvas.nextChange} chars</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #00ff88;">ü§ñ AI Systems:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Trend: <span style="color: #cc88cc;">${predictions.aiSystems.trend}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.aiSystems.confidence}</span></div>
                        <div>Avg Correlation: <span style="color: #cc88cc;">${predictions.aiSystems.avgCorrelation}</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #cc88cc;">‚öñÔ∏è System Harmony:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Status: <span style="color: #cc88cc;">${predictions.harmony.status}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.harmony.confidence}</span></div>
                        <div>Level: <span style="color: #cc88cc;">${predictions.harmony.level}</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #ff88ff;">üß† Memory Usage:</strong>
                    <div style="margin-left: 12px; margin-top: 4px;">
                        <div>Trend: <span style="color: #cc88cc;">${predictions.memory.trend}</span></div>
                        <div>Confidence: <span style="color: #cc88cc;">${predictions.memory.confidence}</span></div>
                        <div>Efficiency: <span style="color: #cc88cc;">${predictions.memory.efficiency}</span></div>
                    </div>
                </div>

                <div style="margin-bottom: 12px;">
                    <strong style="color: #ffaa00;">üí° Key Insights:</strong>
                    <div style="margin-left: 12px; margin-top: 4px; font-size: 10px; line-height: 1.4;">
                        <div>‚Ä¢ ${predictions.overall.opportunities} opportunities identified</div>
                        <div>‚Ä¢ ${predictions.overall.concerns} concerns detected</div>
                        <div>‚Ä¢ Last updated: ${predictions.lastUpdate}</div>
                    </div>
                </div>
            `;
        }

        // Event-driven synthesis report listener - DJINN Council activation
        window.addEventListener('message', function(event) {
            if (event.data.type === 'SYNTHESIS_REPORT_COMPLETE') {
                console.log('üèõÔ∏è DJINN Council activated by synthesis report');
                initiateCouncilDeliberation(event.data.synthesisReport, event.data.canvasData);
            }
        });

        // Monitor localStorage changes for real-time surveillance updates
        window.addEventListener('storage', function(event) {
            if (event.key === 'canvas_synthesis_status' || event.key === 'synthesis_progress' || event.key === 'synthesis_report_generated') {
                updateSynthesisStatusFromLocalStorage();
                updateSynthesisProgressStatus();
                console.log('üìä Surveillance panel updated from localStorage change');

                // TRIGGER ACTUAL DJINN COUNCIL ANALYSIS when synthesis report is generated
                if (event.key === 'synthesis_report_generated') {
                    setTimeout(() => {
                        const synthesisReport = localStorage.getItem('synthesis_report');
                        const canvasData = {
                            aiOutputs: [],
                            memories: JSON.parse(localStorage.getItem('ai_memory_state') || '{}'),
                            documentChanges: [],
                            canvasContent: localStorage.getItem('sovereign_canvas_content') || ''
                        };

                        if (synthesisReport) {
                            console.log('üèõÔ∏è DJINN Council activated by synthesis report generation');
                            initiateCouncilDeliberation({ content: synthesisReport, timestamp: new Date().toISOString() }, canvasData);
                        }
                    }, 1000);
                }
            }
        });

        // Poll localStorage for surveillance updates (fallback for same-window updates)
        setInterval(function() {
            // Update synthesis status first, then surveillance metrics
            updateSynthesisStatusFromLocalStorage();
            updateSynthesisProgressStatus();
            updateAllSurveillanceMetrics();
        }, 5000); // Reduced frequency from 2s to 5s to prevent excessive updates

        // Throttle updates to prevent excessive duplicate calls
        let lastMetricsUpdate = 0;
        const METRICS_UPDATE_THROTTLE = 1000; // Only allow updates every 1 second

        // Update ALL surveillance metrics with real data and persist state
        function updateAllSurveillanceMetrics() {
            // Throttle updates to prevent duplicate data source issues
            const now = Date.now();
            if (now - lastMetricsUpdate < METRICS_UPDATE_THROTTLE) {
                return; // Skip update if called too recently
            }
            lastMetricsUpdate = now;

            try {
                // Load persistent surveillance state
                const persistentState = JSON.parse(localStorage.getItem('djinn_surveillance_state') || '{}');

                // Get canvas content and calculate velocity
                const canvasContent = localStorage.getItem('sovereign_canvas_content') || '';
                const previousContent = persistentState.lastCanvasContent || surveillanceState.lastCanvasContent || '';
                const contentDiff = Math.abs(canvasContent.length - previousContent.length);
                const timeElapsed = 2; // 2 second polling interval
                const velocity = (contentDiff / timeElapsed * 60).toFixed(1); // chars per minute

                // Track velocity history for better calculations
                if (!persistentState.velocityHistory) persistentState.velocityHistory = [];
                if (velocity > 0) {
                    persistentState.velocityHistory.push({
                        velocity: parseFloat(velocity),
                        timestamp: Date.now()
                    });
                    // Keep last 10 velocity measurements
                    if (persistentState.velocityHistory.length > 10) {
                        persistentState.velocityHistory.shift();
                    }
                }

                // Calculate rolling average velocity
                const avgVelocity = persistentState.velocityHistory.length > 0
                    ? (persistentState.velocityHistory.reduce((sum, v) => sum + v.velocity, 0) / persistentState.velocityHistory.length).toFixed(1)
                    : velocity;

                // Update Evolution Trend
                const evolutionTrendEl = document.getElementById('evolutionTrend');
                if (evolutionTrendEl) {
                    const trend = contentDiff > 50 ? 'EXPANDING' : contentDiff > 10 ? 'EVOLVING' : 'STABLE';
                    evolutionTrendEl.textContent = trend;
                    evolutionTrendEl.style.color = trend === 'EXPANDING' ? '#00ff88' : trend === 'EVOLVING' ? '#ffaa00' : '#4ecdc4';
                }

                // Update Change Velocity with rolling average
                const changeVelocityEl = document.getElementById('changeVelocity');
                if (changeVelocityEl) {
                    changeVelocityEl.textContent = `${avgVelocity} chars/min`;
                    changeVelocityEl.style.color = avgVelocity > 10 ? '#ff6b6b' : avgVelocity > 1 ? '#ffaa00' : '#4ecdc4';
                }

                // History Depth is now handled by the unified metrics system above - avoid duplicate updates

                // Update Patterns
                const patternsEl = document.getElementById('patternsDetected');
                if (patternsEl) {
                    const patterns = contentDiff > 100 ? 'burst_activity' : contentDiff > 20 ? 'steady_growth' : 'stable_growth';
                    patternsEl.textContent = patterns;
                }

                // Update Rounds Completed using same data source as Agents Complete
                const roundsCompletedEl = document.getElementById('roundsCompleted');
                if (roundsCompletedEl) {
                    // Get the same synthesis status data that Agents Complete uses
                    const canvasSynthesisStatus = JSON.parse(localStorage.getItem('canvas_synthesis_status') || '{}');
                    const synthesisGenerated = localStorage.getItem('synthesis_report_generated');

                    // Ensure persistent fields exist (but don't reset them)
                    if (typeof persistentState.roundsCompleted === 'undefined') {
                        persistentState.roundsCompleted = 0;
                    }
                    if (typeof persistentState.lastSynthesisTime === 'undefined') {
                        persistentState.lastSynthesisTime = 0;
                    }

                    const currentSynthesisTime = synthesisGenerated ? parseInt(synthesisGenerated) : 0;

                    // Check if this is a genuinely new synthesis completion using same logic as Agents Complete
                    if (currentSynthesisTime > persistentState.lastSynthesisTime + 5000 && // At least 5 second gap
                        canvasSynthesisStatus.synthesisTriggered &&
                        canvasSynthesisStatus.allComplete &&
                        currentSynthesisTime > 0) {

                        persistentState.roundsCompleted++;
                        persistentState.lastSynthesisTime = currentSynthesisTime;
                        console.log(`üéØ New synthesis round completed! Total: ${persistentState.roundsCompleted} (Round: ${canvasSynthesisStatus.currentRound})`);
                    }

                    // Always display current count - synchronized with same data source as Agents Complete
                    roundsCompletedEl.textContent = persistentState.roundsCompleted;
                }

                // Update Extended Analysis with fresh synthesis data only
                const extendedAnalysisEl = document.getElementById('extendedAnalysisContent');
                if (extendedAnalysisEl) {
                    const synthesisGenerated = localStorage.getItem('synthesis_report_generated');
                    const canvasSynthesisStatus = JSON.parse(localStorage.getItem('canvas_synthesis_status') || '{}');

                    // Only show synthesis if it's recent (within last 10 minutes)
                    const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
                    const synthesisTime = synthesisGenerated ? parseInt(synthesisGenerated) : 0;

                    let newContent;
                    if (synthesisTime > tenMinutesAgo && canvasSynthesisStatus.synthesisTriggered) {
                        const lastSynthesis = localStorage.getItem('synthesis_report') || '';
                        if (lastSynthesis && lastSynthesis.length > 100) {
                            // Show recent synthesis - static content to prevent constant updates
                            const staticTimestamp = new Date(synthesisTime).toLocaleTimeString();
                            newContent = `üìä Latest Synthesis Analysis (${staticTimestamp})<br><br><pre style="white-space: pre-wrap; font-family: inherit; margin: 0; height: 100%; overflow-y: auto;">${lastSynthesis}</pre>`;
                        } else {
                            newContent = `üìä Latest Synthesis Analysis<br><br>Synthesis in progress...`;
                        }
                    } else {
                        // No recent synthesis data - only update if progress actually changes
                        const agentsComplete = canvasSynthesisStatus.completedSystems || 0;
                        newContent = `üìä Latest Synthesis Analysis<br><br>Waiting for synthesis completion...<br>Current progress: ${agentsComplete}/5 systems complete`;
                    }

                    // Only update if content actually changed (prevents scroll interruption)
                    if (extendedAnalysisEl.innerHTML !== newContent) {
                        const scrollTop = extendedAnalysisEl.scrollTop;
                        extendedAnalysisEl.innerHTML = newContent;
                        // Restore scroll position after DOM update
                        setTimeout(() => {
                            extendedAnalysisEl.scrollTop = scrollTop;
                        }, 0);
                    }
                }

                // Store current content for next comparison
                surveillanceState.lastCanvasContent = canvasContent;
                persistentState.lastCanvasContent = canvasContent;
                persistentState.lastUpdate = Date.now();

                // Persist the state to localStorage
                try {
                    localStorage.setItem('djinn_surveillance_state', JSON.stringify(persistentState));
                } catch (storageError) {
                    console.warn('Failed to persist surveillance state:', storageError);
                }

            } catch (error) {
                console.error('Error updating surveillance metrics:', error);
            }
        }

        // Initialize persistent surveillance state on load
        function initializePersistentSurveillance() {
            try {
                const persistentState = JSON.parse(localStorage.getItem('djinn_surveillance_state') || '{}');

                // Initialize missing fields - start fresh to avoid conflicting sources
                if (!persistentState.velocityHistory) persistentState.velocityHistory = [];
                if (typeof persistentState.roundsCompleted === 'undefined') {
                    // Start from 0 to avoid conflicts with old cached values
                    persistentState.roundsCompleted = 0;
                    console.log('üìä Initializing rounds counter from 0 (ignoring cached values)');
                }
                if (!persistentState.sessionStartTime) persistentState.sessionStartTime = Date.now();
                if (!persistentState.lastSynthesisTime) persistentState.lastSynthesisTime = 0;

                // Update surveillance state from persistent data
                if (persistentState.lastCanvasContent) {
                    surveillanceState.lastCanvasContent = persistentState.lastCanvasContent;
                }

                localStorage.setItem('djinn_surveillance_state', JSON.stringify(persistentState));
                console.log('üìä Persistent surveillance state initialized');
            } catch (error) {
                console.error('Failed to initialize persistent surveillance:', error);
            }
        }

        // Main DJINN Council Deliberation Function - full advanced analysis
        async function initiateCouncilDeliberation(synthesisReport, canvasData) {
            console.log('üéØ Starting DJINN Council deliberation session with full advanced analysis');

            // Prepare comprehensive analysis data with all synthesis and canvas data
            const analysisData = {
                type: 'synthesis_report_analysis',
                data: {
                    content: canvasData?.canvasContent || localStorage.getItem('sovereign_canvas_content') || '',
                    synthesisReport: synthesisReport,
                    canvasOutputs: canvasData?.aiOutputs || [],
                    canvasMemories: canvasData?.memories || {},
                    documentEvolution: canvasData?.documentChanges || [],
                    aiMemoryState: JSON.parse(localStorage.getItem('ai_memory_state') || '{}'),
                    timestamp: new Date().toISOString()
                },
                timestamp: new Date().toISOString()
            };

            console.log('üß† Initiating advanced 3-stage analysis with cross-pollination and memory integration');

            // Use existing analyze function which includes:
            // - 3-stage collaborative analysis (Stage 1: Pattern & Wisdom, Stage 2: Cross-pollinated Paradox & Boundaries, Stage 3: Memory synthesis)
            // - Advanced memory integration with referential analysis
            // - Cross-pollination between council members
            // - Consensus generation with collaborative insights
            // - Intelligence report generation with correlative analysis
            await triggerCouncilAnalysis();

            console.log('‚úÖ DJINN Council deliberation complete with full advanced analysis');
        }

        // Initialize correlative analysis framework
        if (typeof correlativeAnalysisFramework !== 'undefined') {
            correlativeAnalysisFramework.initialize();
            console.log('üîç Correlative Analysis Framework initialized and ready for synthesis report integration');
        }

        // ========================================
        // INTELLIGENCE AGENT CHAT SYSTEM
        // ========================================

        async function askIntelligenceAgent() {
            const input = document.getElementById('intelligenceInput');
            const question = input.value.trim();
            if (!question) return;

            const chatHistory = document.getElementById('intelligenceChatHistory');
            const timestamp = new Date().toLocaleTimeString();

            // Add user question to chat
            addToChatHistory(`<div style="color: #fff; margin-bottom: 10px;"><strong>üë§ You (${timestamp}):</strong> ${question}</div>`);

            // Clear input
            input.value = '';

            // Show thinking indicator
            addToChatHistory(`<div id="thinking" style="color: #ffaa00; margin-bottom: 10px;"><strong>ü§ñ Intelligence Agent:</strong> <span style="animation: pulse 1s infinite;">Analyzing comprehensive database...</span></div>`);

            try {
                // Gather ALL available data
                const comprehensiveData = await gatherComprehensiveIntelligenceData();

                // Build comprehensive prompt for AI
                const prompt = buildIntelligenceAgentPrompt(question, comprehensiveData);

                // Query Ollama with comprehensive context
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'gemma3:1b',
                        prompt: prompt,
                        stream: false
                    })
                });

                const result = await response.json();

                // Remove thinking indicator
                document.getElementById('thinking')?.remove();

                // Add AI response to chat
                addToChatHistory(`<div style="color: #4ecdc4; margin-bottom: 15px;"><strong>ü§ñ Intelligence Agent (${timestamp}):</strong><br><div style="margin-top: 5px; padding-left: 10px; border-left: 2px solid #4ecdc4; white-space: pre-wrap;">${result.response}</div></div>`);

            } catch (error) {
                document.getElementById('thinking')?.remove();
                addToChatHistory(`<div style="color: #ff6b6b; margin-bottom: 10px;"><strong>‚ùå Error:</strong> Failed to connect to AI system. ${error.message}</div>`);
            }
        }

        function addToChatHistory(html) {
            const chatHistory = document.getElementById('intelligenceChatHistory');
            chatHistory.innerHTML += html;
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        async function gatherComprehensiveIntelligenceData() {
            const data = {
                // Canvas data
                canvasContent: localStorage.getItem('sovereign_canvas_content') || '',
                canvasTimestamp: localStorage.getItem('sovereign_canvas_timestamp') || '',

                // Synthesis data
                synthesisReport: localStorage.getItem('synthesis_report') || '',
                synthesisCanvas: localStorage.getItem('synthesis_canvas_content') || '',
                synthesisGenerated: localStorage.getItem('synthesis_report_generated') || '',

                // AI Memory data - comprehensive
                aiMemoryState: JSON.parse(localStorage.getItem('ai_memory_state') || '{}'),
                aiFeeds: JSON.parse(localStorage.getItem('ai_feeds') || '[]'),
                aiEvolutionHistory: JSON.parse(localStorage.getItem('ai_evolution_history') || '[]'),

                // DJINN Council data - complete
                councilMemory: djinnCouncilMemory,
                intelligenceReports: JSON.parse(localStorage.getItem('djinn_intelligence') || '[]'),
                councilCompleteMemory: JSON.parse(localStorage.getItem('djinn_council_complete_memory') || '{}'),

                // Canvas synthesis status - detailed
                canvasSynthesisStatus: JSON.parse(localStorage.getItem('canvas_synthesis_status') || '{}'),
                synthesisProgress: localStorage.getItem('synthesis_progress') || '',
                synthesisReportGenerated: localStorage.getItem('synthesis_report_generated') || '',

                // Surveillance data - comprehensive
                surveillanceState: JSON.parse(localStorage.getItem('djinn_surveillance_state') || '{}'),

                // Correlative analysis
                correlativeAnalysis: JSON.parse(localStorage.getItem('correlative_analysis_results') || '{}'),

                // System performance metrics
                systemMetrics: {
                    totalMemoryItems: Object.values(JSON.parse(localStorage.getItem('ai_memory_state') || '{}')).reduce((total, system) => {
                        return total + (system.conversationHistory ? system.conversationHistory.length : 0);
                    }, 0),
                    evolutionSnapshots: JSON.parse(localStorage.getItem('ai_evolution_history') || '[]').length,
                    activeCouncilMembers: Object.keys(djinnCouncilMemory.members || {}).length,
                    roundsCompleted: (JSON.parse(localStorage.getItem('djinn_surveillance_state') || '{}')).roundsCompleted || 0
                },

                // System stats - enhanced
                systemStats: {
                    timestamp: new Date().toISOString(),
                    sessionDuration: Math.floor((Date.now() - (djinnCouncilMemory.sessionStart ? new Date(djinnCouncilMemory.sessionStart).getTime() : Date.now())) / 60000),
                    totalCouncilReports: Object.values(djinnCouncilMemory.members || {}).reduce((sum, member) => sum + (member.reports ? member.reports.length : 0), 0),
                    canvasSize: (localStorage.getItem('sovereign_canvas_content') || '').length,
                    wordCount: (localStorage.getItem('sovereign_canvas_content') || '').trim() ? (localStorage.getItem('sovereign_canvas_content') || '').trim().split(/\s+/).length : 0,
                    lastSynthesis: localStorage.getItem('synthesis_report_generated') ? new Date(parseInt(localStorage.getItem('synthesis_report_generated'))).toLocaleString() : 'Never'
                }
            };

            return data;
        }

        function buildIntelligenceAgentPrompt(question, data) {
            return `You are an expert Intelligence Agent with access to the Canvas AI Orchestration System and DJINN Council databases. Answer questions directly using ONLY the data provided below. DO NOT make up numbers, invent details, or speculate beyond what is shown in the data.

CRITICAL INSTRUCTIONS:
- Use ONLY the specific data provided below
- Reference actual numbers from the system metrics
- If data is not available, say "data not available" rather than guessing
- Focus on facts from the localStorage and system state

QUESTION: ${question}

REAL SYSTEM DATA:

CANVAS SYSTEM:
Content: ${data.canvasContent.substring(0, 1200)}${data.canvasContent.length > 1200 ? '...' : ''}
Size: ${data.systemStats.canvasSize} characters (${data.systemStats.wordCount} words)
Last Updated: ${data.canvasTimestamp}

SYNTHESIS REPORTS:
Latest Report: ${data.synthesisReport.substring(0, 600)}${data.synthesisReport.length > 600 ? '...' : ''}
Last Generated: ${data.systemStats.lastSynthesis}
Status: ${data.canvasSynthesisStatus.synthesisTriggered ? 'ACTIVE' : 'READY'} | All Complete: ${data.canvasSynthesisStatus.allComplete ? 'YES' : 'NO'}
Progress: ${data.synthesisProgress}

AI MEMORY SYSTEMS (${data.systemMetrics.totalMemoryItems} total items):
${Object.entries(data.aiMemoryState).map(([system, memory]) => {
    const reports = memory.conversationHistory ? memory.conversationHistory.length : 0;
    const insights = memory.keyInsights ? memory.keyInsights.length : 0;
    const lastActivity = memory.lastActivity ? new Date(memory.lastActivity).toLocaleTimeString() : 'Never';
    return `‚Ä¢ ${system.toUpperCase()}: ${reports} conversations, ${insights} insights, last: ${lastActivity}`;
}).join('\n')}

DJINN COUNCIL (Session: ${data.systemStats.sessionDuration} minutes):
Active Members: ${data.systemMetrics.activeCouncilMembers}/5
Total Reports: ${data.systemStats.totalCouncilReports}
Rounds Completed: ${data.systemMetrics.roundsCompleted}
Member Performance: ${Object.entries(data.councilMemory.members || {}).map(([name, member]) =>
    `${name}: ${member.reports ? member.reports.length : 0} reports`).join(', ')}

SYSTEM PERFORMANCE:
Evolution Snapshots: ${data.systemMetrics.evolutionSnapshots}
Memory Items: ${data.systemMetrics.totalMemoryItems}
Intelligence Reports: ${data.intelligenceReports.length}
Surveillance Data: ${Object.keys(data.surveillanceState).length} metrics tracked

RESPONSE REQUIREMENTS:
- Answer conversationally but stick to the data above
- Use exact numbers from the system metrics provided
- When referencing council members, use the actual report counts shown
- When discussing AI systems, use the specific conversation and insight counts provided
- Do NOT invent or estimate any data not explicitly shown above
- Keep responses under 300 words and focused on the actual data

Answer the question now using ONLY the data provided:`;
        }

        function clearIntelligenceChat() {
            document.getElementById('intelligenceChatHistory').innerHTML = `
                <div style="color: #4ecdc4; margin-bottom: 10px;">
                    <strong>ü§ñ Intelligence Agent initialized</strong><br>
                    <span style="color: #888; font-size: 11px;">Ready to answer questions about canvas content, AI systems, council analysis, synthesis reports, memories, and all stored data.</span>
                </div>
            `;
        }

        function toggleControls() {
            const controlsContainer = document.getElementById('djinnControls');
            const toggleBtn = document.getElementById('controlsToggleBtn');
            const djinnContainer = document.querySelector('.djinn-container');

            if (controlsContainer.classList.contains('minimized')) {
                controlsContainer.classList.remove('minimized');
                toggleBtn.textContent = 'Close Intelligence Agent Chat';
                // Expand controls area
                djinnContainer.style.gridTemplateRows = 'minmax(60px, auto) 1fr 1fr minmax(200px, 30vh)';
            } else {
                controlsContainer.classList.add('minimized');
                toggleBtn.textContent = 'Open Intelligence Agent Chat';
                // Minimize controls area, let panels expand
                djinnContainer.style.gridTemplateRows = 'minmax(60px, auto) 1fr 1fr minmax(60px, auto)';
            }
        }

        window.addEventListener('beforeunload', function() {
            if (surveillanceState.pollingTimer) {
                clearInterval(surveillanceState.pollingTimer);
            }
        });
    </script>

    <!-- Export Selection Popup -->
    <div id="exportSelectionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; font-family: 'Courier New', monospace;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; border: 2px solid #4ecdc4; border-radius: 8px; padding: 20px; max-width: 80%; max-height: 80%; overflow-y: auto; color: #ffffff;">
            <h3 style="color: #4ecdc4; margin-top: 0; text-align: center;">üìä DJINN Council Data Export Selection</h3>

            <div style="margin-bottom: 20px; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 4px;">
                <strong>Available Reports for Export:</strong>
                <div style="font-size: 12px; color: #aaa; margin-top: 5px;">Select the reports you want to include in your export package</div>
            </div>

            <div id="exportReportsList" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <!-- Reports will be populated here -->
            </div>

            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="selectAllReports()" style="padding: 8px 16px; background: #4ecdc4; color: #000; border: none; border-radius: 4px; cursor: pointer;">Select All</button>
                <button onclick="deselectAllReports()" style="padding: 8px 16px; background: #666; color: #fff; border: none; border-radius: 4px; cursor: pointer;">Deselect All</button>
                <button onclick="performExport()" style="padding: 8px 16px; background: #28a745; color: #fff; border: none; border-radius: 4px; cursor: pointer;">Export Selected</button>
                <button onclick="closeExportModal()" style="padding: 8px 16px; background: #dc3545; color: #fff; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

</body>
</html>